[
  {
    "objectID": "clases/14/index.html#ejercicio-1---urdf",
    "href": "clases/14/index.html#ejercicio-1---urdf",
    "title": "Robótica",
    "section": "Ejercicio 1 - URDF",
    "text": "Ejercicio 1 - URDF\n\nDebe estar parametrizado al menos el radio de las ruedas de tracción y la separación de las mismas\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"diffbot\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n    &lt;!-- ... --&gt;\n    &lt;xacro:property name=\"wheel_radius\" value=\"0.035\"/&gt;\n    &lt;xacro:property name=\"wheel_sep\" value=\"0.135\"/&gt;\n    &lt;!-- ... --&gt;\n    &lt;link name=\"left_wheel\"&gt;\n        &lt;!-- ... --&gt;\n        &lt;collision&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"${pi/2} 0 0\"/&gt;\n            &lt;geometry&gt;\n                &lt;cylinder radius=\"${wheel_radius}\" length=\"${wheel_width}\"/&gt;\n            &lt;/geometry&gt;\n        &lt;/collision&gt;\n\n        &lt;xacro:inertial_cylinder mass=\"${wheel_mass}\" length=\"${wheel_width}\" radius=\"${wheel_radius}\"&gt;\n            &lt;origin xyz=\"0 0 0\" rpy=\"${pi/2.0} 0 0\"/&gt;\n        &lt;/xacro:inertial_cylinder&gt;\n    &lt;/link&gt;\n&lt;/robot&gt;\n\nDeclaración de parámetros en el URDF no utilizados No aprovecha las constantes definidas por XACRO"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-1-y-2---dependencias",
    "href": "clases/14/index.html#ejercicio-1-y-2---dependencias",
    "title": "Robótica",
    "section": "Ejercicio 1 y 2 - Dependencias",
    "text": "Ejercicio 1 y 2 - Dependencias\n\n\n\ndescription.launch.py\n\nfrom launch import LaunchDescription\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.conditions import IfCondition\nfrom launch.substitutions import Command, PathJoinSubstitution, LaunchConfiguration, EqualsSubstitution\n\nfrom launch_ros.actions import Node\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n    # Ubicación del paquete y del archivo URDF\n    urdf_path = PathJoinSubstitution(\n        [FindPackageShare(\"diffbot_description\"), \"urdf\", \"diffbot_description.urdf.xacro\"]\n    )\n    \n    # Procesar archivo URDF\n    urdf = Command(['xacro ', urdf_path])\n\n    # Publicar el 'robot description'\n    node_robot_state_publisher = Node(\n        package = 'robot_state_publisher',\n        executable = 'robot_state_publisher',\n        output = 'screen',\n        parameters=[{\n            'robot_description': urdf\n        }]\n    )\n\n    # Parámetro para ejecutar el 'joint_state_publisher_gui' \n    testing_ = DeclareLaunchArgument(\n        'testing', default_value='true'\n    )\n    \n    node_joint_state_publisher_gui = Node(\n        condition = IfCondition(\n            EqualsSubstitution(LaunchConfiguration('testing'), 'true')\n        ),\n        package = 'joint_state_publisher_gui',\n        executable = 'joint_state_publisher_gui',\n        output = 'screen'\n    )\n\n    # RViz\n    node_rviz2 = Node(\n        condition=IfCondition(\n            EqualsSubstitution(LaunchConfiguration('testing'), 'true')\n        ),\n        package = 'rviz2',\n        executable = 'rviz2',\n    )\n\n    return LaunchDescription([\n        testing_,\n        node_robot_state_publisher,\n        node_joint_state_publisher_gui,\n        node_rviz2,\n    ])"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-1-y-2---dependencias-1",
    "href": "clases/14/index.html#ejercicio-1-y-2---dependencias-1",
    "title": "Robótica",
    "section": "Ejercicio 1 y 2 - Dependencias",
    "text": "Ejercicio 1 y 2 - Dependencias\n\nDependencias: xacro, robot_state_publisher, joint_state_publisher, rviz2\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\"\n    schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n&lt;package format=\"3\"&gt;\n    &lt;name&gt;diffbot_description&lt;/name&gt;\n    &lt;version&gt; .. &lt;/version&gt;\n    &lt;description&gt; .. &lt;/description&gt;\n\n    &lt;!-- ... --&gt;\n    &lt;exec_depend&gt;xacro&lt;/exec_depend&gt;\n    &lt;exec_depend&gt;robot_state_publisher&lt;/exec_depend&gt;\n\n    &lt;exec_depend&gt;joint_state_publisher_gui&lt;/exec_depend&gt;\n    &lt;exec_depend&gt;rviz2&lt;/exec_depend&gt;\n    &lt;!-- ... --&gt;\n&lt;/package&gt;\n\nDependencias no utilizadas por el paquete"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-3---gazebo",
    "href": "clases/14/index.html#ejercicio-3---gazebo",
    "title": "Robótica",
    "section": "Ejercicio 3 - Gazebo",
    "text": "Ejercicio 3 - Gazebo\n\n\nros_gz_bridge y use_sim_time\n\n\n\nCarga del robot:\n\n\n\ngazebo.launch.py\n\n    # ...\n    spawn_entity = Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        arguments=[\n            \"-entity\", \"diffbot\",\n            \"-topic\", \"robot_description\",\n            # \"-x\", \"0.0\",\n            # \"-y\", \"0.0\",\n            \"-z\", \"0.05\",   # Al menos media rueda por encima del suelo\n            # \"-Y\", \"0.0\",\n        ],\n        output=\"screen\",\n    )\n    # ...\n\n\n\n\nDependencias no utilizadas por el paquete\nUso de ‘ros_gz_bridge’ no solicitado\nParámetros adicionales no solicitados, ej ‘use_sim_time’\nEl robot inicia a la altura z=0 con referencia al base link"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-4a---ros2_control",
    "href": "clases/14/index.html#ejercicio-4a---ros2_control",
    "title": "Robótica",
    "section": "Ejercicio 4a - ros2_control",
    "text": "Ejercicio 4a - ros2_control\n\n\n\nEditar el archivo de definición del robot [..] de forma tal que las juntas correspondientes a las ruedas de tracción reciban comandos de velocidad y devuelvan el estado de posición y velocidad\n\n\n\n\nros2_control.xacro\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt;\n  &lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    &lt;hardware&gt;\n      &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n    &lt;/hardware&gt;\n    &lt;joint name=\"front_left_wheel_joint\"&gt;\n      &lt;command_interface name=\"velocity\" /&gt;\n      \n      &lt;state_interface name=\"position\" /&gt;\n      &lt;state_interface name=\"velocity\" /&gt;\n    &lt;/joint&gt;\n    &lt;joint name=\"front_right_wheel_joint\"&gt;\n      &lt;command_interface name=\"velocity\" /&gt;\n      \n      &lt;state_interface name=\"velocity\" /&gt;\n      &lt;state_interface name=\"position\" /&gt;\n    &lt;/joint&gt;\n    &lt;joint name=\"caster_rotation_joint\"&gt;\n      &lt;state_interface name=\"position\" /&gt;\n    &lt;/joint&gt;\n    &lt;joint name=\"caster_wheel_joint\"&gt;\n      &lt;state_interface name=\"position\" /&gt;\n    &lt;/joint&gt;\n  &lt;/ros2_control&gt;\n\n  &lt;gazebo&gt;\n    &lt;plugin filename=\"gz_ros2_control-system\"\n      name=\"gz_ros2_control::GazeboSimROS2ControlPlugin\"&gt;\n      &lt;parameters&gt;\n        $(find diffbot_control)/config/controllers.yaml\n      &lt;/parameters&gt;\n    &lt;/plugin&gt;\n  &lt;/gazebo&gt;\n&lt;/robot&gt;\n\n\n\n\nFaltan dependencias para el paquete ‘robot_control’\nNo respeta estructura solicitada\nLímites de velocidad a las ruedas no solicitado\nConfiguración de interfaces de estado incorrecta para las juntas"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-4b---ros2_control",
    "href": "clases/14/index.html#ejercicio-4b---ros2_control",
    "title": "Robótica",
    "section": "Ejercicio 4b - ros2_control",
    "text": "Ejercicio 4b - ros2_control\n\n\n\nCrear un paquete [..] con los parámetros necesarios para que el controller_manager de ROS2 control cargue un JointStateBroadcaster y dos controladores de velocidad de tipo JointGroupVelocityController, uno para cada rueda de tracción.\n\n\n\n\ncontrollers.yaml\n\ncontroller_manager:\n  ros__parameters:\n    update_rate: 30\n\n    joint_state_broadcaster:\n      type: joint_state_broadcaster/JointStateBroadcaster\n    \n    left_wheel_velocity_controller:\n      type: velocity_controllers/JointGroupVelocityController\n    \n    right_wheel_velocity_controller:\n      type: velocity_controllers/JointGroupVelocityController\n\nleft_wheel_velocity_controller:\n  ros__parameters:\n    joints:\n      - front_left_wheel_joint\n\n    command_interfaces:\n      - velocity\n\n    state_interfaces:\n      - position\n      - velocity\n\nright_wheel_velocity_controller:\n  ros__parameters:\n    joints:\n      - front_right_wheel_joint\n\n    command_interfaces:\n      - velocity\n\n    state_interfaces:\n      - position\n      - velocity\n\n\n\n\nLa configuración de los controladores no responde a la consigna"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-4c---ros2_control",
    "href": "clases/14/index.html#ejercicio-4c---ros2_control",
    "title": "Robótica",
    "section": "Ejercicio 4c - ros2_control",
    "text": "Ejercicio 4c - ros2_control\n\nEditar el archivo launch del ejercicio 3 para invocar al comando load_controller de ros2_control y cargar los controladores del inciso anterior.\n\n\n\n\ngazebo.launch.py\n\n    # ...\n    load_joint_state_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active', '--use-sim-time', \n             'joint_state_broadcaster'],\n        output='screen'\n    )\n    load_left_wheel_velocity_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active', '--use-sim-time', \n             'left_wheel_velocity_controller'],\n        output='screen'\n    )\n    load_right_wheel_velocity_controller = ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller', '--set-state', 'active', '--use-sim-time',\n             'right_wheel_velocity_controller'],\n        output='screen'\n    )\n    # ...\n\n\n\nEl archivo ‘launch’ debía ser el mismo que el ejercicio 3\nDelay con acciones de tipo ‘timer’ no solicitadas\nNo sigue la consigna respecto a la inicialización de los controladores"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-5-1",
    "href": "clases/14/index.html#ejercicio-5-1",
    "title": "Robótica",
    "section": "Ejercicio 5",
    "text": "Ejercicio 5\n\n\nCalcular la velocidad lineal y angular del robot y de las ruedas para que se complete:\n\nuna trayectoria recta de 1[m] en 10 [s].\nuna trayectoria circular con un radio de 0.5 [m] en sentido horario en 20 [s].\n\n\nDatos del anexo\n\nRadio de las ruedas: \\(0.035 \\textrm{[m]}\\)\nSeparación de las ruedas: \\(0.135 \\textrm{[m]}\\)"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-5---trayectoria-recta",
    "href": "clases/14/index.html#ejercicio-5---trayectoria-recta",
    "title": "Robótica",
    "section": "Ejercicio 5 - Trayectoria recta",
    "text": "Ejercicio 5 - Trayectoria recta\n\n\nUna trayectoria recta de 1[m] en 10 [s].\n\n\nV lineal del robot: \\(v = \\frac{1 \\mathrm{[m]}}{10 \\mathrm{[s]}} = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\)\nV angular del robot: \\(\\dot{\\theta} = 0\\) (linea recta)\nV lineal rueda derecha = V lineal rueda izquierda (linea recta): \\[\\upsilon_{L|R} = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\]\nV angular rueda derecha = V angular rueda izquierda: \\[\\dot\\phi_{L|R} = \\frac{v}{r} = \\frac{0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\]"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-5---trayectoria-circular",
    "href": "clases/14/index.html#ejercicio-5---trayectoria-circular",
    "title": "Robótica",
    "section": "Ejercicio 5 - Trayectoria circular",
    "text": "Ejercicio 5 - Trayectoria circular\n\n\nUna trayectoria circular con un radio de 0.5 [m] en sentido horario en 20 [s].\n\n\nV angular del robot: \\(\\require{color} \\dot{\\theta} = \\textcolor{Maroon}{-} \\frac{2 \\pi \\mathrm{[rad]}}{20 \\mathrm{[s]}} \\approx \\textcolor{Maroon}{-}0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)\nV lineal del robot: \\(v = \\dot{\\theta} \\times \\mathcal{R} = \\textcolor{Maroon}{-} 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]} \\times \\textcolor{Maroon}{-} 0.5 \\mathrm{\\left[\\frac{m}{rad}\\right]}  = 0.157 \\mathrm{\\left[\\frac{m}{s}\\right]}\\)\nV lineal rueda izquierda: \\(\\upsilon_L = \\dot{\\theta}(\\mathcal{R}-\\frac{b}{2}) = -0.314 (-0.5 - \\frac{0.135}{2}) \\approx 0.178 \\mathrm{\\left[\\frac{m}{s}\\right]}\\)\nV lineal rueda derecha: \\(\\upsilon_R = \\dot{\\theta}(\\mathcal{R}+\\frac{b}{2}) = -0.314 (-0.5 + \\frac{0.135}{2}) \\approx 0.135 \\mathrm{\\left[\\frac{m}{s}\\right]}\\)\nV angular rueda izquierda: \\(\\dot\\phi_{L} = \\frac{\\upsilon_L}{r} = \\frac{0.178 \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 5.09 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)\nV angular rueda derecha: \\(\\dot\\phi_{R} = \\frac{\\upsilon_R}{r} = \\frac{0.136 \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 3.88 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6-1",
    "href": "clases/14/index.html#ejercicio-6-1",
    "title": "Robótica",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\n\nExaminar la definición de los mensajes de tipo geometry_msgs/Twist y describir cuál sería la secuencia de comandos de velocidad a aplicar al robot para seguir la trayectoria mostrada en la Figura 1 utilizando dichos mensajes. La velocidad máxima de giro de los motores es de 50 [rpm]"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6-2",
    "href": "clases/14/index.html#ejercicio-6-2",
    "title": "Robótica",
    "section": "Ejercicio 6",
    "text": "Ejercicio 6\nTrayectoria A: punto inicial \\(\\blacksquare\\) y punto final \\(\\bullet\\)\n\nGiro antihorario con \\(\\mathcal{R} = 0.25 \\mathrm{[m]}\\)\nLinea recta \\(1 \\mathrm{[m]}\\)\nGiro horario con \\(\\mathcal{R} = 0.25 \\mathrm{[m]}\\)\nLinea recta \\(1 \\mathrm{[m]}\\)\n\nTrayectoria B: punto inicial \\(\\bullet\\) y punto final \\(\\blacksquare\\):\n\nLinea recta \\(1 \\mathrm{[m]}\\)\nGiro antihorario con \\(\\mathcal{R} = 0.25 \\mathrm{[m]}\\)\nLinea recta \\(1 \\mathrm{[m]}\\)\nGiro horario con \\(\\mathcal{R} = 0.25 \\mathrm{[m]}\\)"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---segmento-recto",
    "href": "clases/14/index.html#ejercicio-6---segmento-recto",
    "title": "Robótica",
    "section": "Ejercicio 6 - Segmento recto",
    "text": "Ejercicio 6 - Segmento recto\n\n\nPor el Ejercicio 5, la velocidad de rotación de las ruedas para una velocidad lineal de \\(0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y una velocidad angular de \\(0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) es aproximadamente \\(2.86 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\):\n\n\\[ 2.86 \\mathrm{\\left[\\frac{rad}{s}\\right]} \\approx 0.455 \\mathrm{[rps]} \\approx 27.3 \\mathrm{[rpm]} &lt; 50 \\mathrm{[rpm]}\\]\n\nPor lo tanto: un comando de \\(v = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---giro-horario",
    "href": "clases/14/index.html#ejercicio-6---giro-horario",
    "title": "Robótica",
    "section": "Ejercicio 6 - Giro horario",
    "text": "Ejercicio 6 - Giro horario\n\n\nPor el Ejercicio 5, la velocidad de rotación de las ruedas para una velocidad angular de \\(-0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y una velocidad lineal de \\(\\textcolor{Maroon}{-} 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]} \\times \\textcolor{Maroon}{-} 0.25 \\mathrm{\\left[\\frac{m}{rad}\\right]} = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) es:\n\n\\[\\dot\\phi_{L} = \\frac{\\dot{x} - \\frac{b}{2} \\dot\\theta}{r} = \\frac{0.0785 - \\frac{0.135}{2} (-0.314) \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\]\n\\[\\dot\\phi_{R} = \\frac{\\dot{x} + \\frac{b}{2} \\dot\\theta}{r} = \\frac{0.0785 + \\frac{0.135}{2} (-0.314) \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\]\n\\(2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]} \\approx 27.2 \\mathrm{[rpm]} &lt; 50 \\mathrm{[rpm]}\\) y \\(1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]} \\approx 15.6 \\mathrm{[rpm]} &lt; 50 \\mathrm{[rpm]}\\)\n\nPor lo tanto: un comando de \\(\\dot\\theta = -0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) por 10 [s]"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---giro-anti-horario",
    "href": "clases/14/index.html#ejercicio-6---giro-anti-horario",
    "title": "Robótica",
    "section": "Ejercicio 6 - Giro anti-horario",
    "text": "Ejercicio 6 - Giro anti-horario\n\n\nUtilizando la misma magnitud que el giro horario, las velocidades angulares de las ruedas son las mismas pero intercambiadas: \\(\\dot\\theta = 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\)\n\n\\[\\dot\\phi_{L} = \\frac{\\dot{x} - \\frac{b}{2} \\dot\\theta}{r} = \\frac{0.0785 - \\frac{0.135}{2} (0.314) \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\]\n\\[\\dot\\phi_{R} = \\frac{\\dot{x} + \\frac{b}{2} \\dot\\theta}{r} = \\frac{0.0785 + \\frac{0.135}{2} (0.314) \\mathrm{\\left[\\frac{m}{s}\\right]}}{0.035 \\mathrm{\\left[\\frac{m}{rad}\\right]}} \\approx 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\]\n\nPor lo tanto: un comando de \\(\\dot\\theta = 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) por 10 [s]"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---geometry_msgstwist",
    "href": "clases/14/index.html#ejercicio-6---geometry_msgstwist",
    "title": "Robótica",
    "section": "Ejercicio 6 - geometry_msgs/Twist",
    "text": "Ejercicio 6 - geometry_msgs/Twist\n\nDefinición del mensaje\n\n$ ros2 interface show geometry_msgs/msg/Twist\n\n# This expresses velocity in free space broken into its linear and\nangular parts.\n\nVector3  linear\n        float64 x     ⬅️\n        float64 y\n        float64 z\nVector3  angular\n        float64 x\n        float64 y\n        float64 z     ⬅️"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---respuesta",
    "href": "clases/14/index.html#ejercicio-6---respuesta",
    "title": "Robótica",
    "section": "Ejercicio 6 - Respuesta",
    "text": "Ejercicio 6 - Respuesta\nTrayectoria A: punto inicial \\(\\blacksquare\\) y punto final \\(\\bullet\\)\n\nGiro antihorario: \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.0785 }, angular: { z: 0.314 }}\n\nLinea recta: \\(v = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.1 }, angular: { z: 0.0 }}\n\nGiro horario: \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = -0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.0785 }, angular: { z: -0.314 }}\n\nLinea recta: \\(v = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.1 }, angular: { z: 0.0 }}"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-6---respuesta-1",
    "href": "clases/14/index.html#ejercicio-6---respuesta-1",
    "title": "Robótica",
    "section": "Ejercicio 6 - Respuesta",
    "text": "Ejercicio 6 - Respuesta\nTrayectoria B: punto inicial \\(\\bullet\\) y punto final \\(\\blacksquare\\):\n\nLinea recta: \\(v = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.1 }, angular: { z: 0.0 }}\n\nGiro antihorario: \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.0785 }, angular: { z: 0.314 }}\n\nLinea recta: \\(v = 0.1 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = 0 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.1 }, angular: { z: 0.0 }}\n\nGiro horario: \\(v = 0.0785 \\mathrm{\\left[\\frac{m}{s}\\right]}\\) y \\(\\dot\\theta = -0.314 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\n{linear: { x: 0.0785 }, angular: { z: -0.314 }}"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-7-1",
    "href": "clases/14/index.html#ejercicio-7-1",
    "title": "Robótica",
    "section": "Ejercicio 7",
    "text": "Ejercicio 7\n\nExaminar la definición de los mensajes del topic suscripto por el JointGroupVelocityController. Calcule las velocidades angulares de las ruedas para cada comando del ejercicio 6 y construya la secuencia de mensajes de comando correspondientes.\n\n\nSegmento recto:\n\n\\(\\dot\\phi_{L|R} = 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)\n\nGiro horario:\n\n\\(\\dot\\phi_{L} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\), \\(\\dot\\phi_{R} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)\n\nGiro anti-horario:\n\n\\(\\dot\\phi_{L} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\), \\(\\dot\\phi_{R} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\)"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-7---std_msgsfloat64multiarray",
    "href": "clases/14/index.html#ejercicio-7---std_msgsfloat64multiarray",
    "title": "Robótica",
    "section": "Ejercicio 7 - std_msgs/Float64MultiArray",
    "text": "Ejercicio 7 - std_msgs/Float64MultiArray\n\nDefinición del mensaje\n\n$ ros2 interface show std_msgs/msg/Float64MultiArray \n\n...\n# Please look at the MultiArrayLayout message definition for\n# documentation on all multiarrays.\n\nMultiArrayLayout  layout\nfloat64[]         data     ⬅️"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-7---respuesta",
    "href": "clases/14/index.html#ejercicio-7---respuesta",
    "title": "Robótica",
    "section": "Ejercicio 7 - Respuesta",
    "text": "Ejercicio 7 - Respuesta\nTrayectoria A: punto inicial \\(\\blacksquare\\) y punto final \\(\\bullet\\)\n\nGiro antihorario: \\(\\dot\\phi_{L} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y \\(\\dot\\phi_{R} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [1.64]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.85]}\n\nLinea recta: \\(\\dot\\phi_{L|R} = 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\n\nGiro horario: \\(\\dot\\phi_{L} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\), \\(\\dot\\phi_{R} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.85]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [1.64]}\n\nLinea recta: \\(\\dot\\phi_{L|R} = 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-7---respuesta-1",
    "href": "clases/14/index.html#ejercicio-7---respuesta-1",
    "title": "Robótica",
    "section": "Ejercicio 7 - Respuesta",
    "text": "Ejercicio 7 - Respuesta\nTrayectoria B: punto inicial \\(\\bullet\\) y punto final \\(\\blacksquare\\)\n\nLinea recta: \\(\\dot\\phi_{L|R} = 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\n\nGiro antihorario: \\(\\dot\\phi_{L} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) y \\(\\dot\\phi_{R} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [1.64]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.85]}\n\nLinea recta: \\(\\dot\\phi_{L|R} = 2.857 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.86]}\n\nGiro horario: \\(\\dot\\phi_{L} = 2.848 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\), \\(\\dot\\phi_{R} = 1.637 \\mathrm{\\left[\\frac{rad}{s}\\right]}\\) por 10 [s]\n\nros2 topic pub /left_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [2.85]}\nros2 topic pub /right_wheel_velocity_controller/commands std_msgs/msg/Float64MultiArray {data: [1.64]}"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-8---cinemática-inversa",
    "href": "clases/14/index.html#ejercicio-8---cinemática-inversa",
    "title": "Robótica",
    "section": "Ejercicio 8 - Cinemática inversa",
    "text": "Ejercicio 8 - Cinemática inversa\n\nDentro del paquete (*)_control, cree un nodo que reciba comandos de tipo geometry_msgs/Twist a través de un topic llamado /cmd_vel [..]\n\nimport rclpy\nfrom rclpy.node import Node\nfrom geometry_msgs.msg import Twist\n\nclass DiffbotControl(Node):\n    def __init__(self):\n        super().__init__('diffbot_control_node')\n        \n        # Creación de suscriptor\n        self.sub = self.create_subscription(Twist, 'cmd_vel', self.sub_callback, 10)\n\n        \n    def sub_callback(self, msg: Twist):\n        # ...\n\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n    # 2. Creación de nodo\n    nodo = DiffbotControl()\n    try:\n        # 3. Procesamiento de mensajes y callback\n        rclpy.spin(nodo)\n    else:\n        # 4. Finalización \n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n\nNo respeta nombres solicitados\nEstructura incompleta para la función ‘main’"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-8---cinemática-inversa-1",
    "href": "clases/14/index.html#ejercicio-8---cinemática-inversa-1",
    "title": "Robótica",
    "section": "Ejercicio 8 - Cinemática inversa",
    "text": "Ejercicio 8 - Cinemática inversa\n\n[..] calcule las velocidades angulares en base al modelo cinemático inverso del robot y escriba los comandos de velocidad de cada rueda de tracción en los topics left_wheel_cmd y right_wheel_cmd [..]\n\n\nModelo cinemático inverso de un robot diferencial\n\\[\n\\begin{cases}\n    \\textcolor{Plum}{\\dot\\phi_R} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} + \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta}) \\\\[0.5em]\n    \\textcolor{Plum}{\\dot\\phi_L} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} - \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta})\n\\end{cases}\n\\]\n\n\nModelo cinemático mal aplicado, calcula las velocidades lineales de las ruedas, no las angulares\nNo respeta nombre de topics solicitados"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-8---cinemática-inversa-2",
    "href": "clases/14/index.html#ejercicio-8---cinemática-inversa-2",
    "title": "Robótica",
    "section": "Ejercicio 8 - Cinemática inversa",
    "text": "Ejercicio 8 - Cinemática inversa\n\n[..] calcule las velocidades angulares en base al modelo cinemático inverso del robot y escriba los comandos de velocidad de cada rueda de tracción en los topics left_wheel_cmd y right_wheel_cmd [..]\n\n# ..\nfrom std_msgs.msg import Float64MultiArray\n\nclass DiffbotControl(Node):\n    def __init__(self):\n        # ..\n\n        # Crear los dos publisher a los topics de cada rueda\n        self.pub_lwheel = self.create_publisher(Float64MultiArray,\n            'left_wheel_velocity_controller/commands', 10)\n        self.pub_rwheel = self.create_publisher(Float64MultiArray,\n            'right_wheel_velocity_controller/commands', 10)\n        \n    def sub_callback(self, msg: Twist):\n        # Obtengo la velocidad lineal y angular deseada\n        x_dot = msg.linear.x\n        w_dot = msg.angular.z\n        \n        # Modelo cinemático inverso\n        phi_dot_lwheel = (x_dot - ((self.wheel_sep/2) * w_dot)) / self.wheel_r\n        phi_dot_rwheel = (x_dot + ((self.wheel_sep/2) * w_dot)) / self.wheel_r\n\n        # Crear los mensajes y publicar\n        lwheel_msg = Float64MultiArray()\n        lwheel_msg.data = [phi_dot_lwheel]\n        self.pub_lwheel.publish(lwheel_msg)\n\n        rwheel_msg = Float64MultiArray()\n        rwheel_msg.data = [phi_dot_rwheel]\n        self.pub_rwheel.publish(rwheel_msg)\n\n# ..\n\n\nModelo cinemático mal aplicado, calcula las velocidades lineales de las ruedas, no las angulares\nNo respeta nombre de topics solicitados"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-8---cinemática-inversa-3",
    "href": "clases/14/index.html#ejercicio-8---cinemática-inversa-3",
    "title": "Robótica",
    "section": "Ejercicio 8 - Cinemática inversa",
    "text": "Ejercicio 8 - Cinemática inversa\n\n[..] Tenga en cuenta que los parámetros del robot se encuentran en el robot description.\n\n# ..\nfrom std_msgs.msg import Float64MultiArray\n\nclass DiffbotControl(Node):\n    def __init__(self):\n        # ..\n\n        # Parámetro de separación de ruedas\n        self.declare_parameter('wheel_separation', 0.135)\n        # Parámetro de radio de rueda\n        self.declare_parameter('wheel_radius', 0.07/2)\n\n        # Obtener los parámetros\n        self.wheel_sep = self.get_parameter('wheel_separation').get_parameter_value().double_value\n        self.wheel_r = self.get_parameter('wheel_radius').get_parameter_value().double_value\n\n        # ..\n\n    def sub_callback(self, msg: Twist):\n        # ...\n\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n    # 2. Creación de nodo\n    nodo = DiffbotControl()\n    try:\n        # 3. Procesamiento de mensajes y callback\n        rclpy.spin(nodo)\n    else:\n        # 4. Finalización \n        rclpy.shutdown()\n\nif __name__ == '__main__':\n    main()\n\n\nParámetros geométricos del robot programados dentro de la clase"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-9---odometría",
    "href": "clases/14/index.html#ejercicio-9---odometría",
    "title": "Robótica",
    "section": "Ejercicio 9 - Odometría",
    "text": "Ejercicio 9 - Odometría\n\nCrear un nodo que lea el o los topics de posición de las juntas de las ruedas (publicados por el JointStateBroadcaster) [..] El nodo debe recibir como parámetro las dimensiones geométricas del modelo cinemático y los nombres correspondientes a las juntas de las ruedas de tracción.\n\nimport rclpy\nfrom rclpy.node import Node\nfrom sensor_msgs.msg import JointState\n\nclass DiffbotOdometry(Node):\n    def __init__(self):\n        super().__init__('diffbot_odometry_node')\n\n        # Parámetro de radio y separación de ruedas\n        self.declare_parameter('wheel_separation', 0.135)\n        self.declare_parameter('wheel_radius', 0.07/2)\n\n        # Parámetro para el nombre de las juntas\n        self.declare_parameter('left_wheel_name', 'front_left_wheel_joint')\n        self.declare_parameter('right_wheel_name', 'front_right_wheel_joint')\n               \n        # Crear el suscriptor al topic joint_states\n        self.sub = self.create_subscription(JointState, 'joint_states', self.sub_callback, 10)\n\n        # ..\n        \n    def sub_callback(self, msg: JointState):\n        # ...\n\n# ..\n\n\nEstructura incompleta para la función ‘main’"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-9---odometría-1",
    "href": "clases/14/index.html#ejercicio-9---odometría-1",
    "title": "Robótica",
    "section": "Ejercicio 9 - Odometría",
    "text": "Ejercicio 9 - Odometría\n\n[..] calcule la odometría basado en el modelo cinemático directo del robot y publique la misma en el topic /odom con mensajes de tipo nav_msgs/Odometry. [..]\n\n# ..\nfrom nav_msgs.msg import Odometry\n\nclass DiffbotOdometry(Node):\n    def __init__(self):\n        super().__init__('diffbot_odometry_node')\n\n        # Crear el publisher de la odometría\n        self.pub_odom = self.create_publisher(Odometry, 'odom', 10)\n\n        # ..\n        \n    def sub_callback(self, msg: JointState):\n        # Chequear si el primer elemento es el joint\n        # de la rueda izquierda o derecha\n        lwheel_ang, rwheel_ang = 0.0, 0.0\n        for name, position in zip(msg.name, msg.position):\n            if name == self.left_wheel_name:\n                lwheel_ang = position\n            if name == self.right_wheel_name:\n                rwheel_ang = position\n        \n        # Cálculo de la distancia recorrida\n        dl_k = (lwheel_ang - self.lwheel_ang_old) * self.wheel_r\n        dr_k = (rwheel_ang - self.rwheel_ang_old) * self.wheel_r\n        \n        dA_k = (dr_k + dl_k) / 2\n        Dw_k = (dr_k - dl_k) / self.wheel_sep\n\n        # Cálculo de la odometría (pose)\n        x_k_new = self.x_k + dA_k * np.cos(self.w_k)\n        y_k_new = self.y_k + dA_k * np.sin(self.w_k)\n        w_k_new = self.w_k + Dw_k\n\n        odom_msg = Odometry()\n        odom_msg.pose.pose.position.x = x_k_new\n        odom_msg.pose.pose.position.y = y_k_new\n        \n        odom_msg.pose.pose.orientation.x = 0.0\n        odom_msg.pose.pose.orientation.y = 0.0\n        odom_msg.pose.pose.orientation.z = np.sin(w_k_new/2)\n        odom_msg.pose.pose.orientation.w = np.cos(w_k_new/2)\n        \n        # Publicar\n        self.pub_odom.publish(odom_msg)\n\n        # Actualizar valores\n        self.lwheel_ang_old = lwheel_ang\n        self.rwheel_ang_old = rwheel_ang\n        self.x_k = x_k_new\n        self.y_k = y_k_new\n        self.w_k = w_k_new\n\n# ..\n\n\nLa actualización del ángulo ‘theta’ está en el orden incorrecto\nNo respeta campos solicitados para el mensaje ‘odom’\nEl modelo de odometría no es el solicitado"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-10-1",
    "href": "clases/14/index.html#ejercicio-10-1",
    "title": "Robótica",
    "section": "Ejercicio 10",
    "text": "Ejercicio 10\n\nCree un nuevo paquete (*)_bringup con un archivo launch en el cual se cargue todo el sistema desarrollado [..]\n\n\n\nbringup.launch.py\n\n# ..\ndef generate_launch_description():\n    # Launch simulation\n    simulation = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution(\n                [FindPackageShare('diffbot_gazebo'), 'launch', 'gazebo.launch.py']\n            ),\n        ),\n    )\n\n    node_diffbot_controller = Node(\n        package = 'diffbot_control',\n        executable = 'run_controller',\n        output = 'screen',\n    )\n    \n    node_diffbot_odometry = Node(\n        package = 'diffbot_control',\n        executable = 'run_odometry',\n        output = 'screen',\n    )\n\n    return LaunchDescription([\n        simulation,\n        node_diffbot_controller,\n        node_diffbot_odometry,\n    ])\n\n\n\n\nDependencias no utilizadas por el paquete\nNo incluye los archivos ‘launch’ ya desarrollados\nParámetros adicionales no solicitados, ej ‘use_sim_time’\nNodos adicionales no solicitados, ej ‘go_to_pose_controller_node’ o ‘ros_gz_bridge’\nIncluye un ejecutable incorrecto ‘odometry_publisher’"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-11---tf2",
    "href": "clases/14/index.html#ejercicio-11---tf2",
    "title": "Robótica",
    "section": "Ejercicio 11 - tf2",
    "text": "Ejercicio 11 - tf2\n\n(Opción B) Modificar el nodo del ejercicio 9 para que que publique la transformación entre los frames odom y base_link. Agregar un parámetro para que cuando no se requiera esta transformación, no se publique.\n\n# ..\nclass DiffbotOdometry(Node):\n    def __init__(self):\n        # ..      \n        # Parámetro para activar la publicación de las transformaciones\n        self.declare_parameter('publish_tf', True)\n\n        # ..\n        self.publish_tf = self.get_parameter('publish_tf').get_parameter_value().bool_value\n        if self.publish_tf:\n          # Inicializar el broadcaster\n          self.tf_broadcaster = TransformBroadcaster(self)\n        # ..\n\n    def sub_callback(self, msg: JointState):\n      # ..\n      if self.publish_tf:\n        self.send_tf()\n        \n    def send_tf(self):\n        tf = TransformStamped()\n\n        tf.header.stamp = self.get_clock().now().to_msg()\n        # Marco de referencia (padre)\n        tf.header.frame_id = 'odom'  \n        # Marco objetivo (hijo)                      \n        tf.child_frame_id = 'base_link'                 \n\n        # Traslación\n        tf.transform.translation.x = self.x_k\n        tf.transform.translation.y = self.y_k\n        tf.transform.translation.z = 0.0\n\n        # Rotación\n        tf.transform.rotation.x = 0.0\n        tf.transform.rotation.y = 0.0\n        tf.transform.rotation.z = np.sin(self.w_k/2)\n        tf.transform.rotation.w = np.cos(self.w_k/2)\n        \n        # Enviar la transformación\n        self.tf_broadcaster.sendTransform(tf)\n\n# ..\n\n\nSe supone elección de la Opcion B, pero no agrega parámetro para desactivar transformación\nCálculo de cuaternion en 3D no solicitado"
  },
  {
    "objectID": "clases/14/index.html#ejercicio-12-1",
    "href": "clases/14/index.html#ejercicio-12-1",
    "title": "Robótica",
    "section": "Ejercicio 12",
    "text": "Ejercicio 12\n\nCree un archivo launch en el paquete (*)_bringup que extienda (inclusión o copia) al del ejercicio 10 y añada la ejecución de RViz junto con su respectivo archivo de configuración, el cual muestre el robot en el frame odom y las transformaciones de todos los links definidos en el URDF.\n\n\n\nodom_tf.launch.py\n\n# ..\ndef generate_launch_description():\n    # Launch simulation\n    simulation = IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution(\n                [FindPackageShare('diffbot_gazebo'), 'launch', 'gazebo.launch.py']\n            ),\n        ),\n    )\n\n    node_diffbot_controller = Node(\n        package = 'diffbot_control',\n        executable = 'run_controller',\n        output = 'screen',\n    )\n    \n    node_diffbot_odometry = Node(\n        package = 'diffbot_control',\n        executable = 'run_odometry',\n        output = 'screen',\n        parameters = [{ 'publish_tf': True }]\n    )\n    \n    node_rviz =  Node(\n        package='rviz2',\n        executable='rviz2',\n        arguments=['-d', PathJoinSubstitution(\n                [FindPackageShare('diffbot_bringup'), 'rviz', 'odom.rviz']\n            )\n        ]\n    )\n\n    return LaunchDescription([\n        simulation,\n        node_diffbot_controller,\n        node_diffbot_odometry,\n        node_odom_view,\n        node_odom_view_gt,\n        node_rviz\n    ])\n\n# ..\n\n\n\nParámetros adicionales no solicitados, ej ‘use_sim_time’\nDelay con acciones de tipo ‘timer’ no solicitadas"
  },
  {
    "objectID": "clases/17/lab.html",
    "href": "clases/17/lab.html",
    "title": "Clase 17 - Laboratorio",
    "section": "",
    "text": "Implementar un controlador cinemático que dado un par de coordenadas objetivo envíe comandos de velocidad angular y velocidad lineal para conducir el robot a dicho punto\n\n\n\n\n\nCon el fin de mejorar la seguridad del controlador, modificar el controlador para que luego de un período significativo sin recibir mensajes de control en el topic /cmd_vel envíe un comando de parada a las juntas de las ruedas\nModificar el tipo de mensaje recibido de geometry_msgs/Twist a geometry_msgs/TwistStamped\n\n\n\n\n\n\n\nEste mecanismo de seguridad se denomina dead man’s switch\n\n\n\n\n\n\n\nCree un nodo que reciba mediante parámetros las coordenadas objetivo \\((x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel según la ley: \\[\n\\begin{cases}\n\\nu = k_\\rho \\rho \\\\\n\\omega = k_\\alpha \\alpha + k_\\beta \\beta\n\\end{cases}\n\\] donde \\[\n\\begin{gather*}\n\\rho = \\sqrt{{\\Delta x}^2 + {\\Delta y}^2} \\\\\n\\alpha = \\arctan \\left( {\\frac{\\Delta y}{\\Delta x}} \\right) - \\theta\\\\\n\\beta = -\\theta - \\alpha\n\\end{gather*}\n\\]\nLos ángulos \\(\\alpha\\) y \\(\\beta\\) deben expresarse siempre en el intervalo \\((-\\pi, \\pi)\\)\nParametrizar los coeficientes \\(k_\\rho\\), \\(k_\\beta\\) y \\(k_\\alpha\\) y realizar las verificaciones según el criterio de estabilidad \\[\nk_\\rho &gt; 0 \\quad k_\\beta &lt; 0 \\quad k_\\alpha - k_\\rho &gt; 0\n\\]\nUtilice dos parámetros adicionales \\(\\nu_{max}\\) y \\(\\omega_{max}\\) para limitar el valor máximo de velocidad lineal y velocidad angular\nUtilice un parámetro \\(\\epsilon_{tol}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo\n\n\n\n\n\nCree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nAl menos realizar 4 pruebas, con puntos en cada uno de los cuadrantes del ángulo \\(\\beta\\)"
  },
  {
    "objectID": "clases/17/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/17/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 17 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/17/lab.html#modificar-controlador-de-differential-drive",
    "href": "clases/17/lab.html#modificar-controlador-de-differential-drive",
    "title": "Clase 17 - Laboratorio",
    "section": "",
    "text": "Con el fin de mejorar la seguridad del controlador, modificar el controlador para que luego de un período significativo sin recibir mensajes de control en el topic /cmd_vel envíe un comando de parada a las juntas de las ruedas\nModificar el tipo de mensaje recibido de geometry_msgs/Twist a geometry_msgs/TwistStamped\n\n\n\n\n\n\n\nEste mecanismo de seguridad se denomina dead man’s switch"
  },
  {
    "objectID": "clases/17/lab.html#programación-del-nodo",
    "href": "clases/17/lab.html#programación-del-nodo",
    "title": "Clase 17 - Laboratorio",
    "section": "",
    "text": "Cree un nodo que reciba mediante parámetros las coordenadas objetivo \\((x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel según la ley: \\[\n\\begin{cases}\n\\nu = k_\\rho \\rho \\\\\n\\omega = k_\\alpha \\alpha + k_\\beta \\beta\n\\end{cases}\n\\] donde \\[\n\\begin{gather*}\n\\rho = \\sqrt{{\\Delta x}^2 + {\\Delta y}^2} \\\\\n\\alpha = \\arctan \\left( {\\frac{\\Delta y}{\\Delta x}} \\right) - \\theta\\\\\n\\beta = -\\theta - \\alpha\n\\end{gather*}\n\\]\nLos ángulos \\(\\alpha\\) y \\(\\beta\\) deben expresarse siempre en el intervalo \\((-\\pi, \\pi)\\)\nParametrizar los coeficientes \\(k_\\rho\\), \\(k_\\beta\\) y \\(k_\\alpha\\) y realizar las verificaciones según el criterio de estabilidad \\[\nk_\\rho &gt; 0 \\quad k_\\beta &lt; 0 \\quad k_\\alpha - k_\\rho &gt; 0\n\\]\nUtilice dos parámetros adicionales \\(\\nu_{max}\\) y \\(\\omega_{max}\\) para limitar el valor máximo de velocidad lineal y velocidad angular\nUtilice un parámetro \\(\\epsilon_{tol}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo"
  },
  {
    "objectID": "clases/17/lab.html#configuraciń-del-launch",
    "href": "clases/17/lab.html#configuraciń-del-launch",
    "title": "Clase 17 - Laboratorio",
    "section": "",
    "text": "Cree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nAl menos realizar 4 pruebas, con puntos en cada uno de los cuadrantes del ángulo \\(\\beta\\)"
  },
  {
    "objectID": "clases/11/index.html#odometría-1",
    "href": "clases/11/index.html#odometría-1",
    "title": "Robótica",
    "section": "Odometría",
    "text": "Odometría\n\nCálculo de los cambios de posición de vehículos con ruedas, utilizando información proveniente de sensores\n\n\nEn Robótica móvil se utiliza para estimar (\\(\\neq\\) determinar) la posición relativa a una posición inicial (localización relativa)\nImplementación “barata” pero tiene mala precisión a largo plazo (acumula error)"
  },
  {
    "objectID": "clases/11/index.html#definición-matemática",
    "href": "clases/11/index.html#definición-matemática",
    "title": "Robótica",
    "section": "Definición matemática",
    "text": "Definición matemática\n\nDada la pose incial \\(\\boldsymbol{\\xi}\\) en un tiempo inicial \\(t_0\\), encontrar la pose para un tiempo futuro \\(t_0 + \\Delta t\\)\n\n\\[\n\\boldsymbol{\\xi}(t_0) = \\begin{bmatrix} x_0 \\\\ y_0 \\\\ \\theta_0 \\end{bmatrix} \\quad \\textsf{Encontrar: } \\, \\boldsymbol{\\xi}(t_0 + \\Delta t) \\; \\forall \\; \\Delta t &gt; 0\n\\]\n\nCuando \\(\\Delta t\\) es lo suficientemente chico, se puede considerar que la velocidad es constante en el intervalo\nPor lo tanto se puede aproximar en un proceso iterativo usando ecuaciones de movimiento uniforme\n\n\\[\n\\boldsymbol{\\xi}(t_{k+1}) \\approx \\boldsymbol{\\xi}(t_k) + \\dot{\\boldsymbol{\\xi}}(t_k)(t_{k+1}-t_{k})\n\\]"
  },
  {
    "objectID": "clases/11/index.html#implementación",
    "href": "clases/11/index.html#implementación",
    "title": "Robótica",
    "section": "Implementación",
    "text": "Implementación\n\nLa más clásica es a través de encoders en las ruedas para obtener la velocidad de las mismas\nUsando el modelo cinemático directo (que relaciona la velocidad de las ruedas con la pose del vehículo):\n\n\\[\n\\require{color}\n{}^{O} \\boldsymbol{\\dot\\xi}_{R} (t_{k}) =\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}_k} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}_k} \\\\\n    \\textcolor{Orange}{\\dot\\theta_k}\n\\end{bmatrix}_{R}} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_{R_k}} \\\\ \\textcolor{Plum}{\\dot\\phi_{L_k}} \\end{bmatrix}\n\\]\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1}) =\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\\\\n    \\textcolor{Orange}{\\theta_{k+1}}\n\\end{bmatrix}_{R}} \\approx\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k}} \\\\\n    \\textcolor{Orange}{\\theta_{k}}\n\\end{bmatrix}_{R}} +\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}_k} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}_k} \\\\\n    \\textcolor{Orange}{\\dot\\theta_k}\n\\end{bmatrix}_{R}}\n(t_{k+1}-t_{k})\n\\]"
  },
  {
    "objectID": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial",
    "href": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial",
    "title": "Robótica",
    "section": "Calculo de odometría para un robot diferencial",
    "text": "Calculo de odometría para un robot diferencial\n\nSea \\(\\Delta t_k = t_{k+1} - t_k\\) el intervalo de tiempo entre \\(t_k\\) y \\(t_{k+1}\\)\nSea \\(\\textcolor{Plum}{\\dot\\phi_{{R|L},k}}\\) la velocidad de las ruedas der. e izq. en \\(k\\), puede aproximarse: \\[\n\\textcolor{Plum}{\\dot\\phi_{R_k}} \\approx \\frac{\\textcolor{Plum}{\\Delta \\phi_{R_k}}}{\\Delta t_k} \\qquad \\textcolor{Plum}{\\dot\\phi_{L_k}} \\approx \\frac{\\textcolor{Plum}{\\Delta \\phi_{L_k}}}{\\Delta t_k}\n\\]"
  },
  {
    "objectID": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-1",
    "href": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-1",
    "title": "Robótica",
    "section": "Calculo de odometría para un robot diferencial",
    "text": "Calculo de odometría para un robot diferencial\n\nReemplazando en el modelo cinemático:\n\n\\[\n\\begin{align}\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\\\\n    \\textcolor{Orange}{\\theta_{k+1}}\n\\end{bmatrix}_{R}} &\\approx\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k}} \\\\\n    \\textcolor{Orange}{\\theta_{k}}\n\\end{bmatrix}_{R}} +\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_{R_k}} \\\\ \\textcolor{Plum}{\\dot\\phi_{L_k}} \\end{bmatrix}\n(t_{k+1}-t_{k}) \\\\[1em]\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\\\\n    \\textcolor{Orange}{\\theta_{k+1}}\n\\end{bmatrix}_{R}} &\\approx\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k}} \\\\\n    \\textcolor{Orange}{\\theta_{k}}\n\\end{bmatrix}_{R}} +\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\frac{\\textcolor{Plum}{\\Delta \\phi_{R_k}}}{\\Delta t_k} \\\\ \\frac{\\textcolor{Plum}{\\Delta \\phi_{L_k}}}{\\Delta t_k} \\end{bmatrix}\n(\\Delta t_k)\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-2",
    "href": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-2",
    "title": "Robótica",
    "section": "Calculo de odometría para un robot diferencial",
    "text": "Calculo de odometría para un robot diferencial\n\n\\(\\Delta t_k\\) se simplifica en el cálculo de \\(\\Delta \\phi\\) para cada rueda, por lo que el cálculo de odometría a través de estas ecuaciones no depede de \\(\\Delta t\\)\n\n\\[\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\\\\n    \\textcolor{Orange}{\\theta_{k+1}}\n\\end{bmatrix}_{R}} \\approx\n\\sideset{^{O}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}} \\\\\n    \\textcolor{ForestGreen}{{y}_{k}} \\\\\n    \\textcolor{Orange}{\\theta_{k}}\n\\end{bmatrix}_{R}} +\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta_k}} & 0 \\\\\n0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\phi_{R_k}} \\\\ \\textcolor{Plum}{\\phi_{L_k}} \\end{bmatrix}\n\\]\n\n\\[\n\\begin{cases}\n\\textcolor{ForestGreen}{{x}_{k+1}} \\approx \\textcolor{ForestGreen}{{x}_{k}} + \\frac{r}{2}                   (\\textcolor{Plum}{\\phi_{R_k}} + \\textcolor{Plum}{\\phi_{L_k}}) \\cos{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n\\textcolor{ForestGreen}{{y}_{k+1}} \\approx \\textcolor{ForestGreen}{{y}_{k}} + \\frac{r}{2}                   (\\textcolor{Plum}{\\phi_{R_k}} + \\textcolor{Plum}{\\phi_{L_k}}) \\sin{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n\\textcolor{Orange}{\\theta_{k+1}}   \\approx \\textcolor{Orange}{\\theta_{k}}   + \\frac{r}{\\textcolor{Gray}{b}} (\\textcolor{Plum}{\\phi_{R_k}} - \\textcolor{Plum}{\\phi_{L_k}})\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-3",
    "href": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-3",
    "title": "Robótica",
    "section": "Calculo de odometría para un robot diferencial",
    "text": "Calculo de odometría para un robot diferencial\n\nDistancia recorrida por la rueda derecha: \\(d_{R_k} = (\\textcolor{Plum}{\\phi_{R_k}} - \\textcolor{Plum}{\\phi_{R_{k-1}}}) r\\)\nDistancia recorrida por la rueda izquierda: \\(d_{L_k} = (\\textcolor{Plum}{\\phi_{L_k}} - \\textcolor{Plum}{\\phi_{L_{k-1}}}) r\\)\nDistancia recorrida por el robot: \\(\\textcolor{Blue}{\\Delta d_{k}} = \\frac{d_{R_k} + d_{L_k}}{2}\\)\nDesplazamiento angular del robot: \\(\\textcolor{Blue}{\\Delta \\theta_k} = \\frac{d_{R_k} - d_{L_k}}{b}\\)\n\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1}) =\n\\begin{bmatrix}\n\\textcolor{ForestGreen}{{x}_{k+1}}\\\\[.5em]\n\\textcolor{ForestGreen}{{y}_{k+1}}\\\\[.5em]\n\\textcolor{Orange}{\\theta_{k+1}}  \n\\end{bmatrix} \\approx\n\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\cos{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{ForestGreen}{{y}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\sin{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{Orange}{\\theta_{k}}   + \\textcolor{Blue}{\\Delta \\theta_k}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-4",
    "href": "clases/11/index.html#calculo-de-odometría-para-un-robot-diferencial-4",
    "title": "Robótica",
    "section": "Calculo de odometría para un robot diferencial",
    "text": "Calculo de odometría para un robot diferencial\n\nProblemas\n\n\n“Dead reconing”: Siempre se suma un incremento a una estimación anterior, ambos con cierto error, por lo que este se acumula (y nunca se corrige). Si bien funciona para cortas distancias, al tiempo la estimación se desvía del valor real (generalmente mucho).\nEl modelo: por naturaleza el modelo no es exactamente lo que sucede en la realidad, sobre todo cuando los supuestos no se cumplen.\nDeslizamiento: La condición de no deslizamiento utilizada en el modelo difícilmente se cumpla siempre, y el error producido nunca se elimina.\nCalibración de parámetros: Además de las mediciones, el modelo tiene dos parámetros \\(r\\) y \\(b\\). La medición imperfecta de estos parámetros introduce un error en cada iteración. Se puede corregir con un re-ajuste."
  },
  {
    "objectID": "clases/11/index.html#taller-de-resolución-1",
    "href": "clases/11/index.html#taller-de-resolución-1",
    "title": "Robótica",
    "section": "Taller de resolución",
    "text": "Taller de resolución\nEjercicios 9 al 12"
  },
  {
    "objectID": "clases/10/index.html#cinemática-1",
    "href": "clases/10/index.html#cinemática-1",
    "title": "Robótica",
    "section": "Cinemática",
    "text": "Cinemática\n\nDef.: Rama de la mecánica que describe el de los objetos sólidos sin considerar las causas que lo originan. Estudio de la trayectoria en función del tiempo 1\n\n\n\nUtiliza velocidades y aceleraciones\nDiferencia con Dinámica (estudio de fuerzas y sus efectos)\nModelos más simples\n\n\n\n\n\n\n\n\n\n\nSe utilizará la notación de Newton para las derivadas\n\n\nVelocidad \\(\\boldsymbol{\\upsilon}\\) (primera derivada) y aceleración \\(\\boldsymbol{a}\\) (segunda derivada):\n\\[\n\\boldsymbol{\\upsilon} = \\frac{d\\boldsymbol{x}}{dt} = \\boldsymbol{\\dot{x}} \\qquad\\qquad \\boldsymbol{a} = \\frac{d^2\\boldsymbol{x}}{dt^2} = \\boldsymbol{\\ddot{x}}\n\\]\n\n\n\n\n\nWikipedia, “Cinemática”, disponible en: es.wikipedia.org/wiki/Cinemática"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático",
    "href": "clases/10/index.html#modelo-cinemático",
    "title": "Robótica",
    "section": "Modelo cinemático",
    "text": "Modelo cinemático\n\nLos modelos cinemáticos lidian con la relación entre el movimiento de las ruedas y las restricciones de movimiento de la plataforma\n\n\n\n\n\n\n\n\n\n\n\nCinemática directa\nCinemática inversa\n\n\n\n\nDado un conjunto de velocidades de las ruedas (y la geometría del robot), determinar la velocidad del robot.\nDada la velocidad del robot (y la geometría), determinar el conjunto de velocidades de las ruedas.\n\n\nAplicación: Posicionamiento\nAplicación: Control"
  },
  {
    "objectID": "clases/10/index.html#grados-de-libertad",
    "href": "clases/10/index.html#grados-de-libertad",
    "title": "Robótica",
    "section": "Grados de libertad",
    "text": "Grados de libertad\n\n\n\n\n\n\n\n\nSistemas holonómicos\nSistemas no-holonómicos\n\n\n\n\nEl sistema puede moverse instantáneamente en cualquier dirección según sus grados de libertad\nEl sistema no puede moverse instantáneamente en cualquier dirección\n\n\nSilla de oficina con rueditas\nAuto de calle"
  },
  {
    "objectID": "clases/10/index.html#locomoción",
    "href": "clases/10/index.html#locomoción",
    "title": "Robótica",
    "section": "Locomoción",
    "text": "Locomoción\n\nDef.: mecanismos que permiten al robot moverse libremente dentro de su entorno 1\n\n\n\nSe diferencia con Manipulación donde el robot está fijo y se mueven los objetos\nPara robótica móvil el uso de ruedas es eficiente en terrenos planos y firmes\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nR. Siegwart, I. R. Nourbakhsh, and D. Scaramuzza, Introduction to Autonomous Mobile Robots, 2nd ed. Cambridge, MA: MIT Press, 2011"
  },
  {
    "objectID": "clases/10/index.html#tipos-de-ruedas",
    "href": "clases/10/index.html#tipos-de-ruedas",
    "title": "Robótica",
    "section": "Tipos de ruedas",
    "text": "Tipos de ruedas\n\n\n\n3 ruedas son suficientes para garantizar estabilidad. Más de 3 requieren un sistema de suspención adecuado\nLa selección depende de la aplicación"
  },
  {
    "objectID": "clases/10/index.html#configuraciones-de-robots-con-ruedas",
    "href": "clases/10/index.html#configuraciones-de-robots-con-ruedas",
    "title": "Robótica",
    "section": "Configuraciones de robots con ruedas",
    "text": "Configuraciones de robots con ruedas"
  },
  {
    "objectID": "clases/10/index.html#robot-diferencial-1",
    "href": "clases/10/index.html#robot-diferencial-1",
    "title": "Robótica",
    "section": "Robot diferencial",
    "text": "Robot diferencial\n\n\n\nPrincipio: controlar la dirección del movimiento variando las velocidades de la rueda izq. (\\(v_L\\)) y derecha por separado (\\(v_R\\))"
  },
  {
    "objectID": "clases/10/index.html#suposiciones-para-el-modelo",
    "href": "clases/10/index.html#suposiciones-para-el-modelo",
    "title": "Robótica",
    "section": "Suposiciones para el modelo",
    "text": "Suposiciones para el modelo\n\nEl movimiento es en una superficie horizontal.\nEl contacto de las ruedas con la superficie es un punto.\nLas ruedas no son deformables.\nLas ruedas se encuentran conectadas por una estructura rígida."
  },
  {
    "objectID": "clases/10/index.html#suposiciones-para-el-modelo-1",
    "href": "clases/10/index.html#suposiciones-para-el-modelo-1",
    "title": "Robótica",
    "section": "Suposiciones para el modelo",
    "text": "Suposiciones para el modelo\n\n\n\nEl movimiento a lo largo del eje Y se conoce como rodaje (roll), cualquier otro movimiento se conoce como deslizamiento.\nSe asume que el movimiento es de rodaje puro.\nSe asume que no existe deslizamiento de ningún tipo (sliding, skidding, slipping)."
  },
  {
    "objectID": "clases/10/index.html#suposiciones-para-el-modelo-2",
    "href": "clases/10/index.html#suposiciones-para-el-modelo-2",
    "title": "Robótica",
    "section": "Suposiciones para el modelo",
    "text": "Suposiciones para el modelo\n\n\n\nNo existe fricción para una rotación alrededor del punto de contacto.\nLos ejes de rotación son ortogonales a la superficie.\nPara una vuelta completa de una rueda de radio \\(r\\), el centro se desplaza \\(2 \\pi \\, r\\)."
  },
  {
    "objectID": "clases/10/index.html#icr-instantaneous-center-of-rotation",
    "href": "clases/10/index.html#icr-instantaneous-center-of-rotation",
    "title": "Robótica",
    "section": "ICR (Instantaneous Center of Rotation)",
    "text": "ICR (Instantaneous Center of Rotation)\n\n\n\nPara un robot con múltiples ruedas, existe un punto en común de rotación denominado ICR\nLa velocidad de cada rueda debe ser consistente con la rotación de la estructura rígida de modo que no exista movimiento relativo entre ellas\n\n\n\n\n\n\n\n\n\n\n\n\nFig. 24.5a,b. de W. Chung and K. Iagnemma, “Wheeled robots” in Springer Handbook of Robotics, 2nd ed., B. Siciliano and O. Khatib, Eds. Cham, Switzerland: Springer, 2016, pp. 575–593"
  },
  {
    "objectID": "clases/10/index.html#suposiciones-para-el-modelo-de-un-r.d.",
    "href": "clases/10/index.html#suposiciones-para-el-modelo-de-un-r.d.",
    "title": "Robótica",
    "section": "Suposiciones para el modelo de un r.d.",
    "text": "Suposiciones para el modelo de un r.d.\n\n\n\nPar de ruedas montadas a lo largo de un eje y una tercera de apoyo (no activa)\nEl ICR se ubica a lo largo de este eje"
  },
  {
    "objectID": "clases/10/index.html#velocidad-angular-y-velocidad-lineal",
    "href": "clases/10/index.html#velocidad-angular-y-velocidad-lineal",
    "title": "Robótica",
    "section": "Velocidad angular y velocidad lineal",
    "text": "Velocidad angular y velocidad lineal\n\n\n\nUna rueda ubicada a \\(\\require{color} \\textcolor{ForestGreen}{\\mathcal{R}}\\) unidades del ICR, rota alrededor del ICR a lo largo de un círculo de radio \\(\\textcolor{ForestGreen}{\\mathcal{R}}\\)\nLa velocidad lineal \\(\\textcolor{Blue}{\\upsilon}\\) de una rueda puede definirse como \\(\\textcolor{Blue}{\\upsilon} = \\tfrac{2 \\pi \\textcolor{ForestGreen}{\\mathcal{R}}}{T}\\) donde \\(T\\) es el tiempo que tarda en completar una vuelta.\nLa velocidad angular \\(\\textcolor{Orange}{\\dot\\theta}\\) se define como \\(\\textcolor{Orange}{\\dot\\theta} = \\tfrac{2 \\pi}{T}\\) y tiene unidades de rad/s.\nCombinando estas dos ecuaciones, se obtiene la relación entre velocidad lineal y angular para un movimiento circular: \\[\n\\textcolor{Blue}{\\upsilon} = \\textcolor{Orange}{\\dot\\theta} \\textcolor{ForestGreen}{\\mathcal{R}}\n\\tag{1}\\]"
  },
  {
    "objectID": "clases/10/index.html#deducción-del-modelo-de-un-r.d.",
    "href": "clases/10/index.html#deducción-del-modelo-de-un-r.d.",
    "title": "Robótica",
    "section": "Deducción del modelo de un r.d.",
    "text": "Deducción del modelo de un r.d.\n\n\n\nDado el punto medio entre las ruedas \\(\\textcolor{Maroon}{P}\\) a una distancia \\(\\textcolor{ForestGreen}{R}\\) del ICR, la distancia de la rueda izquierda y la derecha al ICR es:\n\n\\[\n\\begin{cases}\n    \\mathcal{R}_L = \\textcolor{ForestGreen}{R} - \\tfrac{\\textcolor{Gray}{b}}{2}\\\\\n    \\mathcal{R}_R = \\textcolor{ForestGreen}{R} + \\tfrac{\\textcolor{Gray}{b}}{2}\n\\end{cases}\n\\]\n\n\nReemplazando en 1 (\\(\\textcolor{Blue}{\\upsilon} = \\textcolor{Orange}{\\dot\\theta} \\mathcal{R}\\)), las velocidades lineales quedan definidas como: \\[\n\\begin{cases}\n  \\textcolor{Blue}{\\upsilon_L} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} - \\tfrac{\\textcolor{Gray}{b}}{2})\\\\\n  \\textcolor{Blue}{\\upsilon_R} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\tfrac{\\textcolor{Gray}{b}}{2})\n\\end{cases}\n\\tag{2}\\]"
  },
  {
    "objectID": "clases/10/index.html#velocidad-angular-de-un-robot-diferencial",
    "href": "clases/10/index.html#velocidad-angular-de-un-robot-diferencial",
    "title": "Robótica",
    "section": "Velocidad angular de un robot diferencial",
    "text": "Velocidad angular de un robot diferencial\n\\[\n\\begin{cases}\n    \\textcolor{Blue}{\\upsilon_R} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\tfrac{\\textcolor{Gray}{b}}{2})\\\\\n    \\textcolor{Blue}{\\upsilon_L} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} - \\tfrac{\\textcolor{Gray}{b}}{2})\n\\end{cases}\n\\]\n\nRestando ambas ecuaciones y resolviendo para \\(\\textcolor{Orange}{\\dot\\theta}\\)\n\n\\[\n\\require{cancel}\n\\begin{align*}\n    \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\tfrac{\\textcolor{Gray}{b}}{2}) - \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} - \\tfrac{\\textcolor{Gray}{b}}{2}) &= \\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L} \\\\\n    \\textcolor{Orange}{\\dot\\theta} (\\cancel{\\textcolor{ForestGreen}{{R}}} + \\tfrac{\\textcolor{Gray}{b}}{2} - \\cancel{\\textcolor{ForestGreen}{{R}}} + \\tfrac{\\textcolor{Gray}{b}}{2}) &= \\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L} \\\\\n    \\textcolor{Orange}{\\dot\\theta} \\textcolor{Gray}{b} &= \\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L} \\to \\textcolor{Orange}{\\dot\\theta} = (\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}) / {\\textcolor{Gray}{b}}\\\\\n\\end{align*}\n\\]\n\nExpresión de \\(\\textcolor{Orange}{\\dot\\theta}\\) en función de las velocidades de las ruedas y la geometría:\n\n\\[\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\tag{3}\\]"
  },
  {
    "objectID": "clases/10/index.html#radio-de-giro-de-un-robot-diferencial",
    "href": "clases/10/index.html#radio-de-giro-de-un-robot-diferencial",
    "title": "Robótica",
    "section": "Radio de giro de un robot diferencial",
    "text": "Radio de giro de un robot diferencial\n\\[\n\\begin{cases}\n    \\textcolor{Blue}{\\upsilon_R} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\tfrac{\\textcolor{Gray}{b}}{2})\\\\\n    \\textcolor{Blue}{\\upsilon_L} = \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} - \\tfrac{\\textcolor{Gray}{b}}{2})\n\\end{cases}\n\\]\n\nSumando ambas ecuaciones y resolviendo para \\(\\textcolor{ForestGreen}{{R}}\\):\n\n\\[\n\\begin{align*}\n    \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\tfrac{\\textcolor{Gray}{b}}{2}) + \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} - \\tfrac{\\textcolor{Gray}{b}}{2}) &= \\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}\\\\\n    \\textcolor{Orange}{\\dot\\theta} (\\textcolor{ForestGreen}{{R}} + \\cancel{\\tfrac{\\textcolor{Gray}{b}}{2}} + \\textcolor{ForestGreen}{{R}} - \\cancel{\\tfrac{\\textcolor{Gray}{b}}{2}}) &= \\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L} \\\\\n    2 \\textcolor{ForestGreen}{{R}} \\, \\textcolor{Orange}{\\dot\\theta} &= \\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L} \\to \\textcolor{ForestGreen}{{R}} = (\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}) / {2 \\textcolor{Orange}{\\dot\\theta}} \\\\\n    %R &= \\frac{\\upsilon_R + \\upsilon_L}{2 \\dot\\omega}\n\\end{align*}\n\\]\n\nReemplazando con 3, expresión de \\(\\textcolor{ForestGreen}{{R}}\\) en función de las velocidades de las ruedas y la geometría: \\[\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{2 \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}} \\to \\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.",
    "href": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.",
    "title": "Robótica",
    "section": "Casos particulares del modelo de r.d.",
    "text": "Casos particulares del modelo de r.d.\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\end{split}\n\\]\n\nTres casos particulares:\n\n\\[\n\\begin{array}{lllc}\n\\textcolor{white}{{\\upsilon_R} = {\\upsilon_L}}  & \\textcolor{white}{{\\dot\\theta} = 0} & \\textcolor{white}{{{R}} = \\infty} & \\textcolor{white}{\\text{Movimiento en línea recta}} \\\\\n\\hline\n\\textcolor{white}{{\\upsilon_L} = -{\\upsilon_R}} & \\textcolor{white}{{\\dot\\theta} = \\begin{cases}\\tfrac{2 {\\upsilon_R}}{{b}} \\\\[.25em] \\tfrac{-2 {\\upsilon_L}}{{b}} \\end{cases}} & \\textcolor{white}{{{R}} = 0} & \\textcolor{white}{\\text{Movimiento de rotación}} \\\\\n\\hline\n\\begin{array}{l}\n\\textcolor{white}{{\\upsilon_L} = 0 \\; \\text{y} \\; {\\upsilon_R} \\neq 0}  \\\\[.25em] \\textcolor{white}{{\\upsilon_R} = 0 \\; \\text{y} \\; {\\upsilon_L} \\neq 0}\n\\end{array} & \\textcolor{white}{{\\dot\\theta} = \\begin{cases}\\tfrac{{\\upsilon_R}}{{b}} \\\\[.25em]  \\tfrac{-{\\upsilon_L}}{{b}} \\end{cases}} & \\textcolor{white}{{{R}} = \\begin{cases} \\tfrac{{b}}{2} \\\\[.25em]  \\tfrac{-{b}}{2} \\end{cases}} & \\textcolor{white}{\\text{Rotación sobre una rueda}} \\\\\n\\end{array}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-1",
    "href": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-1",
    "title": "Robótica",
    "section": "Casos particulares del modelo de r.d.",
    "text": "Casos particulares del modelo de r.d.\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\end{split}\n\\]\n\nTres casos particulares:\n\n\\[\n\\begin{array}{lllc}\n\\textcolor{Blue}{\\upsilon_R} = \\textcolor{Blue}{\\upsilon_L}  & \\textcolor{Orange}{\\dot\\theta} = 0 & \\textcolor{ForestGreen}{{R}} = \\infty & \\text{Movimiento en línea recta} \\\\\n\\hline\n\\textcolor{white}{{\\upsilon_L} = -{\\upsilon_R}} & \\textcolor{white}{{\\dot\\theta} = \\begin{cases}\\tfrac{2 {\\upsilon_R}}{{b}} \\\\[.25em] \\tfrac{-2 {\\upsilon_L}}{{b}} \\end{cases}} & \\textcolor{white}{{{R}} = 0} & \\textcolor{white}{\\text{Movimiento de rotación}} \\\\\n\\hline\n\\begin{array}{l}\n\\textcolor{white}{{\\upsilon_L} = 0 \\; \\text{y} \\; {\\upsilon_R} \\neq 0}  \\\\[.25em] \\textcolor{white}{{\\upsilon_R} = 0 \\; \\text{y} \\; {\\upsilon_L} \\neq 0}\n\\end{array} & \\textcolor{white}{{\\dot\\theta} = \\begin{cases}\\tfrac{{\\upsilon_R}}{{b}} \\\\[.25em]  \\tfrac{-{\\upsilon_L}}{{b}} \\end{cases}} & \\textcolor{white}{{{R}} = \\begin{cases} \\tfrac{{b}}{2} \\\\[.25em]  \\tfrac{-{b}}{2} \\end{cases}} & \\textcolor{white}{\\text{Rotación sobre una rueda}} \\\\\n\\end{array}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-2",
    "href": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-2",
    "title": "Robótica",
    "section": "Casos particulares del modelo de r.d.",
    "text": "Casos particulares del modelo de r.d.\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\end{split}\n\\]\n\nTres casos particulares:\n\n\\[\n\\begin{array}{lllc}\n\\textcolor{Blue}{\\upsilon_R} = \\textcolor{Blue}{\\upsilon_L}  & \\textcolor{Orange}{\\dot\\theta} = 0 & \\textcolor{ForestGreen}{{R}} = \\infty & \\text{Movimiento en línea recta} \\\\\n\\hline\n\\textcolor{Blue}{\\upsilon_L} = -\\textcolor{Blue}{\\upsilon_R} & \\textcolor{Orange}{\\dot\\theta} = \\begin{cases}\\tfrac{2 \\textcolor{Blue}{\\upsilon_R}}{\\textcolor{Gray}{b}} \\\\[.25em] \\tfrac{-2 \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}} \\end{cases} & \\textcolor{ForestGreen}{{R}} = 0 & \\text{Movimiento de rotación} \\\\\n\\hline\n\\begin{array}{l}\n\\textcolor{white}{{\\upsilon_L} = 0 \\; \\text{y} \\; {\\upsilon_R} \\neq 0}  \\\\[.25em] \\textcolor{white}{{\\upsilon_R} = 0 \\; \\text{y} \\; {\\upsilon_L} \\neq 0}\n\\end{array} & \\textcolor{white}{{\\dot\\theta} = \\begin{cases}\\tfrac{{\\upsilon_R}}{{b}} \\\\[.25em]  \\tfrac{-{\\upsilon_L}}{{b}} \\end{cases}} & \\textcolor{white}{{{R}} = \\begin{cases} \\tfrac{{b}}{2} \\\\[.25em]  \\tfrac{-{b}}{2} \\end{cases}} & \\textcolor{white}{\\text{Rotación sobre una rueda}} \\\\\n\\end{array}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-3",
    "href": "clases/10/index.html#casos-particulares-del-modelo-de-r.d.-3",
    "title": "Robótica",
    "section": "Casos particulares del modelo de r.d.",
    "text": "Casos particulares del modelo de r.d.\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\end{split}\n\\]\n\nTres casos particulares:\n\n\\[\n\\begin{array}{lllc}\n\\textcolor{Blue}{\\upsilon_R} = \\textcolor{Blue}{\\upsilon_L}  & \\textcolor{Orange}{\\dot\\theta} = 0 & \\textcolor{ForestGreen}{{R}} = \\infty & \\text{Movimiento en línea recta} \\\\\n\\hline\n\\textcolor{Blue}{\\upsilon_L} = -\\textcolor{Blue}{\\upsilon_R} & \\textcolor{Orange}{\\dot\\theta} = \\begin{cases}\\tfrac{2 \\textcolor{Blue}{\\upsilon_R}}{\\textcolor{Gray}{b}} \\\\[.25em] \\tfrac{-2 \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}} \\end{cases} & \\textcolor{ForestGreen}{{R}} = 0 & \\text{Movimiento de rotación} \\\\\n\\hline\n\\begin{array}{l}\n\\textcolor{Blue}{\\upsilon_L} = 0 \\; \\text{y} \\; \\textcolor{Blue}{\\upsilon_R} \\neq 0  \\\\[.25em] \\textcolor{Blue}{\\upsilon_R} = 0 \\; \\text{y} \\; \\textcolor{Blue}{\\upsilon_L} \\neq 0\n\\end{array} & \\textcolor{Orange}{\\dot\\theta} = \\begin{cases}\\tfrac{\\textcolor{Blue}{\\upsilon_R}}{\\textcolor{Gray}{b}} \\\\[.25em]  \\tfrac{-\\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}} \\end{cases} & \\textcolor{ForestGreen}{{R}} = \\begin{cases} \\tfrac{\\textcolor{Gray}{b}}{2} \\\\[.25em]  \\tfrac{-\\textcolor{Gray}{b}}{2} \\end{cases} & \\text{Rotación sobre una rueda} \\\\\n\\end{array}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#velocidades-angulares-de-las-ruedas",
    "href": "clases/10/index.html#velocidades-angulares-de-las-ruedas",
    "title": "Robótica",
    "section": "Velocidades angulares de las ruedas",
    "text": "Velocidades angulares de las ruedas\n\n\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Gray}{b}}\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Blue}{\\upsilon_R} + \\textcolor{Blue}{\\upsilon_L}}{\\textcolor{Blue}{\\upsilon_R} - \\textcolor{Blue}{\\upsilon_L}}\n\\end{split}\n\\]\n\nSea \\(\\textcolor{Plum}{\\dot\\phi}\\) la velocidad de rotación de la rueda: \\[\\textcolor{Blue}{\\upsilon} = \\textcolor{Plum}{\\dot\\phi} \\, r\\]\n\n\n\nReemplazando para \\(\\textcolor{Blue}{\\upsilon_R}\\) y \\(\\textcolor{Blue}{\\upsilon_L}\\):\n\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}\n\\end{split}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#velocidades-lineales-del-robot-diferencial",
    "href": "clases/10/index.html#velocidades-lineales-del-robot-diferencial",
    "title": "Robótica",
    "section": "Velocidades lineales del robot diferencial",
    "text": "Velocidades lineales del robot diferencial\n\n\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}\n\\end{split}\n\\]\n\nSea \\(\\textcolor{ForestGreen}{\\dot{x}}\\) e \\(\\textcolor{ForestGreen}{\\dot{y}}\\) la velocidad lineal del robot en los ejes \\(\\textcolor{Maroon}{\\boldsymbol{x}_R}\\) e \\(\\textcolor{Maroon}{\\boldsymbol{y}_R}\\)\nUtilizando la ecuación de velocidad angular: \\[\n\\require{cancel}\n\\begin{align*}\n  {}^\\textcolor{Maroon}{R}\\textcolor{ForestGreen}{\\dot{x}} = \\textcolor{Orange}{\\dot\\theta} \\, R &=  \\frac{r}{{\\textcolor{Gray}{b}}} {(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})} \\, \\frac{{\\textcolor{Gray}{b}}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}}\\\\\n  {}^\\textcolor{Maroon}{R}\\textcolor{ForestGreen}{\\dot{x}} &= \\frac{r}{2} \\, (\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L})\n\\end{align*}\n\\]\n\n\n\n\n\n\n\n\nQue pasa con \\(\\textcolor{ForestGreen}{\\dot{y}}\\) ?"
  },
  {
    "objectID": "clases/10/index.html#velocidades-lineales-del-robot-diferencial-1",
    "href": "clases/10/index.html#velocidades-lineales-del-robot-diferencial-1",
    "title": "Robótica",
    "section": "Velocidades lineales del robot diferencial",
    "text": "Velocidades lineales del robot diferencial\n\n\n\\[\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}\n\\end{split}\n\\]\n\nSea \\(\\textcolor{ForestGreen}{\\dot{x}}\\) e \\(\\textcolor{ForestGreen}{\\dot{y}}\\) la velocidad lineal del robot en los ejes \\(\\textcolor{Maroon}{\\boldsymbol{x}_R}\\) e \\(\\textcolor{Maroon}{\\boldsymbol{y}_R}\\)\nUtilizando la ecuación de velocidad angular: \\[\n\\begin{align*}\n  {}^\\textcolor{Maroon}{R}\\textcolor{ForestGreen}{\\dot{x}} &= \\frac{r}{2} \\, (\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L})\\\\\n  {}^\\textcolor{Maroon}{R}\\textcolor{ForestGreen}{\\dot{y}} &= 0\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-de-un-robot-diferencial",
    "href": "clases/10/index.html#modelo-cinemático-de-un-robot-diferencial",
    "title": "Robótica",
    "section": "Modelo cinemático de un robot diferencial",
    "text": "Modelo cinemático de un robot diferencial\n\n\n\nSe define un marco inercial \\(\\textcolor{Blue}{\\mathcal{O}: \\{ \\mathcal{X}_O, \\mathcal{Y}_O \\}}\\) y un marco de referencia local del robot \\(\\textcolor{Maroon}{\\mathcal{P}: \\{ \\mathcal{X}_R, \\mathcal{Y}_R \\}}\\)\n\n\n\nLa velocidad del robot en el marco local:\n\n\\[\n{}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot \\xi}_\\textcolor{Maroon}{P} =\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{pmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{pmatrix}_\\textcolor{Maroon}{P}} =\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{pmatrix}\n    \\frac{r}{2} \\, (\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L})\\\\\n    0 \\\\\n    \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{pmatrix}_\\textcolor{Maroon}{P}}\n\\]\n\n\n\nExpresado en forma matricial \\[\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n  \\textcolor{ForestGreen}{\\dot{x}} \\\\\n  \\textcolor{ForestGreen}{\\dot{y}} \\\\\n  \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}_\\textcolor{Maroon}{P}} = \\begin{bmatrix}\n  \\frac{r}{2} & \\frac{r}{2}\\\\\n  0 & 0\\\\\n  \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n\\tag{4}\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.",
    "href": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.",
    "title": "Robótica",
    "section": "Modelo cinemático directo de un r.d.",
    "text": "Modelo cinemático directo de un r.d.\n\nModelo cinemático directo: Dada las velocidades de las ruedas, la orientación actual y la geometría del robot, obtener la velocidad en el marco global.\n\n\\[\n\\boldsymbol{f}(\\textcolor{Gray}{b}, r, \\textcolor{Orange}{\\theta}, \\textcolor{Plum}{\\dot\\phi_R}, \\textcolor{Plum}{\\dot\\phi_L} ) = \\sideset{^\\textcolor{Blue}{O}}{}{\\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R}} = \\sideset{^\\textcolor{Blue}{O}}{}{\\begin{bmatrix} \\textcolor{ForestGreen}{\\dot{x}} \\\\ \\textcolor{ForestGreen}{\\dot{y}} \\\\ \\textcolor{Orange}{\\dot\\theta} \\end{bmatrix}_\\textcolor{Maroon}{R}}\n\\]\n\n\nDada \\(\\boldsymbol{R}(\\textcolor{Orange}{\\theta})\\) la matriz de rotación entre el marco local \\(\\textcolor{Maroon}{R}\\) y el global \\(\\textcolor{Blue}{O}\\):\n\n\\[\n{}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} = \\boldsymbol{R}(\\textcolor{Orange}{\\theta}) {}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{P} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}_\\textcolor{Maroon}{P}}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.-1",
    "href": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.-1",
    "title": "Robótica",
    "section": "Modelo cinemático directo de un r.d.",
    "text": "Modelo cinemático directo de un r.d.\n\\[\n{}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}_\\textcolor{Maroon}{P}}\n\\]\n\nUtilizando la definición de 4:\n\n\\[\n{}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n\\]\n\\[\n\\boldsymbol{f}(\\textcolor{Gray}{b}, r, \\textcolor{Orange}{\\theta}, \\textcolor{Plum}{\\dot\\phi_R}, \\textcolor{Plum}{\\dot\\phi_L} ) =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.-2",
    "href": "clases/10/index.html#modelo-cinemático-directo-de-un-r.d.-2",
    "title": "Robótica",
    "section": "Modelo cinemático directo de un r.d.",
    "text": "Modelo cinemático directo de un r.d.\n\nNombrando \\(\\textcolor{ForestGreen}{V}\\) a la velocidad lineal en el eje \\(\\textcolor{Maroon}{\\boldsymbol{x}_R}\\) del marco local del robot:\n\n\\[\n\\textcolor{ForestGreen}{V} = {}^\\textcolor{Maroon}{R}\\textcolor{ForestGreen}{\\dot{x}} = \\frac{r}{2} \\, (\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L})\n\\]\n\nSabiendo que \\(\\textcolor{Orange}{\\dot\\theta} =  \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\\), podemos escribir de forma abreviada:\n\n\\[\n\\boldsymbol{f}(\\textcolor{Gray}{b}, r, \\textcolor{Orange}{\\theta}, \\textcolor{Plum}{\\dot\\phi_R}, \\textcolor{Plum}{\\dot\\phi_L} ) =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 1\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{ForestGreen}{V} \\\\ \\textcolor{Orange}{\\dot\\theta} \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.",
    "href": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.",
    "title": "Robótica",
    "section": "Modelo cinemático inverso de un r.d.",
    "text": "Modelo cinemático inverso de un r.d.\n\nModelo cinemático inverso: Dada la velocidad del robot, la orientación actual y la geometría del robot, obtener las velocidades de las ruedas.\n\n\\[\n\\boldsymbol{g}(\\textcolor{Gray}{b}, r, \\textcolor{Orange}{\\theta}, {}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} ) = \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} & \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix} \\Rightarrow \\boldsymbol{f}^{-1} = {( {}^\\textcolor{Blue}{O}{\\boldsymbol{\\dot\\xi}}_\\textcolor{Maroon}{R} )}^{-1} = \\sideset{^\\textcolor{Maroon}{R}}{_\\textcolor{Blue}{O}}{\\boldsymbol{\\dot\\xi}}\n\\]\n\n\nComo está planteado el problema, no es invertible:\n\n\\[\n\\boldsymbol{g} = \\boldsymbol{f}^{-1} =\n\\left(\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n\\right)^{-1}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.-1",
    "href": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.-1",
    "title": "Robótica",
    "section": "Modelo cinemático inverso de un r.d.",
    "text": "Modelo cinemático inverso de un r.d.\n\nSabiendo que no hay velocidad en la componente \\(\\textcolor{Maroon}{\\boldsymbol{y}_R}\\) del robot, es posible reducir 4 a dos ecuaciones:\n\n\\[\n\\begin{gather*}\n{}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot \\xi}_\\textcolor{Maroon}{P} =\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}_\\textcolor{Maroon}{P}} = \\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\\\\[0.5em]\n\\downarrow\\\\[0.5em]\n\\overline{{}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot \\xi}_\\textcolor{Maroon}{P}} =\n\\sideset{^\\textcolor{Maroon}{R}}{_\\textcolor{Maroon}{P}}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\ \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}} =\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix}\n\\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n\\end{gather*}\n\\]"
  },
  {
    "objectID": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.-2",
    "href": "clases/10/index.html#modelo-cinemático-inverso-de-un-r.d.-2",
    "title": "Robótica",
    "section": "Modelo cinemático inverso de un r.d.",
    "text": "Modelo cinemático inverso de un r.d.\n\nInvirtiendo el sistema:\n\n\\[\n\\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix} =\n\\begin{bmatrix}\n    \\tfrac{r}{2} & \\tfrac{r}{2}\\\\\n    \\tfrac{r}{b} & -\\tfrac{r}{b}\n\\end{bmatrix}^{-1}\n\\sideset{^\\textcolor{Maroon}{R}}{}{\n\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\ \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}} =\n\\begin{bmatrix}\n    \\tfrac{1}{r} & \\tfrac{b}{2r}\\\\\n    \\tfrac{1}{r} & - \\tfrac{b}{2r}\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\ \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}\n\\]\n\n\nDe forma simplificada:\n\n\\[\n\\begin{cases}\n    \\textcolor{Plum}{\\dot\\phi_R} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} + \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta}) \\\\[0.5em]\n    \\textcolor{Plum}{\\dot\\phi_L} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} - \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta})\n\\end{cases}\n\\]\n\n\n\nSe puede verificar reemplazando la definición 1 en 2 y \\(\\upsilon = \\dot\\phi \\, r\\)"
  },
  {
    "objectID": "clases/10/index.html#taller-de-resolución-1",
    "href": "clases/10/index.html#taller-de-resolución-1",
    "title": "Robótica",
    "section": "Taller de resolución",
    "text": "Taller de resolución\nEjercicios 5 al 8"
  },
  {
    "objectID": "clases/02/lab.html",
    "href": "clases/02/lab.html",
    "title": "Clase 02 - Laboratorio",
    "section": "",
    "text": "Windows 10 / 11 (WSL)Ubuntu 24.04Docker\n\n\n\n\n\n\n\n\nImportantAntes de iniciar\n\n\n\nSe necesitan todas las últimas actualizaciones de Windows instaladas\n\n\n\n\n\n    $ wsl --install\n\n\nVer salida\n\nLa operación solicitada requiere elevación.\nDescargando: Subsistema de Windows para Linux 2.4.13\nInstalando: Subsistema de Windows para Linux 2.4.13\nSe ha instalado Subsistema de Windows para Linux 2.4.13.\nInstalando componente opcional de Windows: VirtualMachinePlatform\n\nHerramienta Administración y mantenimiento de imágenes de implementación\nVersión: 10.0.26100.1150\n\nVersión de imagen: 10.0.26100.3624\n\nHabilitando características\n[==========================100.0%==========================]\nLa operación se completó correctamente.\nLa operación solicitada se realizó correctamente. Los cambios se aplicarán una vez que se reinicie el sistema.\nLa operación solicitada se realizó correctamente. Los cambios se aplicarán una vez que se reinicie el sistema.\n\n\n\n\n\n\n\nNoteRecomendación\n\n\n\nSe recomienda reiniciar la PC después de esta instalación inicial para finalizar el setup\n\n\n\n\n\n\nPara ver todas las distribuciones y versiones disponibles:\n    $ wsl --list --online\n\n\nVer salida\n\nA continuación, se muestra una lista de las distribuciones válidas que se pueden instalar.\nInstalar con \"wsl.exe --install &lt;Distro&gt;\".\n\nNAME                            FRIENDLY NAME\nAlmaLinux-8                     AlmaLinux OS 8\nAlmaLinux-9                     AlmaLinux OS 9\nAlmaLinux-Kitten-10             AlmaLinux OS Kitten 10\nDebian                          Debian GNU/Linux\nSUSE-Linux-Enterprise-15-SP5    SUSE Linux Enterprise 15 SP5\nSUSE-Linux-Enterprise-15-SP6    SUSE Linux Enterprise 15 SP6\nUbuntu                          Ubuntu\nUbuntu-24.04                    Ubuntu 24.04 LTS\nkali-linux                      Kali Linux Rolling\nopenSUSE-Tumbleweed             openSUSE Tumbleweed\nopenSUSE-Leap-15.6              openSUSE Leap 15.6\nUbuntu-18.04                    Ubuntu 18.04 LTS\nUbuntu-20.04                    Ubuntu 20.04 LTS\nUbuntu-22.04                    Ubuntu 22.04 LTS\nOracleLinux_7_9                 Oracle Linux 7.9\nOracleLinux_8_7                 Oracle Linux 8.7\nOracleLinux_9_1                 Oracle Linux 9.1\n\nPara instalar\n    $ wsl --install -d Ubuntu-24.04\n\n\nVer salida\n\nDescargando: Ubuntu 24.04 LTS\nInstalando: Ubuntu 24.04 LTS\nDistribución instalada correctamente.\n\n\n\n\n\n    $ wsl -d Ubuntu-24.04\n\n\nVer salida\n\nProvisioning the new WSL instance Ubuntu-24.04\nThis might take a while...\nCreate a default Unix user account: ubuntu\nNew password:\nRetype new password:\npasswd: password updated successfully\nTo run a command as administrator (user \"root\"), use \"sudo &lt;command&gt;\".\nSee \"man sudo_root\" for details.\n\n\n\n\n\n\n\n\nNote\n\n\n\nContinuar con la creación de usuario y contraseña\n\n\n\n\n\n\nTraducido de documentation.ubuntu.com/wsl\n\n\n\n\n\n\n\n\n\nWarningActualizar el sistema\n\n\n\n    $ sudo apt update\n    $ sudo apt upgrade -y\n\n\n\n\n\n    $ sudo apt install software-properties-common curl -y\n    $ sudo add-apt-repository universe\nAgregar la key GPG de ROS 2\n    $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\nAgregar repositorio a la source list\n    $ echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n\n\n\n\nActualizar repositorios apt y asegurar que los paquetes se encuentren actualizados\n    $ sudo apt update && sudo apt upgrade -y\nInstalación Desktop: ROS, RViz, demos, etc.\n    $ sudo apt install ros-jazzy-desktop -y\n\nTraducido de docs.ros.org\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer contenido del archivo\n\n\n\ndevcontainer.json\n\n// For format details, see https://aka.ms/devcontainer.json.\n{\n    \"name\": \"TUAR - ROS2 Jazzy\",\n    // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile\n    \"image\": \"registry.gitlab.com/acapovilla/ros-docker-images/ros2/jazzy-noble-desktop-full:latest\",\n    // Workspace setup\n    \"workspaceMount\": \"source=${localWorkspaceFolder},target=/workspaces/catkin_ws,type=bind,consistency=cached\",\n    \"workspaceFolder\": \"/workspaces/catkin_ws\",\n    \"remoteUser\": \"ubuntu\",\n    \"containerUser\": \"ubuntu\",\n\n    // Features to add to the dev container. More info: https://containers.dev/features.\n    \"features\": {\n        \"ghcr.io/devcontainers/features/common-utils:2\": {\n            \"installZsh\": true,\n            \"installOhMyZsh\": true,\n            \"installOhMyZshConfig\": true,\n            \"nonFreePackages\": true,\n            \"username\": \"ubuntu\",\n            \"userUid\": \"automatic\",\n            \"userGid\": \"automatic\"\n        }\n    },\n\n    // Use 'forwardPorts' to make a list of ports inside the container available locally.\n    // \"forwardPorts\": [],\n\n    // Use 'postCreateCommand' to run commands after the container is created.\n    // \"postCreateCommand\": \"uname -a\",\n\n    // Configure tool-specific properties.\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"ms-vscode.cpptools\",\n                \"ms-iot.vscode-ros\",\n                \"twxs.cmake\",\n                \"mutantdino.resourcemonitor\",\n                \"donjayamanne.python-environment-manager\",\n                \"KevinRose.vsc-python-indent\",\n                \"VisualStudioExptTeam.vscodeintellicode\",\n                \"ms-python.vscode-pylance\",\n                \"ms-vscode.cmake-tools\"\n            ]\n        }\n    },\n\n    // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.\n    // \"remoteUser\": \"root\"\n\n    \"containerEnv\": {\n        // Display configuration\n        \"DISPLAY\": \"${localEnv:DISPLAY}\"\n    },\n    \"mounts\": [\n        // X-Server\n        \"type=bind,source=/tmp/.X11-unix,target=/tmp/.X11-unix,readonly=false\"\n    ],\n    \"runArgs\": [\n        \"--device=/dev/dri:/dev/dri\",\n        \"--privileged\",\n        \"--volume=/dev:/dev\",\n        \"--net=host\"\n    ],\n    \"onCreateCommand\": \"echo 'source /opt/ros/$ROS_DISTRO/setup.bash' &gt;&gt; /home/ubuntu/.bashrc\",\n    \"postCreateCommand\": \"sudo apt update && rosdep update\"\n}"
  },
  {
    "objectID": "clases/02/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/02/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 02 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/02/lab.html#instalación-de-ros2",
    "href": "clases/02/lab.html#instalación-de-ros2",
    "title": "Clase 02 - Laboratorio",
    "section": "",
    "text": "Windows 10 / 11 (WSL)Ubuntu 24.04Docker\n\n\n\n\n\n\n\n\nImportantAntes de iniciar\n\n\n\nSe necesitan todas las últimas actualizaciones de Windows instaladas\n\n\n\n\n\n    $ wsl --install\n\n\nVer salida\n\nLa operación solicitada requiere elevación.\nDescargando: Subsistema de Windows para Linux 2.4.13\nInstalando: Subsistema de Windows para Linux 2.4.13\nSe ha instalado Subsistema de Windows para Linux 2.4.13.\nInstalando componente opcional de Windows: VirtualMachinePlatform\n\nHerramienta Administración y mantenimiento de imágenes de implementación\nVersión: 10.0.26100.1150\n\nVersión de imagen: 10.0.26100.3624\n\nHabilitando características\n[==========================100.0%==========================]\nLa operación se completó correctamente.\nLa operación solicitada se realizó correctamente. Los cambios se aplicarán una vez que se reinicie el sistema.\nLa operación solicitada se realizó correctamente. Los cambios se aplicarán una vez que se reinicie el sistema.\n\n\n\n\n\n\n\nNoteRecomendación\n\n\n\nSe recomienda reiniciar la PC después de esta instalación inicial para finalizar el setup\n\n\n\n\n\n\nPara ver todas las distribuciones y versiones disponibles:\n    $ wsl --list --online\n\n\nVer salida\n\nA continuación, se muestra una lista de las distribuciones válidas que se pueden instalar.\nInstalar con \"wsl.exe --install &lt;Distro&gt;\".\n\nNAME                            FRIENDLY NAME\nAlmaLinux-8                     AlmaLinux OS 8\nAlmaLinux-9                     AlmaLinux OS 9\nAlmaLinux-Kitten-10             AlmaLinux OS Kitten 10\nDebian                          Debian GNU/Linux\nSUSE-Linux-Enterprise-15-SP5    SUSE Linux Enterprise 15 SP5\nSUSE-Linux-Enterprise-15-SP6    SUSE Linux Enterprise 15 SP6\nUbuntu                          Ubuntu\nUbuntu-24.04                    Ubuntu 24.04 LTS\nkali-linux                      Kali Linux Rolling\nopenSUSE-Tumbleweed             openSUSE Tumbleweed\nopenSUSE-Leap-15.6              openSUSE Leap 15.6\nUbuntu-18.04                    Ubuntu 18.04 LTS\nUbuntu-20.04                    Ubuntu 20.04 LTS\nUbuntu-22.04                    Ubuntu 22.04 LTS\nOracleLinux_7_9                 Oracle Linux 7.9\nOracleLinux_8_7                 Oracle Linux 8.7\nOracleLinux_9_1                 Oracle Linux 9.1\n\nPara instalar\n    $ wsl --install -d Ubuntu-24.04\n\n\nVer salida\n\nDescargando: Ubuntu 24.04 LTS\nInstalando: Ubuntu 24.04 LTS\nDistribución instalada correctamente.\n\n\n\n\n\n    $ wsl -d Ubuntu-24.04\n\n\nVer salida\n\nProvisioning the new WSL instance Ubuntu-24.04\nThis might take a while...\nCreate a default Unix user account: ubuntu\nNew password:\nRetype new password:\npasswd: password updated successfully\nTo run a command as administrator (user \"root\"), use \"sudo &lt;command&gt;\".\nSee \"man sudo_root\" for details.\n\n\n\n\n\n\n\n\nNote\n\n\n\nContinuar con la creación de usuario y contraseña\n\n\n\n\n\n\nTraducido de documentation.ubuntu.com/wsl\n\n\n\n\n\n\n\n\n\nWarningActualizar el sistema\n\n\n\n    $ sudo apt update\n    $ sudo apt upgrade -y\n\n\n\n\n\n    $ sudo apt install software-properties-common curl -y\n    $ sudo add-apt-repository universe\nAgregar la key GPG de ROS 2\n    $ sudo curl -sSL https://raw.githubusercontent.com/ros/rosdistro/master/ros.key -o /usr/share/keyrings/ros-archive-keyring.gpg\nAgregar repositorio a la source list\n    $ echo \"deb [arch=$(dpkg --print-architecture) signed-by=/usr/share/keyrings/ros-archive-keyring.gpg] http://packages.ros.org/ros2/ubuntu $(. /etc/os-release && echo $UBUNTU_CODENAME) main\" | sudo tee /etc/apt/sources.list.d/ros2.list &gt; /dev/null\n\n\n\n\nActualizar repositorios apt y asegurar que los paquetes se encuentren actualizados\n    $ sudo apt update && sudo apt upgrade -y\nInstalación Desktop: ROS, RViz, demos, etc.\n    $ sudo apt install ros-jazzy-desktop -y\n\nTraducido de docs.ros.org\n\n\n\n\n\n\n\n\n\n\n\n\n\nVer contenido del archivo\n\n\n\ndevcontainer.json\n\n// For format details, see https://aka.ms/devcontainer.json.\n{\n    \"name\": \"TUAR - ROS2 Jazzy\",\n    // Or use a Dockerfile or Docker Compose file. More info: https://containers.dev/guide/dockerfile\n    \"image\": \"registry.gitlab.com/acapovilla/ros-docker-images/ros2/jazzy-noble-desktop-full:latest\",\n    // Workspace setup\n    \"workspaceMount\": \"source=${localWorkspaceFolder},target=/workspaces/catkin_ws,type=bind,consistency=cached\",\n    \"workspaceFolder\": \"/workspaces/catkin_ws\",\n    \"remoteUser\": \"ubuntu\",\n    \"containerUser\": \"ubuntu\",\n\n    // Features to add to the dev container. More info: https://containers.dev/features.\n    \"features\": {\n        \"ghcr.io/devcontainers/features/common-utils:2\": {\n            \"installZsh\": true,\n            \"installOhMyZsh\": true,\n            \"installOhMyZshConfig\": true,\n            \"nonFreePackages\": true,\n            \"username\": \"ubuntu\",\n            \"userUid\": \"automatic\",\n            \"userGid\": \"automatic\"\n        }\n    },\n\n    // Use 'forwardPorts' to make a list of ports inside the container available locally.\n    // \"forwardPorts\": [],\n\n    // Use 'postCreateCommand' to run commands after the container is created.\n    // \"postCreateCommand\": \"uname -a\",\n\n    // Configure tool-specific properties.\n    \"customizations\": {\n        \"vscode\": {\n            \"extensions\": [\n                \"ms-vscode.cpptools\",\n                \"ms-iot.vscode-ros\",\n                \"twxs.cmake\",\n                \"mutantdino.resourcemonitor\",\n                \"donjayamanne.python-environment-manager\",\n                \"KevinRose.vsc-python-indent\",\n                \"VisualStudioExptTeam.vscodeintellicode\",\n                \"ms-python.vscode-pylance\",\n                \"ms-vscode.cmake-tools\"\n            ]\n        }\n    },\n\n    // Uncomment to connect as root instead. More info: https://aka.ms/dev-containers-non-root.\n    // \"remoteUser\": \"root\"\n\n    \"containerEnv\": {\n        // Display configuration\n        \"DISPLAY\": \"${localEnv:DISPLAY}\"\n    },\n    \"mounts\": [\n        // X-Server\n        \"type=bind,source=/tmp/.X11-unix,target=/tmp/.X11-unix,readonly=false\"\n    ],\n    \"runArgs\": [\n        \"--device=/dev/dri:/dev/dri\",\n        \"--privileged\",\n        \"--volume=/dev:/dev\",\n        \"--net=host\"\n    ],\n    \"onCreateCommand\": \"echo 'source /opt/ros/$ROS_DISTRO/setup.bash' &gt;&gt; /home/ubuntu/.bashrc\",\n    \"postCreateCommand\": \"sudo apt update && rosdep update\"\n}"
  },
  {
    "objectID": "clases/02/lab.html#configuración-del-entorno",
    "href": "clases/02/lab.html#configuración-del-entorno",
    "title": "Clase 02 - Laboratorio",
    "section": "Configuración del entorno",
    "text": "Configuración del entorno\nConfigurar el entorno:\n    $ source /opt/ros/jazzy/setup.bash\nVariables de entorno: ROS_DOMAIN_ID\n    $ printenv | grep -i ROS\nObtener ayuda desde la terminal:\n    $ ros2 --help"
  },
  {
    "objectID": "clases/02/lab.html#emisor-receptor",
    "href": "clases/02/lab.html#emisor-receptor",
    "title": "Clase 02 - Laboratorio",
    "section": "Emisor / Receptor",
    "text": "Emisor / Receptor\n\nInstalación de paquetes de demostración: demo-nodes-py\n    $ sudo apt install ros-jazzy-demo-nodes-py\nVer paquetes instalados:\n    $ ros2 pkg executables\n\n\nNodos talker y listener\n\nEjecutar nodos\n\n  $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n    $ ros2 run demo_nodes_py talker\ny en otra terminal\n    $ ros2 run demo_nodes_py listener\n\n\n\n\n\n\nTip\n\n\n\nRecuerda volver a configurar el entorno y configurar el ROS_DOMAIN_ID correctamente\n\n\n\n\n\n\n\n\n\nTip\n\n\n\nPara detener el nodo: Ctrl+C\n\n\n\n\nListar los nodos\n    $ ros2 node list\n\n\nObtener información\n\n  $ ros2 node info &lt;nombre_nodo&gt;\n\n\n    $ ros2 node info /talker\n\n\n\nTopics\n\nListar los topics\n    $ ros2 topic list\n\n\nObtener información\nInformación acerca del topic: ros2 topic info &lt;nombre_topic&gt;\n\n    $ ros2 topic info /chatter\nInformación acerca del tipo de topic: ros2 topic type &lt;nombre_topic&gt;\n\n    $ ros2 topic type /chatter\nMedir la frecuencia con la que se publican mensajes: ros2 topic hz &lt;nombre_topic&gt;\n\n    $ ros2 topic hz /chatter\n\n\nVer los mensajes que pasan por un topic\n\n  $ ros2 topic echo &lt;nombre_topic&gt;\n\n\n    $ ros2 topic echo /chatter\n\n\n\nMensajes\n\nObtener información\n\n  $ ros2 interface show &lt;nombre_del_tipo_de_mensaje&gt;\n\nEjemplo\n    $ ros2 interface show std_msgs/msg/String\n\n\nPublicar mensajes\n\n  $ ros2 topic pub &lt;nombre_del_topic&gt;\n      &lt;nombre_del_tipo_de_mensaje&gt; '&lt;contenido&gt;'\n\nEjemplo\n    $ ros2 topic pub /chatter std_msgs/msg/String \"{data: Mensaje de prueba}\""
  },
  {
    "objectID": "clases/04/lab.html",
    "href": "clases/04/lab.html",
    "title": "Clase 04 - Laboratorio",
    "section": "",
    "text": "NotePaso inicial\n\n\n\nCreación del workspace\n\n\n\nCrear una carpeta para el workspace (como por ejemplo robotica-2025) y dentro, crear la carpeta src:\n\n\n📂 ...\n   📂 robotica-2025\n       📁 src\n...\n\n\n\n\n\n\n\nTipRecomendación\n\n\n\nRealizar este paso solo por cada proyecto individual\n\n\n\n\n\n  $ ros2 pkg create --build-type ament_python &lt;nombre_paquete&gt;\n\n\n\n\n\n\n\nDentro de workspace/src\n\n\n\n\n    $ ros2 pkg create --build-type ament_python clase_04\nEsto generará la estructura de carpetas correspondientes para un paquete de python:\n\n📂 src\n  📂 clase_04\n    📂 clase_04\n      📄 __init__.py\n    📂 resource\n      📄 clase_04\n    📁 test\n    📄 package.xml\n    ⚙️ setup.cfg\n    📄 setup.py\n\n\n\n\n\n\n\nCompletar la información adicional en los respectivos archivos package.xml y setup.py\n\n\n\n\n\n    $ colcon build\n\n\n\n\n\n\nSiempre ejecutar este comando dentro de workspace\n\n\n\n\n\n\n\n\n\nCuando quieras compilar un solo paquete usa la opción --packages-select\n\n\n\nSe generarán las carpetas adicionales en el workspace:\n\n📂 ...\n    📂 robotica-2025\n        📁 src\n        📁 build      ⬅️\n        📁 install    ⬅️\n        📁 log        ⬅️\n...\n\n\n\n\n\n\n\n\n\nimport rclpy\n\n\n\nrclpy.init(args=args)\n\n\n\n\n  rclpy.create_node('&lt;nombre_nodo&gt;')\n\n\nnodo = rclpy.create_node('publicador')\n\n\n\n\n  &lt;nodo&gt;.create_publisher(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;tamaño_cola&gt;)\n\n\npub = nodo.create_publisher(String, 'chat', 10)\n\n\n\n\n  &lt;nodo&gt;.create_timer(&lt;periodo_en_seg&gt;, &lt;funcion_callback&gt;)\n\n\ntimer = nodo.create_timer(1, timer_callback)\n\n\n\n\n  rclpy.spin(&lt;nodo&gt;)\n\n\nrclpy.spin(nodo)\n\n\n\nrclpy.shutdown()\n\n\n\n\n\n\n\n\n\nDentro de la carpeta correspondiente: **/src/&lt;nombre_paquete&gt;/&lt;nombre_paquete&gt;\n\n\n\n\n\nnodo_publicador.py\n\nimport rclpy\n\n# Importar el tipo de mensaje String\nfrom std_msgs.msg import String\n\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 2.1 Creación de publisher\n    # pub = ...\n\n    # 2.2 Creación de mensaje\n    msg = String()\n\n    # 2.3 Programación de función de callback\n    def timer_callback():\n        # Completar el campo 'data' del mensaje \n        msg.data = 'Mensaje de prueba'\n\n        # Publicar el mensaje\n        pub.publish(msg)\n\n    # 2.4 Creación del timer\n    # ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\nPara añadir dependencias a un paquete, modificar el archivo package.xml\n&lt;package format=\"3\"&gt;\n    ...\n    &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n    ...\n&lt;/package&gt;\nInstalar dependencias:\n    $ rosdep install -i --from-path src -y\n\n\n\n\n\n\nSiempre ejecutar este comando dentro de workspace\n\n\n\n\n\n\n\nPara añadir un ejecutable en un paquete de Python, modificar el archivo setup.py\n\n  entry_points={\n       'console_scripts': [\n               '&lt;nombre_ejecutable&gt; = &lt;nombre_paquete&gt;.&lt;nombre_archivo&gt;:main',\n       ],\n  },\n\nsetup(\n    ...\n    entry_points={\n            'console_scripts': [\n                    'publicar = clase_04.nodo_publicador:main',\n            ],\n    },\n)\n\n\n\n\n\n\n\n\n\n\n\nRecuerda compilar el paquete\n\n\n\n\n\n\n\n\n\nRecuerda configurar el entorno local:\n    $ source install/setup.bash\n\n\n\n\n\n\n\n\n\n\n\nTipPara ejecutar\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\nPuedes utilizar los comandos de ros2 node list y ros2 node info\n\n\n\nPuedes utilizar los comandos de ros2 topic list, ros2 topic info y ros2 topic echo\n\n\n\n\n\n\n\n\n\n  &lt;nodo&gt;.create_subscription(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;funcion_callback&gt;, &lt;tamaño_cola&gt;)\n\n\nsub = nodo.create_subscription(String, 'chat', sub_callback, 10)\n\n\nnodo_suscriptor.py\n\nimport rclpy\n\n# Importar el tipo de mensaje String\nfrom std_msgs.msg import String\n\ndef main(args=None):\n    # 1. Inicialización\n    # ...\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 2.1 Programación de función de callback\n    def sub_callback(msg):\n        # Mostrar el mensaje en consola\n        nodo.get_logger().info('Recibí: \"%s\"' % msg.data)\n\n    # 2.2 Creación de suscriptor\n    # ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "clases/04/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/04/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 04 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/04/lab.html#parte-2-creación-de-paquetes-y-programación-de-nodos",
    "href": "clases/04/lab.html#parte-2-creación-de-paquetes-y-programación-de-nodos",
    "title": "Clase 04 - Laboratorio",
    "section": "",
    "text": "NotePaso inicial\n\n\n\nCreación del workspace\n\n\n\nCrear una carpeta para el workspace (como por ejemplo robotica-2025) y dentro, crear la carpeta src:\n\n\n📂 ...\n   📂 robotica-2025\n       📁 src\n...\n\n\n\n\n\n\n\nTipRecomendación\n\n\n\nRealizar este paso solo por cada proyecto individual\n\n\n\n\n\n  $ ros2 pkg create --build-type ament_python &lt;nombre_paquete&gt;\n\n\n\n\n\n\n\nDentro de workspace/src\n\n\n\n\n    $ ros2 pkg create --build-type ament_python clase_04\nEsto generará la estructura de carpetas correspondientes para un paquete de python:\n\n📂 src\n  📂 clase_04\n    📂 clase_04\n      📄 __init__.py\n    📂 resource\n      📄 clase_04\n    📁 test\n    📄 package.xml\n    ⚙️ setup.cfg\n    📄 setup.py\n\n\n\n\n\n\n\nCompletar la información adicional en los respectivos archivos package.xml y setup.py\n\n\n\n\n\n    $ colcon build\n\n\n\n\n\n\nSiempre ejecutar este comando dentro de workspace\n\n\n\n\n\n\n\n\n\nCuando quieras compilar un solo paquete usa la opción --packages-select\n\n\n\nSe generarán las carpetas adicionales en el workspace:\n\n📂 ...\n    📂 robotica-2025\n        📁 src\n        📁 build      ⬅️\n        📁 install    ⬅️\n        📁 log        ⬅️\n...\n\n\n\n\n\n\n\n\n\nimport rclpy\n\n\n\nrclpy.init(args=args)\n\n\n\n\n  rclpy.create_node('&lt;nombre_nodo&gt;')\n\n\nnodo = rclpy.create_node('publicador')\n\n\n\n\n  &lt;nodo&gt;.create_publisher(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;tamaño_cola&gt;)\n\n\npub = nodo.create_publisher(String, 'chat', 10)\n\n\n\n\n  &lt;nodo&gt;.create_timer(&lt;periodo_en_seg&gt;, &lt;funcion_callback&gt;)\n\n\ntimer = nodo.create_timer(1, timer_callback)\n\n\n\n\n  rclpy.spin(&lt;nodo&gt;)\n\n\nrclpy.spin(nodo)\n\n\n\nrclpy.shutdown()\n\n\n\n\n\n\n\n\n\nDentro de la carpeta correspondiente: **/src/&lt;nombre_paquete&gt;/&lt;nombre_paquete&gt;\n\n\n\n\n\nnodo_publicador.py\n\nimport rclpy\n\n# Importar el tipo de mensaje String\nfrom std_msgs.msg import String\n\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 2.1 Creación de publisher\n    # pub = ...\n\n    # 2.2 Creación de mensaje\n    msg = String()\n\n    # 2.3 Programación de función de callback\n    def timer_callback():\n        # Completar el campo 'data' del mensaje \n        msg.data = 'Mensaje de prueba'\n\n        # Publicar el mensaje\n        pub.publish(msg)\n\n    # 2.4 Creación del timer\n    # ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\nPara añadir dependencias a un paquete, modificar el archivo package.xml\n&lt;package format=\"3\"&gt;\n    ...\n    &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n    ...\n&lt;/package&gt;\nInstalar dependencias:\n    $ rosdep install -i --from-path src -y\n\n\n\n\n\n\nSiempre ejecutar este comando dentro de workspace\n\n\n\n\n\n\n\nPara añadir un ejecutable en un paquete de Python, modificar el archivo setup.py\n\n  entry_points={\n       'console_scripts': [\n               '&lt;nombre_ejecutable&gt; = &lt;nombre_paquete&gt;.&lt;nombre_archivo&gt;:main',\n       ],\n  },\n\nsetup(\n    ...\n    entry_points={\n            'console_scripts': [\n                    'publicar = clase_04.nodo_publicador:main',\n            ],\n    },\n)\n\n\n\n\n\n\n\n\n\n\n\nRecuerda compilar el paquete\n\n\n\n\n\n\n\n\n\nRecuerda configurar el entorno local:\n    $ source install/setup.bash\n\n\n\n\n\n\n\n\n\n\n\nTipPara ejecutar\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\nPuedes utilizar los comandos de ros2 node list y ros2 node info\n\n\n\nPuedes utilizar los comandos de ros2 topic list, ros2 topic info y ros2 topic echo\n\n\n\n\n\n\n\n\n\n  &lt;nodo&gt;.create_subscription(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;funcion_callback&gt;, &lt;tamaño_cola&gt;)\n\n\nsub = nodo.create_subscription(String, 'chat', sub_callback, 10)\n\n\nnodo_suscriptor.py\n\nimport rclpy\n\n# Importar el tipo de mensaje String\nfrom std_msgs.msg import String\n\ndef main(args=None):\n    # 1. Inicialización\n    # ...\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 2.1 Programación de función de callback\n    def sub_callback(msg):\n        # Mostrar el mensaje en consola\n        nodo.get_logger().info('Recibí: \"%s\"' % msg.data)\n\n    # 2.2 Creación de suscriptor\n    # ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "clases/03/index.html#resumen-clase-02",
    "href": "clases/03/index.html#resumen-clase-02",
    "title": "Robótica",
    "section": "Resumen Clase 02",
    "text": "Resumen Clase 02\n\n\n\nROS 2 - Jazzy\n\nNodos\nTopics\nMensajes\n\n\n\n\n\n\n\n\n\n\nAlgunos comandos más usados (run, node list, node info, topic list, topic info, topic echo, rqt_graph)"
  },
  {
    "objectID": "clases/03/index.html#ros2-contexto-y-namespaces",
    "href": "clases/03/index.html#ros2-contexto-y-namespaces",
    "title": "Robótica",
    "section": "ROS2: Contexto y namespaces",
    "text": "ROS2: Contexto y namespaces\n\n\nSimilaridad a una estructura de carpetas\n\nTipos\n\nGlobal\nRelativo\nBase\nPrivado\n\n\n/\n├── sim1/\n│ └── robot/\n│     ├── cmd_vel       /sim1/robot/cmd_vel\n│     └── odometry      /sim1/robot/odometry\n└── sim2/\n    └── robot/\n        ├── cmd_vel     /sim2/robot/cmd_vel\n        └── odometry    /sim2/robot/odometry\n\nBase:       robot\n\nPrivado:    ~/cmd_vel\n            ~/odometry\n\n\nExplicación de contexto: Estructura jerárquica de nombres utilizada en ROS para proveer encapsulamiento y así poder gestionar de una forma más sencilla grandes sistemas.\nExisten 4 tipos de nombres: base, relativo, global y privado.\nLa resolución se realiza de forma relativa al namespace del nodo.\n\nGlobal -&gt; empiezan con “/” y se consideran resueltos\nRelativo -&gt; no empiezan con “/” y deben ser resueltos de forma relativa al namespace del nodo\nBase -&gt; Es un subtipo de relativo: No llevan namespaces y generalmente se utilizan para inicializar el nombre del nodo\nPrivado -&gt; empiezan on “~” y convierten el nodo en un “namespace”"
  },
  {
    "objectID": "clases/03/index.html#ros2-servicios",
    "href": "clases/03/index.html#ros2-servicios",
    "title": "Robótica",
    "section": "ROS2: Servicios",
    "text": "ROS2: Servicios\n\n\n\nModelo de llamada-respuesta\n\n\n\nBidireccional\n\n\n\n\nSolo proveen información cuando son invocados\n\n\n\n\nComunicación es 1 a N\n\n\n\n\n\n\n\n\n\n\nServicios (comunicación)\n\nBasados en un modelo de “llamada-respuesta” (call-and-response)\nLa diferencia con Topics: no son continuos, solo proveen información cuando son invocados.\nMuchos clientes pero solo un servidor.\nBidireccional\nDefinidos en archivos .srv"
  },
  {
    "objectID": "clases/03/index.html#ros2-parámetros",
    "href": "clases/03/index.html#ros2-parámetros",
    "title": "Robótica",
    "section": "ROS2: Parámetros",
    "text": "ROS2: Parámetros\n\nValores de configuración para un nodo\n\n\n\nCada nodo posee sus propios parámetros\n\n\n\n\n\nint\nfloat\nbool\nstring\nlist[]"
  },
  {
    "objectID": "clases/03/index.html#laboratorio-parte-1",
    "href": "clases/03/index.html#laboratorio-parte-1",
    "title": "Robótica",
    "section": "Laboratorio (parte 1)",
    "text": "Laboratorio (parte 1)\n\nInvocar y analizar servicios\nComandos para setear y obtener comandos"
  },
  {
    "objectID": "clases/03/index.html#entorno-de-ros-y-workspace",
    "href": "clases/03/index.html#entorno-de-ros-y-workspace",
    "title": "Robótica",
    "section": "Entorno de ROS y workspace",
    "text": "Entorno de ROS y workspace\n\n\nDos niveles:\n\noverlay ➡️ Nuestros paquetes\nunderlay ➡️ Paquetes instalados\n\n\n\nWorkspace\n📂 ros_ws\n  📁 src\n  📁 build      ⚠️\n  📁 install    ⚠️\n  📁 log        ⚠️\n\n\n\n \n\n\n\n\n\n\nWorkspace de desarrollo . install/local_setup.bash\n\n\nPaquete de ROS instalados source /opt/ros/jazzy/setup.bash\n\n\n\n\n\nDos “niveles”: Paquetes de ROS2 instalados (cuando se hace el source) “underlay” (tiene las dependencias del “overlay”), workspace de desarrollo donde se agregan paquetes nuevos “overlay”. Este último sobre-escribe paquetes del “underlay”.\nworkspace: Estructura de carpetas que contiene paquetes\n\nsrc: código fuente: crear y editar el código de los paquetes que se quieren compilar\nbuild: caché y archivos intermedios de compilación\ninstall: los paquetes o “targets” instalados\nlog: Información de log"
  },
  {
    "objectID": "clases/03/index.html#paquete-de-ros",
    "href": "clases/03/index.html#paquete-de-ros",
    "title": "Robótica",
    "section": "Paquete de ROS",
    "text": "Paquete de ROS\n\n\nContiene\n\nCódigo fuente\nArchivos de configuración\nArchivos “launch”\nDefinición de mensajes, servicios, etc\nMetadatos e información\nDocumentación\n\n\n\n📂 src\n  📂 nombre_paquete\n      📁 nombre_paquete\n          📄 __init__.py\n          ...\n      📁 resource\n          📄 nombre_paquete\n      📄 package.xml\n      📄 setup.cfg\n      📄 setup.py\n\n\n\nContenedor o marco del código (contiene código fuente, archivos launch, archivos de configuración, definición de mensajes, datos y documentación). Forma que permite instalar el propio código y compartirlo.\nArchivos mínimos para paquetes Python (para cada paquete por separado)\n\npackage.xml: información acerca del paquete (cual?)\nsetup.py -&gt; instrucciones para instalar el paquete\nsetup.cfg -&gt; Para que el comando run encuentra los ejecutables en el caso de que existan\n/&lt;nombre_paquete&gt; -&gt; Carpeta con el mismo nombre del paquete junto con el archivo __init__.py utilizado por las herramientas de ROS2"
  },
  {
    "objectID": "clases/03/index.html#paquete-de-ros-package.xml",
    "href": "clases/03/index.html#paquete-de-ros-package.xml",
    "title": "Robótica",
    "section": "Paquete de ROS: 📄 package.xml",
    "text": "Paquete de ROS: 📄 package.xml\nContiene\n\nPropiedades e información del paquete\nFormato XML\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;?xml-model href=\"http://download.ros.org/schema/package_format3.xsd\"\n    schematypens=\"http://www.w3.org/2001/XMLSchema\"?&gt;\n\n&lt;package format=\"3\"&gt;\n    &lt;name&gt;nombre_paquete&lt;/name&gt;\n    &lt;version&gt;0.0.0&lt;/version&gt;\n    &lt;description&gt;Descripción del paquete&lt;/description&gt;\n    &lt;maintainer email=\"user@todo.todo\"&gt;user&lt;/maintainer&gt;\n    &lt;license&gt;Licencia&lt;/license&gt;\n\n    &lt;url type=\"website\"&gt;https://github.com/...&lt;/url&gt;\n    &lt;author email=\"user@todo.todo\"&gt;user&lt;/author&gt;\n\n    &lt;depend&gt;nombre_paquete_dependencia&lt;/depend&gt;\n\n    &lt;export&gt;\n        &lt;build_type&gt;ament_python&lt;/build_type&gt;\n    &lt;/export&gt;\n&lt;/package&gt;\n\nPropiedades e información del paquete: Nombre, versión, autores, dependencias, descripción, etc\nBreve descripción de los archivos con codificación eXtensible Markup Language:\n\nLenguaje de marcado -&gt; una forma de organizar la información utilizando etiquetas (para definir elementos) y atributos (para información adicional), de forma jerárquica.\nEs flexible y puede personalizarse -&gt; Útil para intercambiar información\nFácil de entender para humanos"
  },
  {
    "objectID": "clases/03/index.html#paquete-de-ros-setup.py",
    "href": "clases/03/index.html#paquete-de-ros-setup.py",
    "title": "Robótica",
    "section": "Paquete de ROS: 📄 setup.py",
    "text": "Paquete de ROS: 📄 setup.py\nContiene\n\nInstrucciones de cómo se debe instalar el paquete (para el sistema de compilación)\nDeben coincidir la información y los metadatos con los del package.xml\n\nfrom setuptools import setup\n\npackage_name = 'nombre_paquete'\n\nsetup(\n  name=package_name,\n  version='0.0.0',\n  # Packages to export\n  packages=[package_name],\n  # Files we want to install, specifically launch files\n  data_files=[\n      # Install marker file in the package index\n      ('share/ament_index/resource_index/packages',\n             ['resource/' + package_name]),\n      # Include our package.xml file\n      ('share/' + package_name, ['package.xml']),\n    ],\n  # This is important as well\n  install_requires=['setuptools'],\n  zip_safe=True,\n  maintainer='TODO',\n  maintainer_email='TODO',\n  description='TODO: Package description',\n  license='TODO: License declaration',\n  tests_require=['pytest'],\n  entry_points={\n      'console_scripts': [\n              'nombre_nodo = nombre_paquete.nombre_nodo:main'\n      ],\n    },\n)\n\nContenido: repite nombre, version, descripción, maintainer y licencia. Es necesario que sean iguales en los dos archivos"
  },
  {
    "objectID": "clases/03/index.html#paquete-de-ros-setup.cfg",
    "href": "clases/03/index.html#paquete-de-ros-setup.cfg",
    "title": "Robótica",
    "section": "Paquete de ROS: 📄 setup.cfg",
    "text": "Paquete de ROS: 📄 setup.cfg\n\nSi el paquete posee un ejecutable, para que ros2 run lo pueda encontrar\n\n[develop]\nscript_dir=$base/lib/&lt;nombre_paquete&gt;\n\n[install]\ninstall_scripts=$base/lib/&lt;nombre_paquete&gt;"
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python",
    "href": "clases/03/index.html#rclpy-ros-client-library-python",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nAcceso a los componentes de ROS\n\n\nInicialización y ejecución de callbacks\nGestión de nodos\nTopics, servicios, acciones, etc.\nLogs\n\n\nimport rclpy\n\n\n\nAcceso a los elementos de ROS desde la sintaxis de Python utilizando tipos nativos y patrones como listas.\nComponentes principales de la librería:-Inicialización y “spinning”. Gestión del nodo. Log. Subscriber/Publisher. Parámetros.\n(así como servicios, acciones y elementos de sincronización)\n\n\n\nDocumentación completa en: docs.ros2.org/latest/api/rclpy"
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python-1",
    "href": "clases/03/index.html#rclpy-ros-client-library-python-1",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nPartes básicas del programa\n\n\n\nInicialización\n rclpy.init(..)\n\n\nAntes que cualquier otra función de ROS\n\n\nDefine el contexto\n\n\n\n\nInicialización: Debe ser llamado antes de cualquier otra función de ROS. Define el contexto."
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python-2",
    "href": "clases/03/index.html#rclpy-ros-client-library-python-2",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nPartes básicas del programa\n\n\nInicialización\n rclpy.init(..)\nCreación de 1 o más nodos\n rclpy.create_node(..)\n\n\nPunto de acceso al sistema de ROS (topics, parámetros, servicios, etc.)\n\n\nEn POO sería a través de una instancia ‘node’\n\n\nCreación del nodo: es el punto de acceso al sistema de ROS (topics, servicios, parámetros, etc)\nEn el caso de utilizar clases (POO) sería a través de una instancia de ‘node’."
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python-3",
    "href": "clases/03/index.html#rclpy-ros-client-library-python-3",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nPartes básicas del programa\n\n\nInicialización\n rclpy.init(..)\nCreación de 1 o más nodos\n rclpy.create_node(..)\nProcesamiento de callbacks (spinning)\n rclpy.spin(..)\n\n\nSe procesan los callbacks y demás tareas del nodo\n\n\n“Spinning”: Procesar los callbacks y demás rutinas"
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python-4",
    "href": "clases/03/index.html#rclpy-ros-client-library-python-4",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nPartes básicas del programa\n\n\nInicialización\n rclpy.init(..)\nCreación de 1 o más nodos\n rclpy.create_node(..)\nProcesamiento de callbacks (spinning)\n rclpy.spin(..)\nApagado / finalización (shutdown)\n rclpy.shutdown()\n\n\nFinalización: rclpy.shutdown()"
  },
  {
    "objectID": "clases/03/index.html#rclpy-ros-client-library-python-5",
    "href": "clases/03/index.html#rclpy-ros-client-library-python-5",
    "title": "Robótica",
    "section": "rclpy: ROS Client Library (Python)",
    "text": "rclpy: ROS Client Library (Python)\n\nGestión de nodos\n\n\n\nCrear un publisher: node.create_publisher(..)\n\n\n\n\nCrear un suscriber: node.create_subscription(..)\n\n\n\n\nTimer: node.create_timer(..)\n\n\n\n\nLog: node.get_logger(..)\n\n\n\nManejo de nodos:\n\nCrear un publisher: Tipo de mensaje, nombre del topic\nCrear un subscriptor: Tipo de mensaje, nombre del topic, callback\nTimer: Tareas repetitivas a una frecuencia deseada. Período, callback\nLoggear: Mensajes en consola"
  },
  {
    "objectID": "clases/03/index.html#compilación-del-paquete",
    "href": "clases/03/index.html#compilación-del-paquete",
    "title": "Robótica",
    "section": "Compilación del paquete",
    "text": "Compilación del paquete\n\nCreación de paquetes:\n\n    ros2 pkg create --build-type ament_python &lt;nombre_paquete&gt;\n\nHerramienta de compilación: colcon\n\n    colcon build [--symlink-install] [--packages-select &lt;nombre_paquete&gt;]\n\nDependencias:\n\n    rosdep update\n\n    rosdep install -i --from-path src --rosdistro jazzy -y\n\n\n\n\n\n\n\nEjecutar en la raíz del workspace"
  },
  {
    "objectID": "clases/16/index.html#navegación-1",
    "href": "clases/16/index.html#navegación-1",
    "title": "Robótica",
    "section": "Navegación",
    "text": "Navegación\n\nÁrea más desafiante en robótica móvil\n\n\n\n4 pilares\n\nPercepción\nLocalización\nCognición\nControl\n\n\n\n\n\n\n\n\n\nDominio de cuatro pilares:\n\nPercepción (interpretar sus sensores para extraer información significativa)\nLocalización (el robot debe determinar su posición en el entorno)\nCognición (el robot debe decidir cómo actuar para lograr sus objetivos)\nControl de movimiento (el robot debe controlar la respuesta de sus motores para lograr la trayectoria deseada)"
  },
  {
    "objectID": "clases/16/index.html#localización-1",
    "href": "clases/16/index.html#localización-1",
    "title": "Robótica",
    "section": "Localización",
    "text": "Localización\n\nResponder a la pregunta: ¿Dónde está el robot ahora?\n\n\n\n\n\n\n\n\nSi se pudiera conectar un GPS preciso a un robot móvil todo el tiempo se solucionaría gran parte del problema\n\n\n\n\n\n\nRealidad\n\nPrecisión inaceptable para robots móviles a escala humana\nNo funciona en interiores ni áreas obstruidas (ej, calles rodeadas por edificios altos)\nPosición respecto al planeta Tierra\n\n\n\n\n\n\n\n\n\nFuente: U-blox (www.u-blox.com)\n\n\n\n\nUn GPS preciso en un robot solucionaría gran parte del problema de localización. El GPS informaría al robot de su posición exacta, en interiores y exteriores, y la respuesta a la pregunta “¿Dónde estoy?” siempre estaría disponible de inmediato.\nDesafortunadamente, un sensor de este tipo no es práctico. La red GPS proporciona una precisión inaceptable para localizar robots móviles a escala humana (utilizando módulos convencionales). Además, las tecnologías GPS no funciona en interiores ni en áreas obstruidas (ej, calles rodeadeas por edificios altos) y, por lo tanto, su área de trabajo está limitada."
  },
  {
    "objectID": "clases/16/index.html#localización-2",
    "href": "clases/16/index.html#localización-2",
    "title": "Robótica",
    "section": "Localización",
    "text": "Localización\n\n\n\nMás problemas\n\nUn robot que interactúa con humanos\n\nSu posición relativa con respecto al objetivo es igualmente importante que su posición absoluta\nIdentificación de obstáculos dinámicos y estáticos: construir un mapa e identificar la posición en relación al mismo\n\n\n2 tipos de posicionamiento\n\nAbsolutos\nRelativos\n\n\n\n\n\n\nExtraído de YouTube\n\n\n\n\nLa localización implica más que conocer la posición absoluta en el sistema de referencia terrestre.\nConsideremos un robot que interactúa con humanos. Su posición relativa con respecto a los humanos objetivo es igualmente importante que su posición absoluta. Su tarea de localización puede incluir identificar humanos mediante su conjunto de sensores y luego calcular su posición relativa.\nAdemás, durante la etapa de cognición, un robot seleccionará una estrategia para lograr sus objetivos. Si pretende llegar a una ubicación específica, la localización puede no ser suficiente. El robot puede necesitar adquirir o construir un modelo ambiental, un mapa, que le ayude a planificar una ruta hacia el objetivo. Una vez más, la localización significa más que simplemente determinar una posición absoluta en el espacio; significa construir un mapa y luego identificar la posición del robot en relación con ese mapa.\nClaramente, los sensores y efectores del robot desempeñan un papel integral en todas las formas de localización mencionadas. Debido a la inexactitud e incompletitud de estos sensores y efectores, la localización plantea grandes desafíos."
  },
  {
    "objectID": "clases/16/index.html#métodos-absolutos",
    "href": "clases/16/index.html#métodos-absolutos",
    "title": "Robótica",
    "section": "Métodos absolutos",
    "text": "Métodos absolutos\n\n\n\nBasados en referencias y sensores exteroceptivos\n\nEjemplos:\n\nBrújulas magnéticas\nBalizas (beacons) de navegación\nSistema de posicionamiento global (GPS)\nPuntos de referencias (activos o pasivos)\nOtros..\n\n\n\n\n\nFrese, U., & Wagner, R. & Röfer, T. A SLAM overview from a users perspective. Künstl Intell 24, 191-198 (2010). 10.1007/s13218-010-0040-4.\n\n\n\n\nCada uno de estos enfoques puede implementarse mediante diversos métodos y sensores\nSin embargo, ninguno de los sistemas existentes es especialmente elegante.\nLos beacons y los puntos de referencia suelen requerir instalaciones y mantenimiento costosos, mientras que la navegación por satélite (GPS) suelen ser más lentos que la odometría y solo puede utilizarse en exteriores."
  },
  {
    "objectID": "clases/16/index.html#métodos-relativos",
    "href": "clases/16/index.html#métodos-relativos",
    "title": "Robótica",
    "section": "Métodos relativos",
    "text": "Métodos relativos\n\nPor lo general basado en sensores propioceptivos\n\n\nSe determina la ubicación actual “avanzando” desde una posición previa, con la información de velocidad en un cierto período de tiempo, hacia una dirección conocida\n\n\\[\n\\require{color}\n\\textcolor{#1f77b4}{\\boldsymbol{p}_k} = \\textcolor{#d62728}{\\boldsymbol{p}_{k-1}} \\textcolor{#ff7f0e}{+} \\textcolor{#7f7f7f}{{\\boldsymbol{\\stackrel{\\cdot}{p}}_k}} \\cdot \\textcolor{#9467bd}{\\vec{\\boldsymbol{\\theta}}} \\cdot \\textcolor{#2ca02c}{\\Delta t}\n\\]\n\nTambién conocidos como dead-reckoning\n\nEjemplos:\n\nNavegación inercial\nOdometría\n\n\ndead-reckoning: Procedimiento matemático para determinar la ubicación actual “avanzando” desde una posición previa a través de un curso conocido con la información de velocidad en un cierto período de tiempo\nOtro enfoque se basa en la navegación inercial con giroscopos y/o acelerómetros. Los datos del acelerómetro deben integrarse dos veces para obtener la posición, lo que hace que estos sensores sean extremadamente sensibles al “bias” o deriva.\nOtro problema es que las aceleraciones en condiciones de funcionamiento típicas pueden ser muy pequeñas, del orden de 0,01 g. Sin embargo, ya se producen fluctuaciones de esta magnitud si el sensor se inclina tan solo 0,5° respecto del plano horizontal (por ejemplo, cuando el vehículo circula sobre superficies irregulares)\nLos giroscopios pueden ser más precisos, pero solo proporcionan información sobre la velocidad de rotación del vehículo (sus datos deben integrarse una sola vez)\nEste problema no existe con las brújulas electrónicas (o magnetómetros) que miden la orientación del robot respecto al campo magnético terrestre. Sin embargo, no se recomiendan para aplicaciones en interiores debido a las grandes distorsiones del campo magnético terrestre cerca de líneas eléctricas o estructuras de acero.\nLa odometría es el método más utilizado para determinar la posición en robótica móvil. Es sencilla, económica y fácil de implementar en tiempo real.\nProporciona información de posicionamiento en tiempo real y de fácil acceso entre mediciones periódicas de posición absoluta. La frecuencia con la que deben realizarse las mediciones absolutas (generalmente costosas y/o laboriosas) depende en gran medida de la precisión del sistema de odometría.\nLa GRAN desventaja de la odometría es su acumulación de error ilimitado (no acotado)."
  },
  {
    "objectID": "clases/16/index.html#odometría-1",
    "href": "clases/16/index.html#odometría-1",
    "title": "Robótica",
    "section": "Odometría",
    "text": "Odometría\n\nEl método más utilizado y económico\nBuena precisión a corto plazo y alta frecuencia de muestreo\nImplementación más común a través de encoders ópticos acoplados a los ejes de las ruedas\nPara calcular la distancia incremental de ambas ruedas en el intervalo \\(i\\):\n\n\\[\n\\Delta s_{L|R,i} = \\pi \\cdot D_{L|R} \\cdot \\frac{N_{L|R, i}}{c_e}\n\\]\ndonde:\n\n\\(D_{L|R}\\): Diámetro de la rueda (en [mm])\n\\(N_{L|R, i}\\): incremento de pulsos del encoder en el intervalo\n\\(c_e\\): Resolución del encoder (en [pulsos por revolución])\n\n\nEs el método de navegación más utilizado para el posicionamiento de robots móviles. Es bien sabido que proporciona una buena precisión a corto plazo, es económica y permite frecuencias de muestreo muy altas. Sin embargo la acumulación de errores es inevitable.\nLa precisión de las mediciones de odometría para dead-reckoning es una acción directa del diseño cinemático de un vehículo. Se debe considerar detenidamente el diseño cinemático antes de intentar mejorar la precisión de la navegación a estima."
  },
  {
    "objectID": "clases/16/index.html#repaso-odometría",
    "href": "clases/16/index.html#repaso-odometría",
    "title": "Robótica",
    "section": "Repaso odometría",
    "text": "Repaso odometría\n\nCalculo del desplazamiento desde una posición inicial mediante la medición de las revoluciones de las ruedas\n\n\nSea la posición en el instante \\(k-1\\): \\[\np_{k-1} = \\begin{bmatrix} x & y & \\theta \\end{bmatrix}^\\top\n\\]\nLa posición estimada para el instante \\(k\\) puede obtenerse sumando las distancias recorridas de forma incremental:\n\n\\[\np_{k} = p_{k-1} + \\Delta p\n\\]\n\nEl posicionamiento relativo suele basarse en la odometría (medición de las revoluciones de las ruedas para calcular el desplazamiento desde una posición inicial conocida).\nLa odometría calcula el desplazamiento horizontal relativo del robot y el cambio de orientación en función del desplazamiento horizontal incremental de las ruedas motrices.\nLa odometría se basa en ecuaciones sencillas de fácil implementación que utilizan datos de encoders incrementales de rueda económicos.\nSin embargo, parte de la suposición de que las revoluciones de la rueda pueden traducirse en un desplazamiento lineal con respecto al suelo. Esta suposición tiene una validez limitada. Un ejemplo extremo es el deslizamiento de una rueda: si una rueda patinara, por ejemplo, en un lugar con aceite, el encoder asociado a la rueda registraría las revoluciones aunque estas no correspondieran a un desplazamiento lineal.\nAdemás de este caso extremo de deslizamiento total, existen otras razones más sutiles que explican las imprecisiones en la traducción de las lecturas del encoder de rueda a movimiento lineal."
  },
  {
    "objectID": "clases/16/index.html#repaso-odometría-1",
    "href": "clases/16/index.html#repaso-odometría-1",
    "title": "Robótica",
    "section": "Repaso odometría",
    "text": "Repaso odometría\n\n\nPara un robot differential-drive, con un período de muestreo fijo \\(\\Delta t\\):\n\n\\[\n\\Delta p =\n\\begin{bmatrix} \\Delta x \\\\ \\Delta y \\\\ \\Delta\\theta \\end{bmatrix} =\n\\begin{bmatrix}\n\\Delta s \\cos(\\theta + \\frac{\\Delta\\theta}{2})\\\\\n\\Delta s \\sin(\\theta + \\frac{\\Delta\\theta}{2})\\\\\n\\frac{\\Delta s_{R} - \\Delta s_{L}}{b}\n\\end{bmatrix}\n\\]\ndonde:\n\n\\(\\Delta x, \\Delta y, \\Delta\\theta\\): el avance en el último período\n\\(\\Delta s_{L|R}\\): la distancia recorrida por la rueda izquierda y derecha respectivamente\n\\(\\Delta s = (\\Delta s_{L} + \\Delta s_{R}) / 2\\)\n\\(b\\): la distancia entre ruedas"
  },
  {
    "objectID": "clases/16/index.html#repaso-odometría-2",
    "href": "clases/16/index.html#repaso-odometría-2",
    "title": "Robótica",
    "section": "Repaso odometría",
    "text": "Repaso odometría\n\n\nUtilizando las definiciones de \\(\\Delta s\\) y \\(\\Delta\\theta\\) se obtiene la ecuación para la actualización de la posición\n\n\\[\\begin{align*}p_k &= p_{k-1} + \\Delta p\\\\ &= \\left[\\begin{matrix}x\\\\y\\\\\\theta\\end{matrix}\\right] + \\left[\\begin{matrix}\\left(\\frac{\\Delta s_{L}}{2} + \\frac{\\Delta s_{R}}{2}\\right) \\cos{\\left(\\theta + \\frac{- \\Delta s_{L} + \\Delta s_{R}}{2 b} \\right)}\\\\\\left(\\frac{\\Delta s_{L}}{2} + \\frac{\\Delta s_{R}}{2}\\right) \\sin{\\left(\\theta + \\frac{- \\Delta s_{L} + \\Delta s_{R}}{2 b} \\right)}\\\\\\frac{- \\Delta s_{L} + \\Delta s_{R}}{b}\\end{matrix}\\right]\\end{align*}\\]\n\n\\[\n\\def\\f{{\\boldsymbol{f}}}\n\\]\n\n\nDe forma reducida:\n\n\\[\np_{k} = \\f \\left( x, \\  y, \\  \\theta, \\  \\Delta s_{L}, \\  \\Delta s_{R}, \\  b\\right)\n\\]"
  },
  {
    "objectID": "clases/16/index.html#modelo-de-error-de-odometría-1",
    "href": "clases/16/index.html#modelo-de-error-de-odometría-1",
    "title": "Robótica",
    "section": "Modelo de error de odometría",
    "text": "Modelo de error de odometría\n\nPara el movimiento incremental \\(\\Delta s_L\\) y \\(\\Delta s_R\\) se asume una matriz de covarianza \\(\\Sigma_\\Delta\\):\n\n\\[\n\\Sigma_\\Delta = \\mathcal{covar}(\\Delta s_L, \\Delta s_R) = \\begin{bmatrix}\nk_L |\\Delta s_L|  & 0\\\\\n               0  & k_R |\\Delta s_R|\n\\end{bmatrix}\n\\]\n\nLos errores de las ruedas motrices son independientes\nLa varianza de los errores es proporcional al valor absoluto de la distancia recorrida\n\\(k_L\\) y \\(k_R\\) son coeficientes de error constantes\n\n\nLas actualizaciones de la posición odométrica solo pueden proporcionar una estimación muy aproximada de la posición real\nDebido a los errores de integración de las incertidumbres de p y a los errores de movimiento durante el movimiento incremental, el error de posición basado en la integración odométrica aumenta con el tiempo\nSe establecerá un modelo de error para la posición integrada \\(p_{k}\\) con el fin de obtener la matriz de covarianza \\(\\Sigma p_{k}\\) de la estimación de la posición odométrica.\nSe asume:\n\nEn el punto de partida se conoce la matriz de covarianza inicial \\(\\Sigma p_{k-1}\\)\n\\(k_R\\), \\(k_L\\) son constantes de error que representan los parámetros no deterministas del accionamiento del motor y la interacción de la rueda y el suelo\nLos dos errores de las ruedas motrices individuales son independientes\nLa varianza de los errores (ruedas izquierda y derecha) es proporcional al valor absoluto de las distancias recorridas\n\nEstas suposiciones no son perfectas, pero simplifican el desarrollo del modelo de error\nLos errores de movimiento se deben a movimientos imprecisos debido a la deformación de la rueda, deslizamiento, suelo irregular, errores en los codificadores, etc. Los valores de las constantes de error \\(k_L\\) y \\(k_R\\) dependen del robot y del entorno, y deben determinarse experimentalmente mediante la realización y el análisis de movimientos representativos."
  },
  {
    "objectID": "clases/16/index.html#modelo-de-error-de-odometría-2",
    "href": "clases/16/index.html#modelo-de-error-de-odometría-2",
    "title": "Robótica",
    "section": "Modelo de error de odometría",
    "text": "Modelo de error de odometría\n\nSuponiendo que \\(p_{k-1}\\) y \\(\\Delta_{L,R} = \\begin{bmatrix} \\Delta s_L & \\Delta s_R \\end{bmatrix}\\) no están correlacionados y \\(\\boldsymbol{f}\\) se puede aproximar mediante la expansión de Taylor de primer orden:\n\n\\[\n\\Sigma_{p_k} = \\nabla_p \\f \\cdot \\Sigma_{p_{k-1}} \\cdot \\nabla_p \\f^\\top + \\nabla_{\\Delta_{L,R}} \\f \\cdot \\Sigma_\\Delta \\cdot \\nabla_{\\Delta_{L,R}} \\f^\\top\n\\]\ndonde \\(\\Sigma_{p_{k-1}}\\) está dado por el paso anterior, y puede calcularse a partir de un valor incial (generalmente \\(\\Sigma_{p_0} = \\mathbb{0}\\))\n\nUtilizando la definción de \\(p_{k} = \\f(\\cdot)\\) es posible obtener los Jacobianos:\n\n\\[\nF_p = \\nabla_p \\f \\\\\nF_{\\Delta_{L,R}} = \\nabla_{\\Delta_{L,R}} \\f\n\\]\n\nSi suponemos que \\(p_{k-1}\\) y \\(\\Delta_{L,R} = \\begin{bmatrix} \\Delta s_L & \\Delta s_R \\end{bmatrix})\\) no están correlacionados y la derivada de \\(f\\) se puede aproximar mediante la expansión de Taylor de primer orden"
  },
  {
    "objectID": "clases/16/index.html#modelo-de-error-de-odometría-3",
    "href": "clases/16/index.html#modelo-de-error-de-odometría-3",
    "title": "Robótica",
    "section": "Modelo de error de odometría",
    "text": "Modelo de error de odometría\n\n\nEl Jacobiano de \\(\\f\\) con respecto al vector de posición \\(p = \\begin{bmatrix}x & y & \\theta \\end{bmatrix}\\):\n\n\\[\nF_p = \\nabla_p \\f = \\nabla_p (\\f^\\top) = \\begin{bmatrix} \\frac{\\partial \\f}{\\partial x} & \\frac{\\partial \\f}{\\partial y} & \\frac{\\partial \\f}{\\partial \\theta} \\end{bmatrix}\n\\]\n\nQue resulta en:\n\n\n\\[F_p = \\left[\\begin{matrix}1 & 0 & - \\Delta s \\sin{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}\\\\0 & 1 & \\Delta s \\cos{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}\\\\0 & 0 & 1\\end{matrix}\\right]\\]"
  },
  {
    "objectID": "clases/16/index.html#modelo-de-error-de-odometría-4",
    "href": "clases/16/index.html#modelo-de-error-de-odometría-4",
    "title": "Robótica",
    "section": "Modelo de error de odometría",
    "text": "Modelo de error de odometría\n\n\nEl Jacobiano de \\(\\f\\) con respecto al desplazamiento de las ruedas \\(\\Delta_{L,R} = \\begin{bmatrix} \\Delta s_L & \\Delta s_R \\end{bmatrix}\\):\n\n\\[\nF_{\\Delta_{L,R}} = \\nabla_{\\Delta_{L,R}} \\f = \\begin{bmatrix} \\frac{\\partial \\f}{\\partial \\Delta s_L} & \\frac{\\partial \\f}{\\partial \\Delta s_R} \\end{bmatrix}\n\\]\n\nQue resulta en:\n\n\\[F_{\\Delta_{L,R}} = \\left[\\begin{matrix}\\frac{\\Delta s \\sin{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2 b} + \\frac{\\cos{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2} & - \\frac{\\Delta s \\sin{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2 b} + \\frac{\\cos{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2}\\\\- \\frac{\\Delta s \\cos{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2 b} + \\frac{\\sin{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2} & \\frac{\\Delta s \\cos{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2 b} + \\frac{\\sin{\\left(\\frac{\\Delta\\theta}{2} + \\theta \\right)}}{2}\\\\- \\frac{1}{b} & \\frac{1}{b}\\end{matrix}\\right]\\]"
  },
  {
    "objectID": "clases/16/index.html#modelo-de-error-de-odometría-5",
    "href": "clases/16/index.html#modelo-de-error-de-odometría-5",
    "title": "Robótica",
    "section": "Modelo de error de odometría",
    "text": "Modelo de error de odometría\n\nDados los parámetros de error \\(k_L\\) y \\(k_R\\), se puede ver la evolución del error de posición\n\n\n\n\n\n\n\n* La incertidumbre en \\(y\\) crece mucho más rápido que en la dirección del movimiento\n\n\n\n\n\n\n\n* El eje principal de la elipse no permanece perpendicular a la dirección del movimiento\n\n\n\n\n\n\nLas FIGURAS muestran ejemplos típicos de cómo aumentan los errores de posición con el tiempo\nCrecimiento de la incertidumbre de la postura para el movimiento en línea recta: Nótese que la incertidumbre en y crece mucho más rápido que en la dirección del movimiento. Esto se debe a la integración de la incertidumbre sobre la orientación del robot\nCrecimiento de la incertidumbre de la pose para el movimiento circular (r = constante): Nuevamente, la incertidumbre perpendicular al movimiento crece mucho más rápido que la de la dirección del movimiento. Nótese que el eje principal de la elipse de incertidumbre no permanece perpendicular a la dirección del movimiento.\nLos errores deterministas se pueden compensar calibrando correctamente el robot. Sin embargo, los parámetros de error que especifican los errores no deterministas solo se pueden cuantificar mediante mediciones estadísticas (repetitivas)"
  },
  {
    "objectID": "clases/16/index.html#fuentes-de-error-1",
    "href": "clases/16/index.html#fuentes-de-error-1",
    "title": "Robótica",
    "section": "Fuentes de error",
    "text": "Fuentes de error\n\nLa verdadera fuente de error generalmente se produce por un modelo incompleto del entorno\n\n\nErrores sistemáticos\nErrores aleatorios (o no sistemáticos)\n\n\nTodas estas fuentes de error se clasifican en dos categorías: (1) errores sistemáticos y (2) errores no sistemáticos."
  },
  {
    "objectID": "clases/16/index.html#errores-no-sistemáticos",
    "href": "clases/16/index.html#errores-no-sistemáticos",
    "title": "Robótica",
    "section": "Errores no sistemáticos",
    "text": "Errores no sistemáticos\n\nCausados ​​por la interacción del robot con características impredecibles del entorno (aleatorios)\n\n\nDesplazamiento sobre superficies irregulares u objetos inesperados\nDeslizamientos:\n\nSuelo con baja adherencia\nGiro rápido (derrape)\nFuerzas externas (interacción con cuerpos externos)\nFuerzas internas (ruedas libres, patines, etc)\n\nContacto no puntual de las ruedas y el suelo\n\n\n\nPor ejemplo, las irregularidades de la superficie del suelo, como baches, grietas o residuos, harán que una rueda gire más de lo previsto.\nEn superficies rugosas con irregularidades significativas, son predominantes los errores no sistemáticos\nLos errores no sistemáticos representan un gran problema para las aplicaciones reales, mediante el uso de encoders redundantes, los errores no sistemáticos pueden reducirse"
  },
  {
    "objectID": "clases/16/index.html#errores-sistemáticos-1",
    "href": "clases/16/index.html#errores-sistemáticos-1",
    "title": "Robótica",
    "section": "Errores sistemáticos",
    "text": "Errores sistemáticos\n\nSuelen deberse a imperfecciones en la construcción de un robot móvil (deterministas)\n\n\nRuedas no alineadas o diámetro desiguales\nEl promedio de los diámetros difiere del nominal\nVariación en el punto de contacto de la rueda\nResolución y frecuencia de muestro de encoder limitada\nPor el propio modelo de odometría\n\n\nIncerteza en la separación de las ruedas (dado que el punto de contacto de la rueda con el suelo no es “un punto”)\nSe pueden introducir errores de odometría adicionales mediante las propias ecuaciones de odometría, ya que aproximan el movimiento arbitrario como una serie de segmentos rectos cortos. La precisión de esta aproximación depende de la frecuencia de muestreo con respecto a la velocidad del robot. Sin embargo, en nuestra experiencia práctica, este error es insignificante al trabajar con tiempos de muestreo típicos de Ts &lt; 10 ms y velocidades típicas de V &lt; 1 m/s."
  },
  {
    "objectID": "clases/16/index.html#errores-sistemáticos-2",
    "href": "clases/16/index.html#errores-sistemáticos-2",
    "title": "Robótica",
    "section": "Errores sistemáticos",
    "text": "Errores sistemáticos\n\nNo suelen cambiar durante la operación\n\n\nPuede mejorarse la odometría midiendo las fuentes de error más predominantes y contrarrestando su efecto mediante software\n\n\n\n2 fuentes de error más comunes:\n\nDiámetro desiguales de las ruedas \\[D_L \\neq D_R\\]\nIncerteza en la distancia entre las ruedas \\[b?\\]\n\n\n\nLos errores sistemáticos son específicos del vehículo y no suelen cambiar durante la operación (aunque diferentes distribuciones de carga pueden modificar cuantitativamente algunos errores sistemáticos). Por lo tanto, la odometría puede mejorarse en significativamente midiendo la contribución individual de las fuentes de error más predominantes y contrarrestando su efecto en el software."
  },
  {
    "objectID": "clases/16/index.html#incerteza-en-la-distancia-entre-ruedas",
    "href": "clases/16/index.html#incerteza-en-la-distancia-entre-ruedas",
    "title": "Robótica",
    "section": "Incerteza en la distancia entre ruedas",
    "text": "Incerteza en la distancia entre ruedas\n\n\n\nLas ruedas de goma no entran en contacto con el suelo en un punto, sino en una zona de contacto\n\n\n\nDenominamos este error Tipo A asociado al coeficiente \\(E_b\\):\n\\[\nE_b = \\frac{b_{\\textrm{actual}}}{b_{\\textrm{nominal}}}\n\\]\ndonde \\(b\\) es la distancia entre ruedas\n\n\nEl Tipo A se define como un error de orientación que reduce (o aumenta) la rotación total del robot tanto en sentido horario como antihorario.\nLa distancia entre ejes se define como la distancia entre los puntos de contacto de las dos ruedas motrices y el suelo.\nEs necesario conocer la distancia entre ejes para calcular el número de pulsos del codificador diferencial correspondientes a una determinada rotación del vehículo. La incertidumbre se debe a que las ruedas (por lo general de goma) no entran en contacto con el suelo en un punto, sino en una zona de contacto.\nLa incertidumbre resultante puede ser del orden del 1%"
  },
  {
    "objectID": "clases/16/index.html#diámetro-desiguales",
    "href": "clases/16/index.html#diámetro-desiguales",
    "title": "Robótica",
    "section": "Diámetro desiguales",
    "text": "Diámetro desiguales\n\n\n\nNo se fabrican 2 ruedas exactamente iguales\nRuedas de goma se comprimen\n\n\n\nDenominamos este error Tipo B asociado al coeficiente \\(E_d\\):\n\\[\nE_d = \\frac{D_R}{D_L}\n\\]\ndonde \\(D_{L|R}\\) es el diámetro de las ruedas izquierda y derecha respectivamente\n\n\n\\(E_d\\) y \\(E_b\\) son valores adimensionales, expresados ​​como fracciones del valor nominal\n\\(E_b\\) solo afecta al girar y \\(E_d\\) solo afecta al movimiento en línea recta\n\n\nEl Tipo B se define como un error de orientación que reduce (o aumenta) la rotación total en una dirección, pero la aumenta (o reduce) en la otra\nLa mayoría de los robots móviles utilizan ruedas de goma difíciles de fabricar con el mismo diámetro. Además, el material elástico se comprimen de forma diferente bajo una distribución asimétrica de la carga. Cualquiera de estos efectos puede causar errores odométricos considerables."
  },
  {
    "objectID": "clases/16/index.html#errores-de-escala",
    "href": "clases/16/index.html#errores-de-escala",
    "title": "Robótica",
    "section": "Errores de escala",
    "text": "Errores de escala\n\nSi el promedio de los dos diámetros reales \\(D_a\\) difiere del diámetro nominal \\(D_n\\) el vehículo experimentará un error odométrico adicional, denominado error de escala \\(E_s\\)\nTambién conocidos como errores de alcance\n\\(E_s\\) afecta el movimiento en línea recta y el movimiento de giro puro\nPara largos períodos de tiempo, los errores de Tipo A y Tipo B superan los errores de escala\n\\(E_s\\) es fácil de medir y corregir con una regla o cinta métrica\n\n\nSi el promedio de los dos diámetros reales de las ruedas, \\(D_a\\), difiere del diámetro nominal de las ruedas, \\(D_n\\), el vehículo experimentará un error odométrico adicional, denominado error de escala \\(E_s\\). \\(E_s\\) afecta el movimiento en línea recta y el movimiento de giro puro. No obstante, aunque \\(E_s\\) puede ser un error significativo, es extremadamente fácil de medir. Por esta razón, asumiremos que \\(E_s\\) se ha medido y corregido antes de realizar cualquiera de los procedimientos descritos a continuación."
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-unidireccional-1",
    "href": "clases/16/index.html#trayectoria-cuadrada-unidireccional-1",
    "title": "Robótica",
    "section": "Trayectoria cuadrada unidireccional",
    "text": "Trayectoria cuadrada unidireccional\n\n\n\nSe compone de 4 segmentos en línea rcta y 4 rotaciones puras en las esquinas\n\n\nEl robot parte de la posición \\((x_0, y_0)\\), y angulo \\(\\theta_0\\)\nLa posición final muestra el error de odometría\n\n\n\n\n\n\n\n\n\nLa FIGURA muestra una trayectoria unidireccional cuadrada de \\(4 \\mathrm{[m]}\\) de lado. El robot parte de la posición \\(x_0\\), \\(y_0\\), \\(\\theta_0\\). El área de inicio debe ubicarse cerca de la esquina de dos paredes perpendiculares. Las paredes sirven como referencia fija antes y después de la carrera: medir la distancia entre tres puntos específicos del robot y las paredes permite determinar con precisión su posición y orientación absolutas.\nEstas mediciones absolutas se comparan con la posición y la orientación del vehículo, calculadas a partir de los datos odométricos. El resultado es un conjunto de errores de posición de retorno causados ​​por la odometría, denominados \\(\\epsilon_x\\), \\(\\epsilon_y\\) y \\(\\epsilon_\\theta\\)"
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-unidireccional-2",
    "href": "clases/16/index.html#trayectoria-cuadrada-unidireccional-2",
    "title": "Robótica",
    "section": "Trayectoria cuadrada unidireccional",
    "text": "Trayectoria cuadrada unidireccional\n\n\n\nAl comparar la pose del vehículo medida con la calculada por la odometría se obtiene un conjunto de errores \\(\\epsilon_x\\), \\(\\epsilon_y\\) y \\(\\epsilon_\\theta\\)\n\n\\[\n\\begin{gather*}\n\\epsilon_x = x_{\\textrm{abs}} - x_{\\textrm{calc}} \\\\\n\\epsilon_y = y_{\\textrm{abs}} - y_{\\textrm{calc}}\\\\\n\\epsilon_\\theta = \\theta_{\\textrm{abs}} - \\theta_{\\textrm{calc}}\n\\label{eq:errors}\n\\end{gather*}\n\\tag{1}\\]\ndonde:\n\n\\(\\{x,y,\\theta\\}_{\\textrm{abs}}\\): Posición y orientación absoluta del robot\n\\(\\{x,y,\\theta\\}_{\\textrm{calc}}\\): Posición y orientación del robot calculada por la odometría"
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-unidireccional-3",
    "href": "clases/16/index.html#trayectoria-cuadrada-unidireccional-3",
    "title": "Robótica",
    "section": "Trayectoria cuadrada unidireccional",
    "text": "Trayectoria cuadrada unidireccional\n\n\n\nEl error \\(\\textcolor{#9467bd}{E_d}\\) por diámetros desiguales se muestra en la trayectoria ligeramente curvada (línea punteada)\nEl error \\(\\textcolor{#d62728}{E_b}\\) por incertidumbre sobre la distancia entre ejes provoca un giro deficiente (línea discontinua)\n\n\n\n\n\n\n\n\n\nCualquiera de estos dos errores podría haber producido el mismo error de posición\n\n\n\n\n\n\n\n\n\n\n\n\nComo se puede ver en la FIGURA, cualquiera de estos dos casos podría haber producido aproximadamente el mismo error de posición. El hecho de que dos mecanismos de error diferentes puedan resultar en el mismo error general puede llevar al experimentador a cometer un grave error: corregir solo una de las dos fuentes de error en el software."
  },
  {
    "objectID": "clases/16/index.html#simple-compensación-de-error",
    "href": "clases/16/index.html#simple-compensación-de-error",
    "title": "Robótica",
    "section": "Simple compensación de error",
    "text": "Simple compensación de error\n\n\n\nSe aumenta el valor de \\(b\\) para que el robot “gire más” en cada esquina, a lo que parece ser el valor “ideal”\n\n\n\n\n\n\n\n\n\nEste error es tan grave porque producirá resultados aparentemente “excelentes”, como se muestra en el ejemplo de la FIGURA. En este ejemplo, asumimos que el experimentador comenzó a “mejorar” el rendimiento ajustando la distancia entre ejes b en el software de control. El experimentador solo necesita aumentar el valor de b para que el robot gire más en cada giro nominal de 90°. Al hacerlo, el experimentador pronto habrá ajustado b a lo que parece ser el valor “ideal”, es decir, el que hará que el robot gire 93°, compensando así eficazmente el error de orientación de 3° introducido por cada tramo ligeramente curvado (pero nominalmente recto) de la trayectoria cuadrada."
  },
  {
    "objectID": "clases/16/index.html#simple-compensación-de-error-1",
    "href": "clases/16/index.html#simple-compensación-de-error-1",
    "title": "Robótica",
    "section": "Simple compensación de error",
    "text": "Simple compensación de error\n\n\n\nSe aumenta el valor de \\(b\\) para que el robot “gire más” en cada esquina, a lo que parece ser el valor “ideal”\nEl robot “calibrado” tendrá enormes errores de odometría, a pesar de que la trayectoria en un sentido muestre que está bien calibrado\n\n\n\n\n\n\n\n\n\nObviamente, el robot así “calibrado” incurriría en enormes errores de odometría, a pesar de que el procedimiento de calibración unidireccional demostró que el robot estaba bien calibrado.\nEl problema, por lo tanto, es cómo distinguir y calcular los errores de tipo A y tipo B a partir de los errores de posición final medidos del robot en el experimento de trayectoria cuadrada bidireccional"
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-bidireccional-1",
    "href": "clases/16/index.html#trayectoria-cuadrada-bidireccional-1",
    "title": "Robótica",
    "section": "Trayectoria cuadrada bidireccional",
    "text": "Trayectoria cuadrada bidireccional\n\n\n\nRealizar la misma trayectoria, pero en ambos sentidos de giro: horario (CW) y anti-horario (CCW)\nSe obtienen conjuntos de errores \\(\\epsilon_x\\), \\(\\epsilon_y\\) y \\(\\epsilon_\\theta\\) para cada sentido\nSe puede observar:\n\n\n\nLos errores se agrupan en dos áreas distintas\nLa distribución dentro de los grupos es el resultado de errores no sistemáticos\n\n\n\n\n\n\n\n\n\n\nLas posiciones de parada para cinco recorridos, cada uno en sentido horario (cw) y antihorario (ccw), se muestran en la FIGURA.\nLos resultados de la FIGURA pueden interpretarse de la siguiente manera: - a. Las posiciones de frenado después de las carreras en sentido horario y antihorario se agrupan en dos áreas distintas. - b. La distribución dentro de los grupos en sentido horario y antihorario es el resultado de errores no sistemáticos, como se menciona en la Sección 2.1. Sin embargo, la FIGURA muestra que, en un vehículo no calibrado que circula sobre un suelo de hormigón razonablemente liso, la contribución de los errores sistemáticos al error odométrico total es notablemente mayor que la de los errores no sistemáticos."
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-bidireccional-2",
    "href": "clases/16/index.html#trayectoria-cuadrada-bidireccional-2",
    "title": "Robótica",
    "section": "Trayectoria cuadrada bidireccional",
    "text": "Trayectoria cuadrada bidireccional\n\n\n\nCoordenadas de los centroides\n\n\n\\[\n\\def\\ccw#1{{\\underset{\\scriptsize \\textrm{CCW}}{#1}}}\n\\def\\cw#1{{\\underset{\\scriptsize \\textrm{CW}}{#1}}}\n\\def\\ccwcw#1{{\\underset{\\scriptsize \\textrm{CCW|CW}}{#1}}}\n\\]\n\n\\[\n\\ccwcw{\\bar{x}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{x_i}}\n\\label{eq:x_centroid}\n\\tag{2}\\]\n\\[\n\\ccwcw{\\bar{y}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{y_i}}\n\\label{eq:y_centroid}\n\\tag{3}\\] con \\(N = 3,5,7 \\cdots\\) la cantidad de repeticiones para cada lado\n\n\n\n\n\n\n\n\nTras realizar el experimento, se podría derivar un único valor numérico que exprese la precisión odométrica (con respecto a los errores sistemáticos) del vehículo probado. Para minimizar el efecto de los errores no sistemáticos, sugerimos considerar el centroide de cada grupo como representativo de los errores odométricos en las direcciones en sentido horario y antihorario."
  },
  {
    "objectID": "clases/16/index.html#trayectoria-cuadrada-bidireccional-3",
    "href": "clases/16/index.html#trayectoria-cuadrada-bidireccional-3",
    "title": "Robótica",
    "section": "Trayectoria cuadrada bidireccional",
    "text": "Trayectoria cuadrada bidireccional\n\n\n\nOffset de los centroides con respecto al origen\n\n\\[\n\\ccw{\\bar{r}} = \\sqrt{\\ccw{\\bar{x}}^2 + \\ccw{\\bar{y}}^2}\n\\label{eq:r_ccw_centroid}\n\\]\n\\[\n\\cw{\\bar{r}} = \\sqrt{\\cw{\\bar{x}}^2 + \\cw{\\bar{y}}^2}\n\\label{eq:r_cw_centroid}\n\\]\n\nEl mayor valor como la medida para errores sistemáticos:\n\n\\[\nE_{\\textrm{max,sist.}} = \\max{\\left( \\ccw{\\bar{r}}, \\cw{\\bar{r}} \\right)}\n\\]"
  },
  {
    "objectID": "clases/16/index.html#análisis-de-los-errores-sistemáticos-1",
    "href": "clases/16/index.html#análisis-de-los-errores-sistemáticos-1",
    "title": "Robótica",
    "section": "Análisis de los errores sistemáticos",
    "text": "Análisis de los errores sistemáticos\n\nSe analizarán los errores por separado y posteriormente se superpondrán para representar condiciones reales\nUtilizaremos aproximaciones de ángulos pequeños (medidos en radianes):\n\n\\[ L\\sin{\\gamma} \\approx L \\gamma \\qquad L \\cos{\\gamma} \\approx L\\]\n\nPara simplicidad la posición inicial del robot \\((x_0, y_0) = (0,0)\\)"
  },
  {
    "objectID": "clases/16/index.html#errores-de-tipo-a",
    "href": "clases/16/index.html#errores-de-tipo-a",
    "title": "Robótica",
    "section": "Errores de tipo A",
    "text": "Errores de tipo A\n\nLa figura muestra la contribución de los errores de Tipo A (asociados a \\(E_b\\))\nCausan un giro excesivo (o insuficiente) en las esquinas\nLa diferencia de rotación en cada giro de 90° se denota como \\(\\alpha\\) (en \\(\\textrm{[rad]}\\))."
  },
  {
    "objectID": "clases/16/index.html#errores-de-tipo-a-1",
    "href": "clases/16/index.html#errores-de-tipo-a-1",
    "title": "Robótica",
    "section": "Errores de tipo A",
    "text": "Errores de tipo A\n\n\n\n\nSegmento 1: \\[\n\\begin{align*}\nx_1 &= x_0 + L\\\\\ny_1 &= y_0\n\\end{align*}\n\\]\nSegmento 2: \\[\n\\begin{align*}\nx_2 &= x_1 + L \\sin{\\alpha} \\approx (L) + L\\alpha\\\\\ny_2 &= y_1 + L \\cos{\\alpha} \\approx L\n\\end{align*}\n\\]\nSegmento 3: \\[\n\\begin{align*}\nx_3 &= x_2 - L \\cos{2 \\alpha} \\approx (L + L\\alpha) - L \\approx L\\alpha\\\\\ny_3 &= y_2 + L \\sin{2 \\alpha} \\approx (L) + 2 L \\alpha\n\\end{align*}\n\\]\nSegmento 4: \\[\n\\begin{align*}\nx_4 &= x_3 - L \\sin{3 \\alpha} \\approx (L\\alpha) - 3 L \\alpha \\approx \\boxed{-2 L \\alpha}\\\\\ny_4 &= y_3 - L \\cos{3 \\alpha} \\approx (L + 2 L \\alpha) - L \\approx \\boxed{2 L \\alpha}\n\\end{align*}\n\\]\n\n\n\n\n\nEn sentido anti-horario:"
  },
  {
    "objectID": "clases/16/index.html#errores-de-tipo-a-2",
    "href": "clases/16/index.html#errores-de-tipo-a-2",
    "title": "Robótica",
    "section": "Errores de tipo A",
    "text": "Errores de tipo A\n\n\n\n\nSegmento 1: \\[\n\\begin{align*}\nx_1 &= x_0 + L\\\\\ny_1 &= y_0\n\\end{align*}\n\\]\nSegmento 2: \\[\n\\begin{align*}\nx_2 &= x_1 + L \\sin{\\alpha} \\approx (L) + L\\alpha\\\\\ny_2 &= y_1 - L \\cos{\\alpha} \\approx -L\n\\end{align*}\n\\]\nSegmento 3: \\[\n\\begin{align*}\nx_3 &= x_2 - L \\cos{2 \\alpha} \\approx (L + L\\alpha) - L \\approx L\\alpha\\\\\ny_3 &= y_2 - L \\sin{2 \\alpha} \\approx (-L) - 2 L \\alpha \\approx -L -2 L \\alpha\n\\end{align*}\n\\]\nSegmento 4: \\[\n\\begin{align*}\nx_4 &= x_3 - L \\sin{3 \\alpha} \\approx (L\\alpha) - 3 L \\alpha \\approx \\boxed{-2 L \\alpha}\\\\\ny_4 &= y_3 + L \\cos{3 \\alpha} \\approx (-L - 2 L \\alpha) + L \\approx \\boxed{-2 L \\alpha}\n\\end{align*}\n\\]\n\n\n\n\n\nEn sentido horario:"
  },
  {
    "objectID": "clases/16/index.html#errores-tipo-b",
    "href": "clases/16/index.html#errores-tipo-b",
    "title": "Robótica",
    "section": "Errores tipo B",
    "text": "Errores tipo B\n\nLa figura muestra la contribución de los errores de Tipo B (asociados a \\(E_d\\))\nCausan una trayectoria ligeramente curva durante los tramos rectos\nEl robot adquiere un error de orientación incremental \\(\\beta\\) (en \\(\\textrm{[rad]}\\)).\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n\n\n\n\n\n\n \n\n\n\n\nLa línea auxiliar \\(c^\\prime_1\\) (que conecta los vértices de la trayectoria real) tiene una pendiente de \\(\\beta/2\\)"
  },
  {
    "objectID": "clases/16/index.html#errores-tipo-b-1",
    "href": "clases/16/index.html#errores-tipo-b-1",
    "title": "Robótica",
    "section": "Errores tipo B",
    "text": "Errores tipo B\n\n\n\n\nSegmento 1: \\[\n\\begin{align*}\nx_1 &= x_0 + L \\cos{\\beta/2} \\approx L\\\\\ny_1 &= y_0 + L \\sin{\\beta/2} \\approx L \\beta / 2\n\\end{align*}\n\\]\nSegmento 2: \\[\n\\begin{align*}\nx_2 &= x_1 - L \\sin{3 \\beta/2} \\approx L - L \\beta/2\\\\\ny_2 &= y_1 + L \\cos{3 \\beta/2} \\approx L \\beta/2 + L\n\\end{align*}\n\\]\nSegmento 3: \\[\n\\begin{align*}\nx_3 &= x_2 - L \\cos{5 \\beta/2} \\approx -3 L \\beta/2 \\\\\ny_3 &= y_2 - L \\sin{5 \\beta/2} \\approx -2 L \\beta/2 + L\n\\end{align*}\n\\]\nSegmento 4: \\[\n\\begin{align*}\nx_4 &= x_3 + L \\sin{7 \\beta/2} \\approx \\boxed{2 L \\beta}\\\\\ny_4 &= y_3 - L \\cos{7 \\beta/2} \\approx \\boxed{-2 L \\beta}\n\\end{align*}\n\\]\n\n\n\n\n\nEn sentido anti-horario:"
  },
  {
    "objectID": "clases/16/index.html#errores-tipo-b-2",
    "href": "clases/16/index.html#errores-tipo-b-2",
    "title": "Robótica",
    "section": "Errores tipo B",
    "text": "Errores tipo B\n\n\n\n\nSegmento 1: \\[\n\\begin{align*}\nx_1 &= x_0 + L \\cos{\\beta/2} \\approx L\\\\\ny_1 &= y_0 + L \\sin{\\beta/2} \\approx L \\beta / 2\n\\end{align*}\n\\]\nSegmento 2: \\[\n\\begin{align*}\nx_2 &= x_1 + L \\sin{3 \\beta/2} \\approx L + 3 L \\beta/2\\\\\ny_2 &= y_1 - L \\cos{3 \\beta/2} \\approx L \\beta/2 - L\n\\end{align*}\n\\]\nSegmento 3: \\[\n\\begin{align*}\nx_3 &= x_2 - L \\cos{5 \\beta/2} \\approx  3 L \\beta/2 \\\\\ny_3 &= y_2 - L \\sin{5 \\beta/2} \\approx -L (\\beta/2 + 1)\n\\end{align*}\n\\]\nSegmento 4: \\[\n\\begin{align*}\nx_4 &= x_3 - L \\sin{7 \\beta/2} \\approx \\boxed{-2 L \\beta}\\\\\ny_4 &= y_3 + L \\cos{7 \\beta/2} \\approx \\boxed{-2 L \\beta}\n\\end{align*}\n\\]\n\n\n\n\n\nEn sentido horario:"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-de-tipo-a",
    "href": "clases/16/index.html#corrección-de-errores-de-tipo-a",
    "title": "Robótica",
    "section": "Corrección de errores de Tipo A",
    "text": "Corrección de errores de Tipo A\n\n\nError de Tipo A y Tipo B para la dirección \\(x\\) en trayectoria con sentido horario y anti-horario:\n\n\\[\n\\begin{alignat}{2}\n&\\textrm{A)} \\, \\cw{x} &= -2 L \\alpha \\qquad &&\\textrm{B)} \\, \\cw{x} &= -2 L \\beta \\\\\n&\\textrm{A)} \\, \\ccw{x} &= -2 L \\alpha \\qquad &&\\textrm{B)} \\, \\ccw{x} &= 2 L \\beta\n\\end{alignat}\n\\]\n\nSuperponiendo ambos tipos de error y sumando ambas expresiones:\n\n\\[\n\\left.\n\\begin{alignat}{3}\n&\\cw{\\textrm{x:}} \\, -&2 L \\alpha - &2 L \\beta\n&&= \\cw{\\bar{x}} \\\\\n&\\ccw{\\textrm{x:}} \\, -&2 L \\alpha + &2 L \\beta\n&&= \\ccw{\\bar{x}}\n\\end{alignat}\n\\right\\}\n-4 L \\alpha = \\cw{\\bar{x}} + \\ccw{\\bar{x}} \\to \\alpha = \\frac{\\cw{\\bar{x}} + \\ccw{\\bar{x}}}{-4L}\n\\tag{4}\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-de-tipo-a-1",
    "href": "clases/16/index.html#corrección-de-errores-de-tipo-a-1",
    "title": "Robótica",
    "section": "Corrección de errores de Tipo A",
    "text": "Corrección de errores de Tipo A\n\n\nEl mismo análisis para la dirección \\(y\\) muestra un resultado similar:\n\n\\[\n\\begin{alignat}{3}\n&\\textrm{A)} \\, &\\cw{y} &= -2 L \\alpha \\qquad &&\\textrm{B)} \\, \\cw{y} &= -2 L \\beta \\\\\n&\\textrm{A)} \\, &\\ccw{y} &= 2 L \\alpha \\qquad &&\\textrm{B)} \\, \\ccw{y} &= - 2 L \\beta\n\\end{alignat}\n\\]\n\nSuperponiendo ambos tipos de error y restando ambas expresiones:\n\n\\[\n\\left.\n\\begin{alignat}{4}\n&\\cw{\\textrm{y:}} \\, -&2 L \\alpha - &2 L \\beta\n&&= \\cw{\\bar{y}} \\\\\n&\\ccw{\\textrm{y:}} \\, &2 L \\alpha - &2 L \\beta\n&&= \\ccw{\\bar{y}}\n\\end{alignat}\n\\right\\}\n-4 L \\alpha = \\cw{\\bar{y}} - \\ccw{\\bar{y}} \\to \\alpha = \\frac{\\cw{\\bar{y}} - \\ccw{\\bar{y}}}{-4L}\n\\tag{5}\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-de-tipo-a-2",
    "href": "clases/16/index.html#corrección-de-errores-de-tipo-a-2",
    "title": "Robótica",
    "section": "Corrección de errores de Tipo A",
    "text": "Corrección de errores de Tipo A\n\n\nDado que la distancia entre ejes \\(b\\) es inversamente proporcional a la rotación real\n\n\\[\n\\frac{b_{\\textrm{actual}}}{\\pi / 2} = \\frac{b_{\\textrm{nominal}}}{\\pi / 2 - \\alpha} \\to b_{\\textrm{actual}} = \\frac{\\pi / 2}{\\pi / 2 - \\alpha} b_{\\textrm{nominal}}\n\\tag{6}\\]\ny por lo tanto:\n\\[\nE_b = \\frac{\\pi / 2}{\\pi / 2 - \\alpha}\n\\tag{7}\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-tipo-b",
    "href": "clases/16/index.html#corrección-de-errores-tipo-b",
    "title": "Robótica",
    "section": "Corrección de errores Tipo B",
    "text": "Corrección de errores Tipo B\n\n\nAnálisis similar al anterior para la dirección en \\(x\\)\n\n\\[\n\\begin{alignat}{2}\n&\\textrm{A)} \\, &\\cw{x} = -2 L \\alpha \\qquad &&\\textrm{B)} \\, &\\cw{x} &= -2 L \\beta \\\\\n&\\textrm{A)} \\, &\\ccw{x} = -2 L \\alpha \\qquad &&\\textrm{B)} \\, &\\ccw{x} &= 2 L \\beta\n\\end{alignat}\n\\]\n\nSuperponiendo ambos tipos de error y restando ambas expresiones:\n\n\\[\n\\left.\n\\begin{alignat}{3}\n&\\cw{\\textrm{x:}} \\, -&2 L \\alpha - &2 L \\beta\n&&= \\cw{\\bar{x}} \\\\\n&\\ccw{\\textrm{x:}} \\, -&2 L \\alpha + &2 L \\beta\n&&= \\ccw{\\bar{x}}\n\\end{alignat}\n\\right\\}\n-4 L \\beta = \\cw{\\bar{x}} - \\ccw{\\bar{x}} \\to \\beta = \\frac{\\cw{\\bar{x}} - \\ccw{\\bar{x}}}{-4L}\n\\tag{8}\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-tipo-b-1",
    "href": "clases/16/index.html#corrección-de-errores-tipo-b-1",
    "title": "Robótica",
    "section": "Corrección de errores Tipo B",
    "text": "Corrección de errores Tipo B\n\n\nEl mismo procedimiento para la dirección en \\(y\\) arroja un resultado similar\n\n\\[\n\\begin{alignat}{3}\n&\\textrm{A)} \\, &\\cw{y} &= -2 L \\alpha \\qquad &&\\textrm{B)} \\, \\cw{y} &= -2 L \\beta \\\\\n&\\textrm{A)} \\, &\\ccw{y} &= 2 L \\alpha \\qquad &&\\textrm{B)} \\, \\ccw{y} &= - 2 L \\beta\n\\end{alignat}\n\\]\n\nSuperponiendo ambos tipos de error y sumando ambas expresiones:\n\n\\[\n\\left.\n\\begin{alignat}{4}\n&\\cw{\\textrm{y:}} \\, -&2 L \\alpha - &2 L \\beta\n&&= \\cw{\\bar{y}} \\\\\n&\\ccw{\\textrm{y:}} \\, &2 L \\alpha - &2 L \\beta\n&&= \\ccw{\\bar{y}}\n\\end{alignat}\n\\right\\}\n-4 L \\beta = \\cw{\\bar{y}} + \\ccw{\\bar{y}} \\to \\beta = \\frac{\\cw{\\bar{y}} + \\ccw{\\bar{y}}}{-4L}\n\\tag{9}\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-errores-tipo-b-2",
    "href": "clases/16/index.html#corrección-de-errores-tipo-b-2",
    "title": "Robótica",
    "section": "Corrección de errores Tipo B",
    "text": "Corrección de errores Tipo B\n\n\n\nEl radio de curvatura \\(R\\) de las trayectorias en linea recta se puede encontrar a partir del triángulo \\(\\overset{\\triangle}{ABM}\\) en la figura \\[\nR = \\frac{L/2}{\\sin(\\beta/2)}\n\\tag{10}\\]\nPara determinar la relación entre los diámetros de las ruedas:\n\n\\[\nE_d = \\frac{D_R}{D_L} = \\frac{R + b/2}{R - b/2}\n\\label{eq:wheel_correction}\n\\tag{11}\\]\n\n\n\nEsta relación se puede utilizar para corregir errores de Tipo B"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-ambos-tipo-de-error",
    "href": "clases/16/index.html#corrección-de-ambos-tipo-de-error",
    "title": "Robótica",
    "section": "Corrección de ambos tipo de error",
    "text": "Corrección de ambos tipo de error\n\nLa corrección del error de distancia entre ejes \\(E_b\\) es trivial\n\n\nLa distancia entre ejes \\(b\\) se redefine según la ecuación: \\[\nb_{\\textrm{actual}} = \\frac{\\pi / 2}{\\pi / 2 - \\alpha} b_{\\textrm{nominal}}\n\\]\n\n\nLa corrección para los diámetros de rueda desiguales \\(E_d\\) es más compleja\n\n\nAl aplicar un factor de compensación, debemos asegurarnos de no modificar el diámetro medio de la rueda \\(D_a = (D_R + D_L)/2\\)\n\n\nUna vez conocidos los valores cuantitativos de \\(E_d\\) y \\(E_b\\), es fácil compensar estos errores en el software.\nLa corrección del error de distancia entre ejes \\(E_b\\) es trivial: la distancia entre ejes \\(b\\) se redefine en el software según la ecuación \\(\\ref{eq:new_b}\\).\nLa corrección para los diámetros de rueda desiguales, \\(E_d\\), es ligeramente más compleja. Tras realizar los experimentos bidireccionales, se conoce la relación real de los diámetros de la ruedas \\(E_d = D_R/D_L\\) a partir de la ecuación \\(\\ref{eq:wheel_correction}\\). Sin embargo, al aplicar un factor de compensación, debemos asegurarnos de no modificar el diámetro medio de la rueda \\(D_a\\), ya que sería necesario recalibrar dicho parámetro. Por lo tanto \\(D_a = (D_R + D_L)/2\\)"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-ambos-tipo-de-error-1",
    "href": "clases/16/index.html#corrección-de-ambos-tipo-de-error-1",
    "title": "Robótica",
    "section": "Corrección de ambos tipo de error",
    "text": "Corrección de ambos tipo de error\n\nResolviendo\n\n\\[\n\\left.\n\\begin{aligned}\nD_a = (D_R + D_L)/2 \\\\\nE_d = \\frac{D_R}{D_L}\n\\end{aligned}\n\\right\\}\nE_d D_L + \\frac{D_R}{E_d} = 2 D_a\n\\]\n\nSe obtiene\n\n\\[\n\\begin{align*}\nE_d D_L + D_L = 2 D_a &\\to D_L = \\frac{2}{E_d +1} D_a \\\\\nD_R + \\frac{D_R}{E_d} = 2 D_a &\\to D_R = \\frac{2}{\\frac{1}{E_d} +1} D_a\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/16/index.html#corrección-de-ambos-tipo-de-error-2",
    "href": "clases/16/index.html#corrección-de-ambos-tipo-de-error-2",
    "title": "Robótica",
    "section": "Corrección de ambos tipo de error",
    "text": "Corrección de ambos tipo de error\n\nSe definen dos factores de corrección:\n\n\\[\n\\begin{align*}\nc_L &= \\frac{2}{E_d + 1} \\\\\nc_R &= \\frac{2}{\\frac{1}{E_d} + 1}\n\\end{align*}\n\\tag{12}\\]\n\nSe re-escribe la ecuación de desplazamiento lineal de las ruedas:\n\n\\[\n\\Delta s_{L|R,i} = \\pi \\cdot D_{L|R} \\cdot \\frac{N_{L|R, i}}{c_e} \\cdot c_{L|R}\n\\]"
  },
  {
    "objectID": "clases/16/index.html#resumen-del-procedimiento",
    "href": "clases/16/index.html#resumen-del-procedimiento",
    "title": "Robótica",
    "section": "Resumen del procedimiento",
    "text": "Resumen del procedimiento\n\nMedir la posición absoluta del vehículo.\nRealizar la trayectoria cuadrada de 4x4 [m] en sentido horario, asegurándose de:\n\ndetenerse después de cada tramo recto de 4[m]\nrealizar un total de cuatro giros de 90° en la esquina\nconducir el robot lentamente para evitar deslizamientos\n\nAl regresar a la zona de inicio, medir la posición absoluta del vehículo.\nCompare la posición absoluta con la posición calculada del robot utilizando las ecuaciones en 1.\nRepita los pasos 1 a 4 cuatro veces más\nRepita los pasos 1 a 5 en sentido antihorario\nUtilice las ecuaciones 2, 3 para obtener \\(\\ccwcw{\\bar{x}}\\) y \\(\\ccwcw{\\bar{y}}\\)"
  },
  {
    "objectID": "clases/16/index.html#resumen-del-procedimiento-1",
    "href": "clases/16/index.html#resumen-del-procedimiento-1",
    "title": "Robótica",
    "section": "Resumen del procedimiento",
    "text": "Resumen del procedimiento\n\n\n\nCon \\(\\alpha\\) (ec. 4 o 5), obtener el nuevo valor de \\(b\\) (6): \\[\nb_{\\textrm{actual}} = \\frac{\\pi / 2}{\\pi / 2 - \\alpha} b_{\\textrm{nominal}}\n\\]\nCon \\(\\beta\\) (ec. 8 o 9), \\(R\\) (10) y \\(E_d\\) (11), obtener los coeficientes de corrección \\(c_L\\) y \\(c_R\\) (12): \\[\n\\begin{align*}\nc_L &= \\frac{2}{E_d + 1} \\\\\nc_R &= \\frac{2}{\\frac{1}{E_d} + 1}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/16/index.html#referencias-1",
    "href": "clases/16/index.html#referencias-1",
    "title": "Robótica",
    "section": "Referencias",
    "text": "Referencias\n\n\nBorenstein, J., and Liqiang Feng. 1996. “Measurement and Correction of Systematic Odometry Errors in Mobile Robots.” IEEE Transactions on Robotics and Automation 12 (6): 869–80. https://doi.org/10.1109/70.544770.\n\n\nBorenstein, Johann, Hobart R. Everett, and Liqiang Feng. 1996. “Where Am i?\" Sensors and Methods for Mobile Robot Positioning.” In. https://api.semanticscholar.org/CorpusID:59906505.\n\n\nBorenstein, Johann, Hobart R. Everett, Liqiang Feng, and David K. Wehe. 1997. “Mobile Robot Positioning: Sensors and Techniques.” J. Field Robotics 14: 231–49. https://api.semanticscholar.org/CorpusID:1045982.\n\n\nChong, Kok Seng, and L. Kleeman. 1997. “Accurate Odometry and Error Modelling for a Mobile Robot.” In Proceedings of International Conference on Robotics and Automation, 4:2783–2788 vol.4. https://doi.org/10.1109/ROBOT.1997.606708."
  },
  {
    "objectID": "clases/16/index.html#laboratorio-1",
    "href": "clases/16/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nCalibración de odometría"
  },
  {
    "objectID": "clases/15/index.html#caso-práctico-seguidor-de-línea",
    "href": "clases/15/index.html#caso-práctico-seguidor-de-línea",
    "title": "Robótica",
    "section": "Caso práctico: Seguidor de línea",
    "text": "Caso práctico: Seguidor de línea\nObjetivos\n\nSimular una cámara en Gazebo y obtener video desde ROS2\nUtilizar procesamiento de imágenes para detectar el camino\nControlar el robot para seguir la pista\n\n\n\n\n\n\n\n\n\nDesde la cámara:"
  },
  {
    "objectID": "clases/15/index.html#simulación-de-cámara-1",
    "href": "clases/15/index.html#simulación-de-cámara-1",
    "title": "Robótica",
    "section": "Simulación de cámara",
    "text": "Simulación de cámara\n\nSensor de referencia: Raspberry Pi Camera V2\n\n\n\n\nSensor model: Sony IMX219 - 8MP\nVideo modes: 1080p47, 1640x1232p41 and 640x480p206\nDepth of field: \\(10 \\mathrm{[cm]}\\) to \\(\\infty\\)\nFocal length: \\(3.04 \\mathrm{[mm]}\\)\nHorizontal Field of View (FoV): \\(62.2 \\mathrm{°}\\)\nVertical Field of View (FoV): \\(48.8 \\mathrm{°}\\)\nSize: \\(25 \\times 24 \\times 9 \\mathrm{[mm]}\\)\n\n\n\n\n\n\n\n\n\nFuente: Raspberry Pi (www.raspberrypi.com)\n\n\n\n\n\nEspecificaciones Camera Module v2 (www.raspberrypi.com)"
  },
  {
    "objectID": "clases/15/index.html#sistema-de-coordenadas",
    "href": "clases/15/index.html#sistema-de-coordenadas",
    "title": "Robótica",
    "section": "Sistema de coordenadas",
    "text": "Sistema de coordenadas\n\nPor lo general la dirección del eje \\(\\require{color} \\textcolor{red}{\\mathbf{x}}\\) es de izquierda a derecha y la dirección del eje \\(\\require{color} \\textcolor{green}{\\mathbf{y}}\\) de arriba hacia abajo\nPor regla de la mano derecha, el eje \\(\\require{color} \\textcolor{blue}{\\mathbf{z}}\\) debe ir hacia adelante de la cámara"
  },
  {
    "objectID": "clases/15/index.html#sistema-de-coordenadas-1",
    "href": "clases/15/index.html#sistema-de-coordenadas-1",
    "title": "Robótica",
    "section": "Sistema de coordenadas",
    "text": "Sistema de coordenadas\n\nPara solucionarlo utilizamos dos marcos:\n\nuno para la cámara (con orientación ENU): cam_link\notro que represente el marco óptico: cam_optical_link\n\n\n&lt;link name=\"cam_optical_link\"&gt;&lt;/link&gt;\n\n&lt;joint name=\"cam_optical_joint\" type=\"fixed\"&gt;\n    &lt;origin xyz=\"0 0 0\" rpy=\"${-pi/2} 0 ${-pi/2}\" /&gt;\n    &lt;parent link=\"cam_link\" /&gt;\n    &lt;child link=\"cam_optical_link\" /&gt;\n&lt;/joint&gt;\n\n\n\n\n\n\n\nLuego los headers de los mensages de Image y CameraInfo deben hacer referencia al cam_optical_link"
  },
  {
    "objectID": "clases/15/index.html#parámetros-de-la-cámara",
    "href": "clases/15/index.html#parámetros-de-la-cámara",
    "title": "Robótica",
    "section": "Parámetros de la cámara",
    "text": "Parámetros de la cámara\n\nDescripción del sensor: RPiCamV2\n\nLinks: cam_link, cam_optical_link\nFotogramas por segundo: 25\n\n\n\n\nsim_camera.xacro\n\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt; \n  &lt;!-- .. --&gt;\n  &lt;gazebo reference=\"cam_link\"&gt;\n    &lt;sensor name=\"RPiCamV2\" type=\"camera\"&gt;\n      &lt;always_on&gt;1&lt;/always_on&gt;\n      &lt;update_rate&gt;25&lt;/update_rate&gt;\n      &lt;visualize&gt;true&lt;/visualize&gt;\n      \n      &lt;topic&gt;camera&lt;/topic&gt;\n      &lt;camera_camera_info_topic&gt;camera_info&lt;/camera_camera_info_topic&gt;\n      &lt;optical_frame_id&gt;cam_optical_link&lt;/optical_frame_id&gt;\n\n      &lt;camera name=\"IMX219\"&gt;\n          &lt;!-- Parámetros de la cámara --&gt;\n      &lt;/camera&gt;\n    &lt;/sensor&gt;\n  &lt;/gazebo&gt;\n  &lt;!-- .. --&gt;\n&lt;/robot&gt;"
  },
  {
    "objectID": "clases/15/index.html#parámetros-de-la-cámara-1",
    "href": "clases/15/index.html#parámetros-de-la-cámara-1",
    "title": "Robótica",
    "section": "Parámetros de la cámara",
    "text": "Parámetros de la cámara\n\nDescripción de los parámetros de la cámara\n\n\n\n\n\\(W = 640 \\mathrm{px}\\), \\(H = 480 \\mathrm{px}\\)\n\\(H_{FoV} = 62.2 \\mathrm{°} \\approx 1.085595 \\mathrm{[rad]}\\)\n\\(V_{FoV} = 48.8 \\mathrm{°} \\approx 0.851721 \\mathrm{[rad]}\\)\n\\(\\texttt{fx} = \\frac{W}{2 \\cdot \\tan(\\frac{H_{FoV} \\mathrm{[rad]}}{2})} \\approx 530.47\\)\n\\(\\texttt{fy} = \\frac{H}{2 \\cdot \\tan(\\frac{V_{FoV} \\mathrm{[rad]}}{2})} \\approx 529.08\\)\n\\(\\texttt{cx} = \\frac{W - 1}{2} = \\frac{639}{2} = 319.5\\)\n\\(\\texttt{cy} = \\frac{H - 1}{2} = \\frac{479}{2} = 239.5\\)\n\n\n\n\nsim_camera.xacro\n\n&lt;camera name=\"IMX219\"&gt;\n  &lt;horizontal_fov&gt;1.085595&lt;/horizontal_fov&gt;\n  &lt;lens&gt;\n    &lt;intrinsics&gt;\n      &lt;fx&gt;530.47&lt;/fx&gt;\n      &lt;fy&gt;529.08&lt;/fy&gt;\n      &lt;cx&gt;319.5&lt;/cx&gt;\n      &lt;cy&gt;239.5&lt;/cy&gt;\n      &lt;s&gt;0&lt;/s&gt;\n    &lt;/intrinsics&gt;\n  &lt;/lens&gt;\n  &lt;image&gt; &lt;!-- 640x480 mode --&gt;\n    &lt;width&gt;640&lt;/width&gt;\n    &lt;height&gt;480&lt;/height&gt;\n    &lt;format&gt;R8G8B8&lt;/format&gt;\n  &lt;/image&gt;\n  &lt;clip&gt;\n    &lt;near&gt;0.01&lt;/near&gt;\n    &lt;far&gt;25&lt;/far&gt;\n  &lt;/clip&gt;\n  &lt;noise&gt;\n    &lt;type&gt;gaussian&lt;/type&gt;\n    &lt;mean&gt;0&lt;/mean&gt;\n    &lt;stddev&gt;0.007&lt;/stddev&gt;\n  &lt;/noise&gt;\n&lt;/camera&gt;"
  },
  {
    "objectID": "clases/15/index.html#plugin-de-sensores",
    "href": "clases/15/index.html#plugin-de-sensores",
    "title": "Robótica",
    "section": "Plugin de sensores",
    "text": "Plugin de sensores\n\nPara la simulación del sensor es necesario añadir en el URDF el plugin de Sensors\n\n\n\nsim_camera.xacro\n\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\"&gt; \n  &lt;!-- .. --&gt;\n  &lt;gazebo&gt;\n    &lt;plugin\n      filename=\"gz-sim-sensors-system\"\n      name=\"gz::sim::systems::Sensors\"&gt;\n      &lt;render_engine&gt;ogre2&lt;/render_engine&gt;\n    &lt;/plugin&gt;\n  &lt;/gazebo&gt;\n  &lt;!-- .. --&gt;\n&lt;/robot&gt;"
  },
  {
    "objectID": "clases/15/index.html#ros_gz_bridge",
    "href": "clases/15/index.html#ros_gz_bridge",
    "title": "Robótica",
    "section": "ros_gz_bridge",
    "text": "ros_gz_bridge\n\nActualizar el launch\n\n\n\n*.launch.py\n\n    Node(\n        package=\"ros_gz_bridge\",\n        executable=\"parameter_bridge\",\n        parameters=[{\n            \"config_file\": PathJoinSubstitution(\n                [FindPackageShare(\"&lt;nombre_paquete&gt;\"), \"config\", \"gz_bridge.yaml\"]\n            ),\n        }],\n    )\n\n\nActualizar el archivo de configuración:\n\n\n\ngz_bridge.yaml\n\n# Image from camera\n- topic_name: \"/camera\"\n  ros_type_name: \"sensor_msgs/msg/Image\"\n  gz_type_name: \"gz.msgs.Image\"\n  direction: GZ_TO_ROS"
  },
  {
    "objectID": "clases/15/index.html#visualización-de-la-imágen",
    "href": "clases/15/index.html#visualización-de-la-imágen",
    "title": "Robótica",
    "section": "Visualización de la imágen",
    "text": "Visualización de la imágen\n\nrqt_image_view\n\n  $ ros2 run rqt_image_view rqt_image_view"
  },
  {
    "objectID": "clases/15/index.html#procesamiento-mediante-cv2",
    "href": "clases/15/index.html#procesamiento-mediante-cv2",
    "title": "Robótica",
    "section": "Procesamiento mediante cv2",
    "text": "Procesamiento mediante cv2\nEtapas\n\nCaptura\nPreprocesamiento\nDetección del camino\nEstimación del curso"
  },
  {
    "objectID": "clases/15/index.html#captura-desde-ros2",
    "href": "clases/15/index.html#captura-desde-ros2",
    "title": "Robótica",
    "section": "0. Captura desde ROS2",
    "text": "0. Captura desde ROS2\n\nSe utiliza el paquete cv_bridge de vision_opencv para convertir los mensajes de tipo Image de ROS2 al tipo de dato utilizado por cv2\n\n\nDado el nodo LineDetector se crea el CvBridge y el subscriptor al topic /camera:\n\nimport rclpy\nfrom rclpy.node import Node\n\nfrom sensor_msgs.msg import Image\nimport cv_bridge\n\nclass LineDetector(Node):\n    def __init__(self):\n        # ..        \n        self.bridge = cv_bridge.CvBridge()\n        self.sub = self.create_subscription(Image, 'camera', self.sub_callback, 10)\n\n    def sub_callback(self, msg: Image):\n        image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n        # .."
  },
  {
    "objectID": "clases/15/index.html#captura-desde-ros2-1",
    "href": "clases/15/index.html#captura-desde-ros2-1",
    "title": "Robótica",
    "section": "0. Captura desde ROS2",
    "text": "0. Captura desde ROS2\n\nSe utiliza el paquete cv_bridge de vision_opencv para convertir los mensajes de tipo Image de ROS2 al tipo de dato utilizado por cv2"
  },
  {
    "objectID": "clases/15/index.html#preprocesamiento",
    "href": "clases/15/index.html#preprocesamiento",
    "title": "Robótica",
    "section": "1. Preprocesamiento",
    "text": "1. Preprocesamiento\n\nDisminuir la resolución para reducir la carga computacional y obtener mejor rendimiento\n\n\nimage = cv2.resize(image, None, 1, 0.25, 0.25, cv2.INTER_CUBIC)"
  },
  {
    "objectID": "clases/15/index.html#detección-del-camino",
    "href": "clases/15/index.html#detección-del-camino",
    "title": "Robótica",
    "section": "2. Detección del camino",
    "text": "2. Detección del camino\n\nAplicar una máscara sobre la representación HSV\n\n\nUtilizando la representación HSV podemos utilizar la información del canal de Value para detectar los píxeles de la línea\nRepresentaciones HSV:\n\n\n\n\n\nRepresentación RGB\nRepresentación HSV\n\n\n\n\n\nRed\nGreen\nBlue\nHue\nSat.\nValue\n\n\nrojo\n255\n0\n0\n0°\n100%\n100%\n\n\nverde\n0\n255\n0\n120°\n100%\n100%\n\n\nazul\n0\n0\n255\n240°\n100%\n100%\n\n\nblanco\n255\n255\n255\n-\n0%\n100%\n\n\nnegro\n0\n0\n0\n-\n-\n0%"
  },
  {
    "objectID": "clases/15/index.html#detección-del-camino-1",
    "href": "clases/15/index.html#detección-del-camino-1",
    "title": "Robótica",
    "section": "2. Detección del camino",
    "text": "2. Detección del camino\n\n\nUsar la función inRange(..) para construir la máscara\n\n\nRecibe como parámetros:\n\nUna imágen de 3 canales: \\(I(x,y) = (H(x,y), S(x,y), V(x,y))\\)\nEl límite inferior: \\(L = (H_{min}, S_{min}, V_{min})\\)\nEl límite superior: \\(U = (H_{max}, S_{max}, V_{max})\\)\n\nDevuelve:\n\nUna imágen de 1 canal \\(M(x,y)\\): \\[\nM(x,y) = \\begin{cases}\n255 \\quad \\textrm{si} \\, \\left| \\begin{matrix} H_{min} \\leq H(x,y) \\leq H_{max} \\\\\nS_{min} \\leq  S(x,y) \\leq S_{max} \\\\\nV_{min} \\leq V(x,y) \\leq V_{max} \\\\\n\\end{matrix} \\right. \\\\\n0 \\quad \\textrm{en cualquier otro caso}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/15/index.html#detección-del-camino-2",
    "href": "clases/15/index.html#detección-del-camino-2",
    "title": "Robótica",
    "section": "2. Detección del camino",
    "text": "2. Detección del camino\n\nUsar la función inRange(..) para construir la máscara\n\n\nEjemplo para el negro: H: (0-180°), S: (0-100%), V: (0-12%)\n\n# Definir rango de la máscara\nlower = np.array([0, 0, 0])\nupper = np.array([255, 255, 30])\n# Aplicar máscara\nmask = cv2.inRange(image_hsv, lower, upper)"
  },
  {
    "objectID": "clases/15/index.html#detección-del-camino-3",
    "href": "clases/15/index.html#detección-del-camino-3",
    "title": "Robótica",
    "section": "2. Detección del camino",
    "text": "2. Detección del camino\n\nUsar la función inRange(..) para construir la máscara\n\n\nAplicado a la imágen del camino:"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso",
    "href": "clases/15/index.html#estimación-del-curso",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nRecibe como parámetro:\n\nUna imágen con intensidad de píxel \\(I(x,y)\\)\n\nDevuelve:\n\nMomentos hasta de 3er orden:\n\n\n\\[\nM_{pq} = \\sum_x \\sum_y x^p y^q I(x,y)\n\\]\ndonde \\(p\\) y \\(q\\) son los índices del momento, el orden se define como \\(p + q\\)"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-1",
    "href": "clases/15/index.html#estimación-del-curso-1",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nMomento de orden cero: \\(p=0\\) y \\(q=0\\)\n\n\\[\nM_{00} = \\sum_x \\sum_y x^0 y^0 I(x,y) = \\sum_x \\sum_y (1) (1) I(x,y) = \\sum_x \\sum_y I(x,y)\n\\]\n\n\n\n\n\n\nEn una imágen binaria, es equivalente a contar la cantidad de píxeles con valor 1"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-2",
    "href": "clases/15/index.html#estimación-del-curso-2",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nMomentos de orden uno: \\(\\langle p=1, q=0 \\rangle\\) y \\(\\langle p=0, q=1 \\rangle\\)\n\n\\[\nM_{10} = \\sum_x \\sum_y x^1 y^0 I(x,y) = \\sum_x \\sum_y x (1) I(x,y) = \\sum_x \\sum_y x I(x,y)\n\\]\n\\[\nM_{01} = \\sum_x \\sum_y x^0 y^1 I(x,y) = \\sum_x \\sum_y (1) y I(x,y) = \\sum_x \\sum_y y I(x,y)\n\\]\n\n\n\n\n\n\nEn una imágen binaria, es equivalente a sumar las coordenadas \\(x\\) (para \\(M_{10}\\)) e \\(y\\) (para \\(M_{01}\\)) de píxeles con valor 1"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-3",
    "href": "clases/15/index.html#estimación-del-curso-3",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nA partir de los momentos es posible calcular el centroide \\((C_x, C_y)\\):\n\n\\[\nC_x = \\frac{M_{10}}{M_{00}} \\qquad C_y = \\frac{M_{01}}{M_{00}}\n\\]"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-4",
    "href": "clases/15/index.html#estimación-del-curso-4",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nEjemplo numérico: Sea una imágen de \\(100\\times100\\) píxeles negros, con un cuadrado de \\(50\\times50\\) de píxeles blancos ubicados en el centro\n\n\n\n\n\n\n\nPara todos los momentos solo se contalibilizaran los píxeles blancos, es decir, solo los píxeles \\((x,y)\\) tal que \\(25 \\leq x,y &lt; 75\\):\n\n\n\n\nMomento de orden cero:\n\n\\[\nM_{00} = \\sum_{x=25}^{74} \\sum_{y=25}^{74} 1 = 50 \\times 50 = 2500\n\\]"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-5",
    "href": "clases/15/index.html#estimación-del-curso-5",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nEjemplo numérico: Sea una imágen de \\(100\\times100\\) píxeles negros, con un cuadrado de \\(50\\times50\\) de píxeles blancos ubicados en el centro\nMomento de orden 1: \\(M_{10}\\) (sumatoria en \\(x\\))\n\n\\[\nM_{10} = \\sum_{x=25}^{74} \\sum_{y=25}^{74} x\n\\]\npara una coordenada \\(x\\) la sumatoria sobre \\(y\\), \\(x\\) se mantiene constante\n\\[\nM_{10} = \\sum_{x=25}^{74} (50 \\cdot x) =  50 \\cdot \\sum_{x=25}^{74} x = 50 \\cdot \\frac{50 (25 + 74)}{2} = 50 \\cdot 2475 = 123750\n\\]"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-6",
    "href": "clases/15/index.html#estimación-del-curso-6",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nEjemplo numérico: Sea una imágen de \\(100\\times100\\) píxeles negros, con un cuadrado de \\(50\\times50\\) de píxeles blancos ubicados en el centro\nMomento de orden 1: \\(M_{01}\\) (sumatoria en \\(y\\)): Al ser simétrico el ejemplo, el valor es igual a \\(M_{10}\\)\n\n\\[\nM_{01} = 50 \\cdot \\sum_{y=25}^{74} y = 50 \\cdot 2475 = 123750\n\\]"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-7",
    "href": "clases/15/index.html#estimación-del-curso-7",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nEjemplo numérico: Sea una imágen de \\(100\\times100\\) píxeles negros, con un cuadrado de \\(50\\times50\\) de píxeles blancos ubicados en el centro\n\n\n\n\n\\[\nC_x = \\frac{M_{10}}{M_{00}} = \\frac{123750}{2500} = 49.5\n\\] \\[\nC_y = \\frac{M_{01}}{M_{00}} = \\frac{123750}{2500} = 49.5\n\\]"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-8",
    "href": "clases/15/index.html#estimación-del-curso-8",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\n\nOtros ejemplos"
  },
  {
    "objectID": "clases/15/index.html#estimación-del-curso-9",
    "href": "clases/15/index.html#estimación-del-curso-9",
    "title": "Robótica",
    "section": "3. Estimación del curso",
    "text": "3. Estimación del curso\n\nEncontrar el centroide usando la función moments(..)\n\nM = cv2.moments(mask)\nif M['m00'] &gt; 0:\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])"
  },
  {
    "objectID": "clases/15/index.html#seguimiento-de-la-pista",
    "href": "clases/15/index.html#seguimiento-de-la-pista",
    "title": "Robótica",
    "section": "Seguimiento de la pista",
    "text": "Seguimiento de la pista\n\n\n\nUtilizando la desviación horizontal del centroide respecto del centro podemos controlar el robot para mantener el curso\n\n\nSea el centro de la imagen \\(W/2\\) y \\(e\\) la diferencia con la coordenada \\(x\\) del centroide, \\(c_x\\): \\[e = (W/2) - c_x\\]\nSi el centroide está a la izquierda: \\[0 \\leq c_x &lt; W/2 \\to 0 &lt; e \\leq W/2\\]"
  },
  {
    "objectID": "clases/15/index.html#seguimiento-de-la-pista-1",
    "href": "clases/15/index.html#seguimiento-de-la-pista-1",
    "title": "Robótica",
    "section": "Seguimiento de la pista",
    "text": "Seguimiento de la pista\n\n\n\nUtilizando la desviación horizontal del centroide respecto del centro podemos controlar el robot para mantener el curso\n\n\nSea el centro de la imagen \\(W/2\\) y \\(e\\) la diferencia con la coordenada \\(x\\) del centroide, \\(c_x\\): \\[e = (W/2) - c_x\\]\nSi el centroide está a la derecha: \\[W/2 &lt; c_x \\leq W \\to -W/2 \\leq e &lt; 0\\]"
  },
  {
    "objectID": "clases/15/index.html#seguimiento-de-la-pista-2",
    "href": "clases/15/index.html#seguimiento-de-la-pista-2",
    "title": "Robótica",
    "section": "Seguimiento de la pista",
    "text": "Seguimiento de la pista\n\n\n\nUtilizando la desviación horizontal del centroide respecto del centro podemos controlar el robot para mantener el curso\n\n\nSea el centro de la imagen \\(W/2\\) y \\(e\\) la diferencia con la coordenada \\(x\\) del centroide, \\(c_x\\): \\[e = (W/2) - c_x\\]\n\n\n\n\n\n\n\n\n\nPor lo tanto: \\[\n\\left.\n\\begin{alignat}{2}\n% c_x &lt; W/2& \\to      -W/2 &&\\leq e  &lt; 0 \\\\\n0 \\leq c_x &lt; W/2& \\to \\qquad 0 &&&lt; e \\leq W/2 \\\\\n%c_x &gt; W/2& \\to \\qquad   0 &&&lt; e \\geq W/2\nW/2 &lt; c_x \\leq W& \\to -W/2 &&\\leq e &lt; 0\n\\end{alignat}\\right\\} -W/2 \\leq e \\leq W/2\n\\]"
  },
  {
    "objectID": "clases/15/index.html#seguimiento-de-la-pista-3",
    "href": "clases/15/index.html#seguimiento-de-la-pista-3",
    "title": "Robótica",
    "section": "Seguimiento de la pista",
    "text": "Seguimiento de la pista\nComando de Twist\n\nVelocidad lineal: puede ser constante \\(\\to 0.25 \\textrm{[m/s]}\\)\nVelocidad angular: variable entre \\(\\to (-\\dot\\theta_{max},\\dot\\theta_{max}) \\textrm{[rad/s]}\\)\n\n\\[\n\\require{color}\n\\dot\\theta = \\textcolor{Maroon}{\\alpha} * \\dot\\theta_{max} \\quad \\textrm{con} \\ \\textcolor{Maroon}{\\alpha} \\in (-1, 1)\n\\]\n\nDividiendo \\(e\\) por \\(W/2\\) se puede acotar entre \\((-1, 1)\\):\n\n\\[\n-W/2 \\leq e \\leq W/2 \\ \\to \\ -1 \\leq \\frac{e}{W/2} \\leq 1\n\\] \n\\[\n\\textcolor{Maroon}{\\alpha} = \\frac{e}{W/2} = \\frac{(W/2) - c_x}{W/2} = 1 - \\frac{c_x}{W/2} = 1 - \\frac{2 * c_x}{W}\n\\]"
  },
  {
    "objectID": "clases/15/index.html#ejemplo-1",
    "href": "clases/15/index.html#ejemplo-1",
    "title": "Robótica",
    "section": "Ejemplo 1",
    "text": "Ejemplo 1\n\n\n\nCentroide a la izquierda\n\n\\[\n\\textcolor{Maroon}{\\alpha} = 1 - \\frac{2 c_x}{W} = 1 - \\frac{2 * 54}{160} = 0.325\n\\]\n\\[\n\\begin{aligned}\n\\dot\\theta &= \\textcolor{Maroon}{\\alpha} * \\theta_{max} \\\\\n           &= 0.325 * 1.0 \\textrm{[rad/s]} \\\\\n           &= 0.325 \\textrm{[rad/s]}\n\\end{aligned}\n\\]\n\nComando:\n\n{linear: { x: 0.25 }, angular: { z: 0.315 }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCon velocidad angular positiva el robot girará hacia su izquierda ✅"
  },
  {
    "objectID": "clases/15/index.html#ejemplo-2",
    "href": "clases/15/index.html#ejemplo-2",
    "title": "Robótica",
    "section": "Ejemplo 2",
    "text": "Ejemplo 2\n\n\n\nCentroide a la derecha\n\n\\[\n\\textcolor{Maroon}{\\alpha} = 1 - \\frac{2 c_x}{W} = 1 - \\frac{2 * 99}{160} = -0.2375\n\\]\n\\[\n\\begin{aligned}\n\\dot\\theta &= \\textcolor{Maroon}{\\alpha} * \\theta_{max} \\\\\n           &= -0.2375 * 1.0 \\textrm{[rad/s]} \\\\\n           &= -0.2375 \\textrm{[rad/s]}\n\\end{aligned}\n\\]\n\nComando:\n\n{linear: { x: 0.25 }, angular: { z: -0.2375 }}\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nCon velocidad angular negativa el robot girará hacia su derecha ✅"
  },
  {
    "objectID": "clases/15/index.html#funciones-auxiliares",
    "href": "clases/15/index.html#funciones-auxiliares",
    "title": "Robótica",
    "section": "Funciones auxiliares",
    "text": "Funciones auxiliares\nVer el procesamiento en tiempo real\n\nSe crea una ventana utilizando la función namedWindow en el constructor del nodo\n\nclass LineDetector(Node):\n    def __init__(self):\n        # ..        \n        cv2.namedWindow(\"Robot_camera\", 1)\n\nLuego en el callback se puede mostrar el resultado\n\n    def sub_callback(self, msg: Image):\n        image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n        # ..\n        # Dibujar el centroide\n        cv2.circle(image, (cx, cy), 5, (0,0,255), -1)\n        \n        cv2.imshow(\"Robot_camera\", image)\n        cv2.waitKey(3)"
  },
  {
    "objectID": "clases/15/index.html#demo-1",
    "href": "clases/15/index.html#demo-1",
    "title": "Robótica",
    "section": "Demo",
    "text": "Demo"
  },
  {
    "objectID": "clases/15/index.html#laboratorio-1",
    "href": "clases/15/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nSeguidor de lineas"
  },
  {
    "objectID": "clases/05/index.html#resumen-clase-04",
    "href": "clases/05/index.html#resumen-clase-04",
    "title": "Robótica",
    "section": "Resumen Clase 04",
    "text": "Resumen Clase 04\n\nCallbacks\n\n\nCódigo publisher y suscriber"
  },
  {
    "objectID": "clases/05/index.html#resumen-clase-04-1",
    "href": "clases/05/index.html#resumen-clase-04-1",
    "title": "Robótica",
    "section": "Resumen Clase 04",
    "text": "Resumen Clase 04\n\nUso de nombres\n\n\nPaquete\nArchivo\nEjecutable\nNodo"
  },
  {
    "objectID": "clases/05/index.html#rclpy-programación-orientada-a-objetos",
    "href": "clases/05/index.html#rclpy-programación-orientada-a-objetos",
    "title": "Robótica",
    "section": "rclpy: Programación Orientada a Objetos",
    "text": "rclpy: Programación Orientada a Objetos\n\nExisten 3 formas de escribir código de ROS:\n\n\nCódigo in-line (utilizado en la clase anterior)\nFunciones locales\nOrientado a Objetos   ⬅️"
  },
  {
    "objectID": "clases/05/index.html#código-publisher",
    "href": "clases/05/index.html#código-publisher",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\nimport rclpy\n\nfrom std_msgs.msg import String\n\ndef main(args=None):\n  # 1. Inicialización\n  rclpy.init(args=args)\n\n  # 2. Creación de nodo\n  nodo = rclpy.create_node('publicador')\n\n  # 2.1 Lógica del programa\n  ...\n\n  # 3. Procesamiento de mensajes y callback\n  rclpy.spin(nodo)\n\n  # 4. Finalización \n  rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\nOrientado a objetos\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\ndef main(args=None):\n  # 1. Inicialización\n  rclpy.init(args=args)\n\n  # 2. Creación de nodo\n  nodo = Publicador()\n\n  # 2.1 La lógica se encuentra en la clase\n\n\n  # 3. Procesamiento de mensajes y callback\n  rclpy.spin(nodo)\n\n  # 4. Finalización \n  rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-1",
    "href": "clases/05/index.html#código-publisher-1",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\nimport rclpy\n\nfrom std_msgs.msg import String\n\ndef main(args=None):\n  # 1. Inicialización\n  rclpy.init(args=args)\n\n  # 2. Creación de nodo\n  nodo = rclpy.create_node('publicador')\n\n  # 2.1 Lógica del programa\n  ...\n\n  # 3. Procesamiento de mensajes y callback\n  rclpy.spin(nodo)\n\n  # 4. Finalización \n  rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\nOrientado a objetos\n\nimport rclpy\nfrom rclpy.node import Node\nfrom std_msgs.msg import String\n\ndef main(args=None):\n  # 1. Inicialización\n  rclpy.init(args=args)\n\n  # 2. Creación de nodo\n  nodo = Publicador()\n\n  # 2.1 La lógica se encuentra en la clase\n  \n\n  # 3. Procesamiento de mensajes y callback\n  rclpy.spin(nodo)\n\n  # 4. Finalización \n  rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-2",
    "href": "clases/05/index.html#código-publisher-2",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-3",
    "href": "clases/05/index.html#código-publisher-3",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-4",
    "href": "clases/05/index.html#código-publisher-4",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-5",
    "href": "clases/05/index.html#código-publisher-5",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-6",
    "href": "clases/05/index.html#código-publisher-6",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-publisher-7",
    "href": "clases/05/index.html#código-publisher-7",
    "title": "Robótica",
    "section": "Código publisher",
    "text": "Código publisher\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  ...\n  # 2.1 Lógica del programa\n  # Creación de publisher\n  pub = nodo.create_publisher(String, 'chat', 10)\n\n  # 2.2 Programación de función de callback\n  def timer_callback():\n    # Creación de mensaje\n    msg = String()\n    # Completar el campo 'data' del mensaje \n    msg.data = 'Mensaje de prueba'\n\n    # Publicar el mensaje\n    pub.publish(msg)\n\n  # 2.3 Creación del timer\n  timer = nodo.create_timer(1, timer_callback)\n  ...\n\n\n\n\nOrientado a objetos\n\nclass Publicador(Node):\n  def __init__(self):\n    super().__init__('publicador')\n    \n    # 2.1 Creación de publisher\n    self.pub = self.create_publisher(\n                      String, 'chat', 10)\n\n    # 2.2 Creación de mensaje\n    self.msg = String()\n    \n    # 2.4 Creación del timer\n    self.timer = self.create_timer(\n                        1, self.timer_callback)\n  \n  # 2.3 Programación de función de callback\n  def timer_callback(self):\n    # Completar el campo 'data' del mensaje \n    self.msg.data = f'Mensaje de prueba'\n\n    # Publicar el mensaje\n    self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/05/index.html#código-suscriber",
    "href": "clases/05/index.html#código-suscriber",
    "title": "Robótica",
    "section": "Código suscriber",
    "text": "Código suscriber\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  # 2.1 Lógica del programa\n  # Programación de función de callback\n  def sub_callback(msg):\n    # Mostrar el mensaje en consola\n    nodo.get_logger()\n          .info(f'Recibí: \"{msg.data}\"')\n\n  # 2.2 Creación de suscriptor\n  sub = nodo.create_subscription(\n              String, 'chat', sub_callback, 10)\n  ...\n\n\nOrientado a objetos\n\nclass Suscriptor(Node):\n  def __init__(self):\n    super().__init__('suscriptor')\n    \n    # 2.2 Creación de suscriptor\n    self.sub = self.create_subscription(\n        String, 'chat', self.sub_callback, 10)\n      \n  # 2.1 Programación de función de callback\n  def sub_callback(self, msg):\n    # Mostrar el mensaje en consola\n    self.get_logger()\n          .info(f'Recibí: \"{msg.data}\"')"
  },
  {
    "objectID": "clases/05/index.html#código-suscriber-1",
    "href": "clases/05/index.html#código-suscriber-1",
    "title": "Robótica",
    "section": "Código suscriber",
    "text": "Código suscriber\n\n\n\nInline\n\ndef main(args=None):\n  ...\n  # 2.1 Lógica del programa\n  # Programación de función de callback\n  def sub_callback(msg):\n    # Mostrar el mensaje en consola\n    nodo.get_logger()\n          .info(f'Recibí: \"{msg.data}\"')\n\n  # 2.2 Creación de suscriptor\n  sub = nodo.create_subscription(\n              String, 'chat', sub_callback, 10)\n  ...\n\n\nOrientado a objetos\n\nclass Suscriptor(Node):\n  def __init__(self):\n    super().__init__('suscriptor')\n    \n    # 2.2 Creación de suscriptor\n    self.sub = self.create_subscription(\n        String, 'chat', self.sub_callback, 10)\n      \n  # 2.1 Programación de función de callback\n  def sub_callback(self, msg):\n    # Mostrar el mensaje en consola\n    self.get_logger()\n          .info(f'Recibí: \"{msg.data}\"')"
  },
  {
    "objectID": "clases/05/index.html#laboratorio",
    "href": "clases/05/index.html#laboratorio",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nModificación código de nodos publisher y suscriber"
  },
  {
    "objectID": "clases/06/index.html#resumen-clase-05",
    "href": "clases/06/index.html#resumen-clase-05",
    "title": "Robótica",
    "section": "Resumen Clase 05",
    "text": "Resumen Clase 05\n\nProgramación Orientada a Objetos\n\n\nCódigo publisher y suscriber"
  },
  {
    "objectID": "clases/06/index.html#rclpy-parámetros",
    "href": "clases/06/index.html#rclpy-parámetros",
    "title": "Robótica",
    "section": "rclpy: Parámetros",
    "text": "rclpy: Parámetros\n\nPermiten configurar nodos sin tener que reprogramarlos\n\n\n\nSe crean y destruyen con el nodo\n\n\n\n\nConsisten en\n\n\nUna key (identificador)\nUn valor\nUna descripción (opcional)\n\n\n\n\nRecapitulación: - Las primeras clases se trabajaron los conceptos de nodos, mensajes y topics; luego se trabajó con los comandos asociados a estas entidades y como interactuar u obtener información acerca de los mismos y por último aprendimos el uso de las librerías para la programación de nodos - También se trabajó con los concetos de servicios y parámetros, y posteriormente los comandos asociados y como utilizarlos - Ahora queda aprender como programar dichos parámetros dentro de los nodos"
  },
  {
    "objectID": "clases/06/index.html#rclpy-parámetros-1",
    "href": "clases/06/index.html#rclpy-parámetros-1",
    "title": "Robótica",
    "section": "rclpy: Parámetros",
    "text": "rclpy: Parámetros\n\nSe declaran todos al inicio, antes de hacer uso\n\n\n    self.declare_parameter('&lt;nombre&gt;', &lt;valor&gt;)\n\n    self.declare_parameter('&lt;nombre&gt;', &lt;valor&gt;, &lt;desc&gt;)\n\n\n\nEl tipo es inferido a través del valor"
  },
  {
    "objectID": "clases/06/index.html#rclpy-parámetros-2",
    "href": "clases/06/index.html#rclpy-parámetros-2",
    "title": "Robótica",
    "section": "rclpy: Parámetros",
    "text": "rclpy: Parámetros\n\nPara obtener el valor\n\n    param = self.get_parameter('&lt;nombre&gt;')\n\n    valor = param.value\n    \n\n\nEstablecer el valor (desde el nodo)\n\n    nuevo_valor = rclpy.parameter.Parameter(&lt;nombre&gt;, &lt;tipo&gt;, valor&gt;)\n    \n    self.set_parameters([ nuevo_valor ])"
  },
  {
    "objectID": "clases/06/index.html#rclpy-parámetros-3",
    "href": "clases/06/index.html#rclpy-parámetros-3",
    "title": "Robótica",
    "section": "rclpy: Parámetros",
    "text": "rclpy: Parámetros\n\nExiste un callback para cuando se modifica algún parámetro\n\n    # Dentro del constructor de la clase\n    self.handler = ParameterEventHandler(self)\n    \n    self.callback_handle = self.handler.add_parameter_callback(\n        parameter_name = \"&lt;nombre_parametro&gt;\",\n        node_name = \"&lt;nombre_nodo&gt;\",\n        callback = &lt;callback&gt;,\n    )\n    \n\n\nEl callback recibe el parámetro modificado\n\n    def callback(self, p: rclpy.parameter.Parameter) -&gt; None:\n        ..."
  },
  {
    "objectID": "clases/06/index.html#argumentos-en-ros2",
    "href": "clases/06/index.html#argumentos-en-ros2",
    "title": "Robótica",
    "section": "Argumentos en ROS2",
    "text": "Argumentos en ROS2\n\nPropiedades que ROS permite reconfigurar\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt; --ros-args ...\n\n\n\nRemapping: -r o --remap\n\n\n    $ ros2 run ... --ros-args -r __node:=&lt;nuevo_nombre_nodo&gt;\n\n\n    $ ros2 run ... --ros-args -r __ns:=/&lt;nombre_namespace&gt;\n\n\n    $ ros2 run ... --ros-args -r &lt;topic&gt;:=&lt;nuevo_nombre_topic&gt;\n\n\n\n\nNivel de log: --log-level\n  $ ros2 run ... --ros-args --log-level &lt;info|debug|warn|error&gt;"
  },
  {
    "objectID": "clases/06/index.html#argumentos-en-ros2-1",
    "href": "clases/06/index.html#argumentos-en-ros2-1",
    "title": "Robótica",
    "section": "Argumentos en ROS2",
    "text": "Argumentos en ROS2\n\nPara el caso de parámetros: -p\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n            --ros-args -p &lt;nombre_parametro&gt;:=&lt;valor&gt;\n\n\n\n\n\n\n\n\nCuando el nodo se encuentra en ejecución:\n\n$ ros2 param set ..."
  },
  {
    "objectID": "clases/06/index.html#ros2launch",
    "href": "clases/06/index.html#ros2launch",
    "title": "Robótica",
    "section": "ros2launch",
    "text": "ros2launch\n\nHerramienta que permite la ejecución de múltiples nodos con un simple comando: ros2 launch ...\n\n\n\nTareas más comunes:\n\n\nCrear nodos (y de forma sincronizada)\nCargar parámetros\nEjecutar comandos\nReutilizar archivos\n\n\nPor lo general, un sistema ROS 2 está compuesto de numerosos nodos que se ejecutan en diversos procesos (e incluso en distintas máquinas)\nSi bien es posible ejecutar manualmente cada uno de estos nodos, se vuelve engorroso rapidamente"
  },
  {
    "objectID": "clases/06/index.html#ros2launch-1",
    "href": "clases/06/index.html#ros2launch-1",
    "title": "Robótica",
    "section": "ros2launch",
    "text": "ros2launch\n\nPor convención se ubican en la carpeta launch dentro del paquete\n\n\n\nFormatos:\n\nXML: nombre_archivo.xml\nYAML: nombre_archivo.yaml\nPython: nombre_archivo.launch.py   ⬅️"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python",
    "href": "clases/06/index.html#archivos-launch-en-python",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nEs necesario adecuar el archivo setup.py:\n\nfrom setuptools import setup\n\nimport os\nfrom glob import glob\n\npackage_name = 'nombre_paquete'\n\nsetup(\n  # Otros parámetros ...\n  data_files=[\n    # ... Otros archivos\n    # Incluir todos los archivos de la carpeta launch\n    (os.path.join('share', package_name, 'launch'), glob('launch/*'))\n  ],\n  # El resto de la configuración ...\n)\n\n\n\n\n\n\n\nSe recomienda agregar ros2launch como dependencia de ejecución:\n\n   &lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-1",
    "href": "clases/06/index.html#archivos-launch-en-python-1",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nSe debe implementar la función\n          generate_launch_description()\nque devuelve\n          launch.LaunchDescription()\n\n\n\nEsta función será utilizada por el comando:\n  $ ros2 launch &lt;nombre_paquete&gt; &lt;nombre_archivo_launch&gt;"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-2",
    "href": "clases/06/index.html#archivos-launch-en-python-2",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nImportar las librerías launch y launch_ros\n\n# Librería independiente de ROS2\nfrom launch import LaunchDescription\n\n# Librería específica con clases de ROS2\nfrom launch_ros import actions"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-3",
    "href": "clases/06/index.html#archivos-launch-en-python-3",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nFormas de agregar acciones (ejemplo con nodo)\n\n\nDirectamente en el constructor\n\ndef generate_launch_description():\n  return LaunchDescription([\n    Node(\n      package = '&lt;nombre_paquete&gt;',\n      executable = '&lt;nombre_ejecutable&gt;',\n      name = '&lt;nombre_nodo&gt;',\n    ),\n  ])\n\nAñadiendo al objeto\n\ndef generate_launch_description():\n  node_1 = Node(\n    package = '&lt;nombre_paquete&gt;',\n    executable = '&lt;nombre_ejecutable&gt;',\n    name = '&lt;nombre_nodo&gt;',\n  )\n\n  ld = LaunchDescription()\n  ld.add_action(node_1)\n  return ld"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-4",
    "href": "clases/06/index.html#archivos-launch-en-python-4",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nActions: Ejecutar un nodo\n\nfrom launch_ros.actions import Node\n...\nreturn LaunchDescription([\n  Node(\n    package = '&lt;nombre_paquete&gt;',\n    executable = '&lt;nombre_ejecutable&gt;',\n    name = '&lt;nombre_nodo&gt;',\n    namespace = '&lt;nombre_namespace&gt;',\n    parameters = [ # Pueden ser archivos\n      {'&lt;nombre_parametro&gt;': &lt;valor&gt;, .. }\n    ],\n    remappings = [\n      ('&lt;nombre_topic&gt;', '&lt;nuevo_nombre&gt;'),\n    ],\n    output = '&lt;screen|log|both&gt;',\n    ros_arguments = [...],              # Listado de argumentos de ejecución (nivel de log, etc)\n    arguments = [...],                  # Listado de argumentos para el nodo\n  ),\n])"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-5",
    "href": "clases/06/index.html#archivos-launch-en-python-5",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nSubstitutions: Parámetros para cambiar valores en el launch\n\n...\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.substitutions import LaunchConfiguration\n \ndef generate_launch_description():\n  return LaunchDescription([\n    DeclareLaunchArgument(\n      '&lt;nombre_parametro&gt;', default_value=&lt;valor&gt;\n    ),\n    Node(\n      package = '&lt;nombre_paquete&gt;',\n      executable = '&lt;nombre_ejecutable&gt;',\n      name = '&lt;nombre_nodo&gt;',\n      parameters=[{\n        '&lt;parametro_del_nodo&gt;': LaunchConfiguration('&lt;nombre_parametro&gt;'),\n      }]\n    ),\n  ])"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-6",
    "href": "clases/06/index.html#archivos-launch-en-python-6",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nConditions: Mecanismos para cambiar el comportamiento del launch\n\n...\nfrom launch.actions import DeclareLaunchArgument\nfrom launch.conditions import IfCondition\nfrom launch.substitutions import LaunchConfiguration, EqualsSubstitution\n\ndef generate_launch_description():\n  return LaunchDescription([\n    DeclareLaunchArgument(\n      'ejecutar_nodo', default_value='true'\n    ),\n    Node(\n      package = '&lt;nombre_paquete&gt;',\n      executable = '&lt;nombre_ejecutable&gt;',\n      name = '&lt;nombre_nodo&gt;',\n      condition=IfCondition(\n        EqualsSubstitution(LaunchConfiguration('ejecutar_nodo'), 'true')\n      ),\n    ),\n  ])"
  },
  {
    "objectID": "clases/06/index.html#archivos-launch-en-python-7",
    "href": "clases/06/index.html#archivos-launch-en-python-7",
    "title": "Robótica",
    "section": "Archivos launch en python",
    "text": "Archivos launch en python\n\nReutilización: Incluir otros launch\n\n...\nfrom launch.actions import IncludeLaunchDescription\nfrom launch.launch_description_sources import PythonLaunchDescriptionSource\nfrom launch_ros.substitutions import FindPackageShare\n\ndef generate_launch_description():\n  return LaunchDescription([\n    IncludeLaunchDescription(\n      PythonLaunchDescriptionSource([\n        FindPackageShare('&lt;nombre_paquete&gt;'), '/launch', '/&lt;nombre_archivo_launch&gt;'\n      ])\n    )\n    ...\n  ])"
  },
  {
    "objectID": "clases/06/index.html#sistema-de-logging",
    "href": "clases/06/index.html#sistema-de-logging",
    "title": "Robótica",
    "section": "Sistema de logging",
    "text": "Sistema de logging\n\n\nPor defecto los mensajes de log se escriben en:\n\nLa consola\nEl archivo de log en el disco\nEl topic \\rosout\n\n\n\n\n\nPueden activarse y desactivarse individualmente"
  },
  {
    "objectID": "clases/06/index.html#mensajes-de-log",
    "href": "clases/06/index.html#mensajes-de-log",
    "title": "Robótica",
    "section": "Mensajes de log",
    "text": "Mensajes de log\n\nEscala de gravedad (severity level)\n\n\nEn orden descendente:\n\nFATAL\nERROR\nWARN\nINFO\nDEBUG\n\n\n\nCada nodo está asociado a un nivel de severidad por lo que se pueden filtrar mensajes con severidad inferior"
  },
  {
    "objectID": "clases/06/index.html#mensajes-de-log-en-rclpy",
    "href": "clases/06/index.html#mensajes-de-log-en-rclpy",
    "title": "Robótica",
    "section": "Mensajes de log en rclpy",
    "text": "Mensajes de log en rclpy\n\nObtener el logger de una clase nodo:\n  &lt;nodo&gt;.get_logger().{debug,info,warning,error,fatal}('&lt;mensaje_de_log&gt;')\n\n\n\n\n\nOpciones para configurar el comportamiento:\n\nonce: Loggear solo la primera vez\nskip_first: No loggear la primera vez, si las siguientes\nthrottle_duration_sec: Cantidad de veces que se puede enviar el mensaje por segundo"
  },
  {
    "objectID": "clases/06/index.html#laboratorio-1",
    "href": "clases/06/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nUso de parámetros y archivos launch"
  },
  {
    "objectID": "clases/09/tres.html",
    "href": "clases/09/tres.html",
    "title": "Clase 09 - Taller de resolución",
    "section": "",
    "text": "Actualizar repositorios apt y asegurar que los paquetes se encuentren actualizados\n    $ sudo apt update && sudo apt upgrade -y\n\n\n\nInstalar la versión de Gazebo por defecto para ROS Jazzy\n    $ sudo apt install ros-jazzy-ros-gz\nTraducido de gazebosim.org\n\n\n\n\n\n\n\nNote\n\n\n\nRecuerda actualizar las dependencias. Gazebo: ros_gz y ROS2 control: gz_ros2_control\n\n\n\n\n\n\n\n\n    $ ros2 launch ros_gz_sim gz_sim.launch.py gz_args:=empty.sdf\n\n\n\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution([\n                FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py'\n            ]),\n        ),\n        launch_arguments={\n            'gz_args': '-r empty.sdf',\n            'on_exit_shutdown': 'True'\n        }.items(),\n    ),\n\n\n\n\n\n\n&lt;xacro:inertial_box mass=\"[masa_kg]\" x=\"[largo]\" y=\"[ancho]\" z=\"[alto]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_box&gt;\n\n\n\n&lt;xacro:inertial_cylinder mass=\"[masa_kg]\" radius=\"[radio]\" length=\"[ancho]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_cylinder&gt;\n\n\n\n&lt;xacro:inertial_sphere mass=\"[masa_kg]\" radius=\"[radio]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_sphere&gt;\n\n\n\n&lt;dummy_inertial /&gt;\n\n\n\n\n\n\n\n\n\n\nWarning\n\n\n\nRecuerda que el URDF debe estar disponible en el topic \\robot_description y cumplir con todos los requerimientos de Gazebo:\n\nGeometrías de colisión e inercias definidas\nTodos los links y joints nombrados\nColores y materiales (opcional)\n\n\n\n\n\n    $ ros2 run ros_gz_sim create -topic robot_description\n        -entity &lt;nombre_robot&gt;\n\n\n\n    Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        arguments=[\n            \"-entity\", \"&lt;nombre_robot&gt;\",\n            \"-topic\", \"robot_description\",\n        ],\n        output=\"screen\",\n    ),"
  },
  {
    "objectID": "clases/09/tres.html#universidad-nacional-del-litoral-unl",
    "href": "clases/09/tres.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 09 - Taller de resolución",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/09/tres.html#instalación-de-gazebo",
    "href": "clases/09/tres.html#instalación-de-gazebo",
    "title": "Clase 09 - Taller de resolución",
    "section": "",
    "text": "Actualizar repositorios apt y asegurar que los paquetes se encuentren actualizados\n    $ sudo apt update && sudo apt upgrade -y\n\n\n\nInstalar la versión de Gazebo por defecto para ROS Jazzy\n    $ sudo apt install ros-jazzy-ros-gz\nTraducido de gazebosim.org\n\n\n\n\n\n\n\nNote\n\n\n\nRecuerda actualizar las dependencias. Gazebo: ros_gz y ROS2 control: gz_ros2_control"
  },
  {
    "objectID": "clases/09/tres.html#ejecutar-gazebo",
    "href": "clases/09/tres.html#ejecutar-gazebo",
    "title": "Clase 09 - Taller de resolución",
    "section": "",
    "text": "$ ros2 launch ros_gz_sim gz_sim.launch.py gz_args:=empty.sdf\n\n\n\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution([\n                FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py'\n            ]),\n        ),\n        launch_arguments={\n            'gz_args': '-r empty.sdf',\n            'on_exit_shutdown': 'True'\n        }.items(),\n    ),"
  },
  {
    "objectID": "clases/09/tres.html#macros-de-inercia-inertial_macros.xacro",
    "href": "clases/09/tres.html#macros-de-inercia-inertial_macros.xacro",
    "title": "Clase 09 - Taller de resolución",
    "section": "",
    "text": "&lt;xacro:inertial_box mass=\"[masa_kg]\" x=\"[largo]\" y=\"[ancho]\" z=\"[alto]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_box&gt;\n\n\n\n&lt;xacro:inertial_cylinder mass=\"[masa_kg]\" radius=\"[radio]\" length=\"[ancho]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_cylinder&gt;\n\n\n\n&lt;xacro:inertial_sphere mass=\"[masa_kg]\" radius=\"[radio]\"&gt;\n    &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n&lt;/xacro:inertial_sphere&gt;\n\n\n\n&lt;dummy_inertial /&gt;"
  },
  {
    "objectID": "clases/09/tres.html#cargar-robot-en-gazebo",
    "href": "clases/09/tres.html#cargar-robot-en-gazebo",
    "title": "Clase 09 - Taller de resolución",
    "section": "",
    "text": "Warning\n\n\n\nRecuerda que el URDF debe estar disponible en el topic \\robot_description y cumplir con todos los requerimientos de Gazebo:\n\nGeometrías de colisión e inercias definidas\nTodos los links y joints nombrados\nColores y materiales (opcional)\n\n\n\n\n\n    $ ros2 run ros_gz_sim create -topic robot_description\n        -entity &lt;nombre_robot&gt;\n\n\n\n    Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        arguments=[\n            \"-entity\", \"&lt;nombre_robot&gt;\",\n            \"-topic\", \"robot_description\",\n        ],\n        output=\"screen\",\n    ),"
  },
  {
    "objectID": "clases/09/tres.html#definición-de-hardware-simulado-y-las-interfaces",
    "href": "clases/09/tres.html#definición-de-hardware-simulado-y-las-interfaces",
    "title": "Clase 09 - Taller de resolución",
    "section": "Definición de hardware simulado y las interfaces",
    "text": "Definición de hardware simulado y las interfaces\n\nDefinir un hardware simulado con &lt;hardware&gt;\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    &lt;hardware&gt;\n        &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n    &lt;/hardware&gt;\n    ...\n&lt;/ros2_control&gt;\n\n\nPara cada junta &lt;joint&gt; definir las interfaces\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    &lt;hardware&gt;\n        &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n    &lt;/hardware&gt;\n    &lt;joint name=\"[nombre_junta]\"&gt;\n        &lt;!-- Interfaces --&gt;\n    &lt;/joint&gt;\n&lt;/ros2_control&gt;\n\nInterfaces de estado con &lt;state_interface .. /&gt;\n\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    ...\n    &lt;joint name=\"[nombre_junta]\"&gt;\n        &lt;!-- Interfaz de estado de posición --&gt;\n        &lt;state_interface name=\"position\" /&gt;\n        &lt;!-- Interfaz de estado de velocidad --&gt;\n        &lt;state_interface name=\"velocity\" /&gt;\n        &lt;!-- Interfaz de estado de esfuerzo --&gt;\n        &lt;state_interface name=\"effort\" /&gt;\n    &lt;/joint&gt;\n    ...\n&lt;/ros2_control&gt;\n\nInterfaces de comando &lt;command_interface .. /&gt;\n\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    ...\n    &lt;joint name=\"[nombre_junta]\"&gt;\n        &lt;!-- Interfaz de estado de posición --&gt;\n        &lt;command_interface name=\"position\" /&gt;\n        &lt;!-- Interfaz de estado de velocidad --&gt;\n        &lt;command_interface name=\"velocity\" /&gt;\n        &lt;!-- Interfaz de estado de esfuerzo --&gt;\n        &lt;command_interface name=\"effort\" /&gt;\n    &lt;/joint&gt;\n    ...\n&lt;/ros2_control&gt;\n\n\n\n\n\n\nNote\n\n\n\nAdicionalmente las interfaces pueden recibir parámetros:\n    &lt;param name=\"initial_value\"&gt;{valor inicial}&lt;/param&gt;\n    &lt;param name=\"min\"&gt;{limite_minimo}&lt;/param&gt;\n    &lt;param name=\"max\"&gt;{limite_maximo}&lt;/param&gt;"
  },
  {
    "objectID": "clases/09/tres.html#definir-controladores-para-ros2_control",
    "href": "clases/09/tres.html#definir-controladores-para-ros2_control",
    "title": "Clase 09 - Taller de resolución",
    "section": "Definir controladores para ros2_control",
    "text": "Definir controladores para ros2_control\n\nTipos de controladores:\n\nPublicar estado de las juntas: joint_state_broadcaster/JointStateBroadcaster\nControladr la velocidad de la junta: velocity_controllers/JointGroupVelocityController\n\nMediante un archivo de configuración YAML\n\ncontroller_manager:\n  ros__parameters:\n    update_rate: 30\n    use_sim_time: true\n\n    {nombre_controlador}:\n        type: {tipo_controlador}\n    ...\n\nConfiguraciones velocity_controllers/JointGroupVelocityController\n{nombre_controlador}:\n  ros__parameters:\n    joints:\n        - {nombre_junta}\n\n    command_interfaces:\n        # Según corresponda (las 3 o alguna)\n        - {velocity}\n        - {position}\n        - {effort}\n\n    state_interfaces:\n        # Según corresponda (las 3 o alguna)\n        - {velocity}\n        - {position}\n        - {effort}"
  },
  {
    "objectID": "clases/09/tres.html#cargar-el-plugin-de-gz_ros2_control",
    "href": "clases/09/tres.html#cargar-el-plugin-de-gz_ros2_control",
    "title": "Clase 09 - Taller de resolución",
    "section": "Cargar el plugin de gz_ros2_control",
    "text": "Cargar el plugin de gz_ros2_control\n\nCargar el plugin con un archivo de configuración adicional\n\n&lt;gazebo&gt;\n    &lt;plugin filename=\"gz_ros2_control-system\"\n            name=\"gz_ros2_control::GazeboSimROS2ControlPlugin\"&gt;\n        &lt;parameters&gt;\n            $(find [nombre_paquete])/config/[nombre_archivo].yaml\n        &lt;/parameters&gt;\n    &lt;/plugin&gt;\n&lt;/gazebo&gt;"
  },
  {
    "objectID": "clases/09/tres.html#cargar-controladores",
    "href": "clases/09/tres.html#cargar-controladores",
    "title": "Clase 09 - Taller de resolución",
    "section": "Cargar controladores",
    "text": "Cargar controladores\n\nDesde la linea de comando\n    $ ros2 control load_controller --set-state active\n        &lt;nombre_controlador&gt; &lt;archivo_parametros&gt;\n\n\nDesde archivo launch\n    ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller',\n             '--set-state', 'active',\n             '&lt;nombre_controlador&gt;'],\n        output='screen'\n    )"
  },
  {
    "objectID": "clases/01/index.html#organización-de-la-materia",
    "href": "clases/01/index.html#organización-de-la-materia",
    "title": "Robótica",
    "section": "Organización de la materia",
    "text": "Organización de la materia\n\nDocente: Tec. Agustín Capovilla\nCursado: Lunes de 17:00 a 19:30 (T/P) 1\nComunicación: via email acapovilla@sinc.unl.edu.ar\nRepositorio: acapovilla.github.io/robotica-2025\n\nclases de consulta a coordinar"
  },
  {
    "objectID": "clases/01/index.html#evaluaciones",
    "href": "clases/01/index.html#evaluaciones",
    "title": "Robótica",
    "section": "Evaluaciones",
    "text": "Evaluaciones\n\n3 trabajos prácticos integradores\n\n\n\n\n\n\n\n\nCon sus respectivas instancias de recuperación"
  },
  {
    "objectID": "clases/01/index.html#evaluaciones-1",
    "href": "clases/01/index.html#evaluaciones-1",
    "title": "Robótica",
    "section": "Evaluaciones",
    "text": "Evaluaciones\n\n3 trabajos prácticos integradores\n\nCodiciones de aprobación\n\nPara regularizar\n\nAprobación de al menos 2\n\nPara promocionar\n\nAprobación de todos los trabajos con mínimo de 60% + promedio mínimo de 70%"
  },
  {
    "objectID": "clases/01/index.html#programa",
    "href": "clases/01/index.html#programa",
    "title": "Robótica",
    "section": "Programa",
    "text": "Programa\n\n4 bloques principales"
  },
  {
    "objectID": "clases/01/index.html#programa-1",
    "href": "clases/01/index.html#programa-1",
    "title": "Robótica",
    "section": "Programa",
    "text": "Programa\n\n4 bloques principales\n\nBloque 0\n\nRobot Operating System (ROS 2)"
  },
  {
    "objectID": "clases/01/index.html#programa-2",
    "href": "clases/01/index.html#programa-2",
    "title": "Robótica",
    "section": "Programa",
    "text": "Programa\n\n4 bloques principales\n\nBloque 1\n\nCinemática\nSimulación y control"
  },
  {
    "objectID": "clases/01/index.html#programa-3",
    "href": "clases/01/index.html#programa-3",
    "title": "Robótica",
    "section": "Programa",
    "text": "Programa\n\n4 bloques principales\n\nBloque 2\n\nPercepción\nLocalización y mapeo"
  },
  {
    "objectID": "clases/01/index.html#programa-4",
    "href": "clases/01/index.html#programa-4",
    "title": "Robótica",
    "section": "Programa",
    "text": "Programa\n\n4 bloques principales\n\nBloque 3\n\nPlaneamiento\nNavegación"
  },
  {
    "objectID": "clases/01/index.html#herramientas-de-trabajo",
    "href": "clases/01/index.html#herramientas-de-trabajo",
    "title": "Robótica",
    "section": "Herramientas de trabajo",
    "text": "Herramientas de trabajo\n\nFramework de robótica: ROS2\nSimulador: Gazebo\nLenguaje de programación: C++ / Python\nIDE: VSCode (potencial en sus extensiones)\nAdicionales:\n\nContenedores: Docker\nControl de versiones: Git (+ GitHub o GitLab)\nEscritura: Latex, Markdown\nDiagramas: Draw.io"
  },
  {
    "objectID": "clases/01/index.html#bibliografía-recursos-oficiales",
    "href": "clases/01/index.html#bibliografía-recursos-oficiales",
    "title": "Robótica",
    "section": "Bibliografía Recursos Oficiales",
    "text": "Bibliografía Recursos Oficiales\n\nROS 2 Documentation, Tutorials\nGazebo\nrospy, ros_control, Nav2\nentre otros…\n\nMaterial adicional recomendado\n\nArticulated Robotics\nThe Construct\nETH Zürich - Programming for Robotic\nAutomatic Addison\n\nBibliografía (muy) complementaria\n\nSpringer Handbook of Robotics\nRobotic Systems (draft), Kris Hauser"
  },
  {
    "objectID": "clases/13/lab.html",
    "href": "clases/13/lab.html",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"imu\"&gt;\n        &lt;plugin\n            filename=\"gz-sim-imu-system\" \n            name=\"gz::sim::systems::Imu\"&gt;\n        &lt;/plugin&gt;\n\n        &lt;!-- Atributos --&gt;\n        &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n\n\n\nRecuerda modificar el URDF para añadir el link y la joint correspondiente\n\n   &lt;link name=\"{nombre_link}\"&gt;\n       &lt;xacro:dummy_inertial /&gt;\n   &lt;/link&gt;\n\n   &lt;joint name=\"{nombre_joint}\" type=\"fixed\"&gt;\n       &lt;parent link=\"base_link\" /&gt;\n       &lt;child link=\"{nombre_link}\" /&gt;\n       &lt;origin xyz=\"{x} {y} {z}\" rpy=\"{r} {p} {y}\" /&gt;\n   &lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\nPuedes crear un archivo aparte para separar los sensores del resto de la descripción, por ej. sensors.xacro\n\n\n\n\n\n\n&lt;noise type=\"gaussian\"&gt;\n    &lt;!-- Media --&gt;\n    &lt;mean&gt;{media}&lt;/mean&gt;\n    &lt;!-- Desviación estándar --&gt;      \n    &lt;stddev&gt;{desviacion_estandar}&lt;/stddev&gt;\n&lt;/noise&gt;\n\n\n\n\nAcelerómetro:\n\nFrecuencia de actualización: 100 [Hz]\nRuido estándar: 0.0016 [m/s2] (X-Y), 0.0019 [m/s2] (Z)\nBias: 0.020 [m/s2]\n\n\n\nGiroscopo:\n\nFrecuencia de actualización: 100 [Hz]\nRuido estándar: 0.00174533 [rad/s]\nBias: 0.0174533 [rad/s]\n\n\n&lt;sensor name=\"imu\" type=\"imu\"&gt;\n    &lt;plugin\n        filename=\"gz-sim-imu-system\" \n        name=\"gz::sim::systems::Imu\"&gt;\n    &lt;/plugin&gt;\n\n    &lt;always_on&gt;1&lt;/always_on&gt;\n    &lt;update_rate&gt;100&lt;/update_rate&gt;\n    &lt;topic&gt;/imu/data&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;imu&gt;\n        &lt;linear_acceleration&gt;\n            &lt;x&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.020&lt;/mean&gt;\n                &lt;stddev&gt;0.0016&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/x&gt;\n            &lt;!-- 'y' repite los parámetros de 'x' --&gt;\n            &lt;z&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.020&lt;/mean&gt;\n                &lt;stddev&gt;0.0019&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/z&gt;\n        &lt;/linear_acceleration&gt;\n        &lt;angular_velocity&gt;\n            &lt;x&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.0174533&lt;/mean&gt;\n                &lt;stddev&gt;0.00174533&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/x&gt;\n            &lt;!-- 'y' y 'z' repiten los parámetros de 'x'  --&gt;\n        &lt;/angular_velocity&gt;\n    &lt;/imu&gt;\n&lt;/sensor&gt;\n\n\n\n\n\n\n&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"gpu_lidar\"&gt;\n        &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n\n        &lt;lidar&gt;\n        &lt;scan&gt;\n        &lt;horizontal&gt;\n            &lt;samples&gt;{cantidad_rayos}&lt;/samples&gt;\n            &lt;resolution&gt;1&lt;/resolution&gt;\n            &lt;min_angle&gt;{min}&lt;/min_angle&gt;\n            &lt;max_angle&gt;{max}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;vertical&gt;\n            &lt;!-- Mismos parámetros que 'horizontal' --&gt;\n        &lt;/vertical&gt;\n        &lt;/scan&gt;\n        &lt;range&gt;\n            &lt;min&gt;{rango_min}&lt;/min&gt;\n            &lt;max&gt;{rango_max}&lt;/max&gt;\n            &lt;resolution&gt;{res_lineal}&lt;/resolution&gt;\n        &lt;/range&gt;\n        &lt;/lidar&gt;\n    &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n&lt;noise&gt;\n    &lt;type&gt;gaussian&lt;/type&gt;\n    &lt;!-- Media --&gt;\n    &lt;mean&gt;{media}&lt;/mean&gt;\n    &lt;!-- Desviación estándar --&gt;      \n    &lt;stddev&gt;{desviacion_estandar}&lt;/stddev&gt;\n&lt;/noise&gt;\n\n\n\n\n\nRango de distancia: 0.05 - 15.0 [m]\nFrecuencia de escaneo: 10 [Hz]\nResolución angular: 0.1125°\nPresición: ± 30 [mm]\nResolución: 10 [mm]\n\n\n&lt;sensor name=\"lidar\" type=\"gpu_lidar\"&gt;\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;10&lt;/update_rate&gt;\n    &lt;topic&gt;/scan&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;lidar&gt;\n        &lt;scan&gt;\n        &lt;horizontal&gt;\n            &lt;samples&gt;3200&lt;/samples&gt;\n            &lt;resolution&gt;1&lt;/resolution&gt;\n            &lt;min_angle&gt;${-pi}&lt;/min_angle&gt;\n            &lt;max_angle&gt;${pi}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;!-- Al ser 2D no tiene parámetros verticales --&gt;\n        &lt;/scan&gt;\n        &lt;range&gt;\n            &lt;min&gt;0.05&lt;/min&gt;\n            &lt;max&gt;15&lt;/max&gt;\n            &lt;resolution&gt;0.010&lt;/resolution&gt;\n        &lt;/range&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;0.0&lt;/mean&gt;\n            &lt;stddev&gt;0.030&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/lidar&gt;\n&lt;/sensor&gt;\n\n\n\n\n\n\n\n\n\nRecuerda crear la carpeta config, el archivo .yaml correspondiente y configurar correctamente el archivo setup.py\n\n\n\n\n\ngz_bridge.yaml\n\n- topic_name: \"&lt;nombre_topic&gt;\"\n  ros_type_name: \"&lt;tipo_topic_ROS&gt;\"\n  gz_type_name: \"&lt;tipo_topic_Gazebo&gt;\"\n  direction: &lt;direccion&gt; # GZ_TO_ROS | ROS_TO_GZ | BIDIRECTIONAL\n  lazy: true\n\n- # Siguiente ..\n\n\n\n\n- topic_name: \"/cmd_vel\"\n  ros_type_name: \"geometry_msgs/msg/Twist\"\n  gz_type_name: \"gz.msgs.Twist\"\n  direction: GZ_TO_ROS\n  lazy: true\n\n\n\n\n\n\n# ...\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution(\n                [FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py']\n            ),\n        ),\n        launch_arguments={\n            'gz_args': [\n                TextSubstitution(text=\"-r\"),\n                PathJoinSubstitution([\n                    FindPackageShare(\"&lt;nombre_paquete&gt;\"),\n                    'worlds',\n                    '&lt;nombre_archivo&gt;.world',\n                ]),\n            ]\n        }.items()\n    )\n# ...\n\n\n\n\n\n\nAgregar al inicio el import correspondiente\nfrom launch.substitutions import PathJoinSubstitution, TextSubstitution\n\n\n\n\n\n\n# ...\n    Node(\n        package=\"ros_gz_bridge\",\n        executable=\"parameter_bridge\",\n        parameters=[{\n            \"config_file\": PathJoinSubstitution(\n                [FindPackageShare(\"&lt;nombre_paquete&gt;\"), \"config\", \"gz_bridge.yaml\"]\n            ),\n        }],\n    )\n# ...\n\n\n\n\n\n\n\n\n\n\n\n\n\nPuede mostrar la distancia mínima para cada zona o si supera cierto umbral enviar un mensaje indicando que zona/s"
  },
  {
    "objectID": "clases/13/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/13/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 13 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/13/lab.html#sensor-de-tipo-imu",
    "href": "clases/13/lab.html#sensor-de-tipo-imu",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"imu\"&gt;\n        &lt;plugin\n            filename=\"gz-sim-imu-system\" \n            name=\"gz::sim::systems::Imu\"&gt;\n        &lt;/plugin&gt;\n\n        &lt;!-- Atributos --&gt;\n        &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n\n\n\nRecuerda modificar el URDF para añadir el link y la joint correspondiente\n\n   &lt;link name=\"{nombre_link}\"&gt;\n       &lt;xacro:dummy_inertial /&gt;\n   &lt;/link&gt;\n\n   &lt;joint name=\"{nombre_joint}\" type=\"fixed\"&gt;\n       &lt;parent link=\"base_link\" /&gt;\n       &lt;child link=\"{nombre_link}\" /&gt;\n       &lt;origin xyz=\"{x} {y} {z}\" rpy=\"{r} {p} {y}\" /&gt;\n   &lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\nPuedes crear un archivo aparte para separar los sensores del resto de la descripción, por ej. sensors.xacro\n\n\n\n\n\n\n&lt;noise type=\"gaussian\"&gt;\n    &lt;!-- Media --&gt;\n    &lt;mean&gt;{media}&lt;/mean&gt;\n    &lt;!-- Desviación estándar --&gt;      \n    &lt;stddev&gt;{desviacion_estandar}&lt;/stddev&gt;\n&lt;/noise&gt;\n\n\n\n\nAcelerómetro:\n\nFrecuencia de actualización: 100 [Hz]\nRuido estándar: 0.0016 [m/s2] (X-Y), 0.0019 [m/s2] (Z)\nBias: 0.020 [m/s2]\n\n\n\nGiroscopo:\n\nFrecuencia de actualización: 100 [Hz]\nRuido estándar: 0.00174533 [rad/s]\nBias: 0.0174533 [rad/s]\n\n\n&lt;sensor name=\"imu\" type=\"imu\"&gt;\n    &lt;plugin\n        filename=\"gz-sim-imu-system\" \n        name=\"gz::sim::systems::Imu\"&gt;\n    &lt;/plugin&gt;\n\n    &lt;always_on&gt;1&lt;/always_on&gt;\n    &lt;update_rate&gt;100&lt;/update_rate&gt;\n    &lt;topic&gt;/imu/data&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;imu&gt;\n        &lt;linear_acceleration&gt;\n            &lt;x&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.020&lt;/mean&gt;\n                &lt;stddev&gt;0.0016&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/x&gt;\n            &lt;!-- 'y' repite los parámetros de 'x' --&gt;\n            &lt;z&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.020&lt;/mean&gt;\n                &lt;stddev&gt;0.0019&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/z&gt;\n        &lt;/linear_acceleration&gt;\n        &lt;angular_velocity&gt;\n            &lt;x&gt;\n            &lt;noise type=\"gaussian\"&gt;\n                &lt;mean&gt;0.0174533&lt;/mean&gt;\n                &lt;stddev&gt;0.00174533&lt;/stddev&gt;\n            &lt;/noise&gt;\n            &lt;/x&gt;\n            &lt;!-- 'y' y 'z' repiten los parámetros de 'x'  --&gt;\n        &lt;/angular_velocity&gt;\n    &lt;/imu&gt;\n&lt;/sensor&gt;"
  },
  {
    "objectID": "clases/13/lab.html#sensor-de-tipo-lidar",
    "href": "clases/13/lab.html#sensor-de-tipo-lidar",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"gpu_lidar\"&gt;\n        &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n\n        &lt;lidar&gt;\n        &lt;scan&gt;\n        &lt;horizontal&gt;\n            &lt;samples&gt;{cantidad_rayos}&lt;/samples&gt;\n            &lt;resolution&gt;1&lt;/resolution&gt;\n            &lt;min_angle&gt;{min}&lt;/min_angle&gt;\n            &lt;max_angle&gt;{max}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;vertical&gt;\n            &lt;!-- Mismos parámetros que 'horizontal' --&gt;\n        &lt;/vertical&gt;\n        &lt;/scan&gt;\n        &lt;range&gt;\n            &lt;min&gt;{rango_min}&lt;/min&gt;\n            &lt;max&gt;{rango_max}&lt;/max&gt;\n            &lt;resolution&gt;{res_lineal}&lt;/resolution&gt;\n        &lt;/range&gt;\n        &lt;/lidar&gt;\n    &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n&lt;noise&gt;\n    &lt;type&gt;gaussian&lt;/type&gt;\n    &lt;!-- Media --&gt;\n    &lt;mean&gt;{media}&lt;/mean&gt;\n    &lt;!-- Desviación estándar --&gt;      \n    &lt;stddev&gt;{desviacion_estandar}&lt;/stddev&gt;\n&lt;/noise&gt;\n\n\n\n\n\nRango de distancia: 0.05 - 15.0 [m]\nFrecuencia de escaneo: 10 [Hz]\nResolución angular: 0.1125°\nPresición: ± 30 [mm]\nResolución: 10 [mm]\n\n\n&lt;sensor name=\"lidar\" type=\"gpu_lidar\"&gt;\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;10&lt;/update_rate&gt;\n    &lt;topic&gt;/scan&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;lidar&gt;\n        &lt;scan&gt;\n        &lt;horizontal&gt;\n            &lt;samples&gt;3200&lt;/samples&gt;\n            &lt;resolution&gt;1&lt;/resolution&gt;\n            &lt;min_angle&gt;${-pi}&lt;/min_angle&gt;\n            &lt;max_angle&gt;${pi}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;!-- Al ser 2D no tiene parámetros verticales --&gt;\n        &lt;/scan&gt;\n        &lt;range&gt;\n            &lt;min&gt;0.05&lt;/min&gt;\n            &lt;max&gt;15&lt;/max&gt;\n            &lt;resolution&gt;0.010&lt;/resolution&gt;\n        &lt;/range&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;0.0&lt;/mean&gt;\n            &lt;stddev&gt;0.030&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/lidar&gt;\n&lt;/sensor&gt;"
  },
  {
    "objectID": "clases/13/lab.html#configuración-del-ros_gz_bridge",
    "href": "clases/13/lab.html#configuración-del-ros_gz_bridge",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "Recuerda crear la carpeta config, el archivo .yaml correspondiente y configurar correctamente el archivo setup.py\n\n\n\n\n\ngz_bridge.yaml\n\n- topic_name: \"&lt;nombre_topic&gt;\"\n  ros_type_name: \"&lt;tipo_topic_ROS&gt;\"\n  gz_type_name: \"&lt;tipo_topic_Gazebo&gt;\"\n  direction: &lt;direccion&gt; # GZ_TO_ROS | ROS_TO_GZ | BIDIRECTIONAL\n  lazy: true\n\n- # Siguiente ..\n\n\n\n\n- topic_name: \"/cmd_vel\"\n  ros_type_name: \"geometry_msgs/msg/Twist\"\n  gz_type_name: \"gz.msgs.Twist\"\n  direction: GZ_TO_ROS\n  lazy: true"
  },
  {
    "objectID": "clases/13/lab.html#modificación-del-.launch.py",
    "href": "clases/13/lab.html#modificación-del-.launch.py",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "# ...\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution(\n                [FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py']\n            ),\n        ),\n        launch_arguments={\n            'gz_args': [\n                TextSubstitution(text=\"-r\"),\n                PathJoinSubstitution([\n                    FindPackageShare(\"&lt;nombre_paquete&gt;\"),\n                    'worlds',\n                    '&lt;nombre_archivo&gt;.world',\n                ]),\n            ]\n        }.items()\n    )\n# ...\n\n\n\n\n\n\nAgregar al inicio el import correspondiente\nfrom launch.substitutions import PathJoinSubstitution, TextSubstitution\n\n\n\n\n\n\n# ...\n    Node(\n        package=\"ros_gz_bridge\",\n        executable=\"parameter_bridge\",\n        parameters=[{\n            \"config_file\": PathJoinSubstitution(\n                [FindPackageShare(\"&lt;nombre_paquete&gt;\"), \"config\", \"gz_bridge.yaml\"]\n            ),\n        }],\n    )\n# ..."
  },
  {
    "objectID": "clases/13/lab.html#detector-de-obstáculos-con-lidar",
    "href": "clases/13/lab.html#detector-de-obstáculos-con-lidar",
    "title": "Clase 13 - Laboratorio",
    "section": "",
    "text": "Puede mostrar la distancia mínima para cada zona o si supera cierto umbral enviar un mensaje indicando que zona/s"
  },
  {
    "objectID": "clases/07/lab.html",
    "href": "clases/07/lab.html",
    "title": "Clase 07 - Laboratorio",
    "section": "",
    "text": "Sea un punto \\({\\boldsymbol{p}} = {\\begin{pmatrix} a & b \\end{pmatrix}}\\) y su correspondiente homogéneo \\({\\boldsymbol{\\tilde{p}}} = {\\begin{pmatrix} a & b & 1 \\end{pmatrix}}\\), podemos representar una traslación y rotación 2D mediante una transformación homogénea:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}\\boldsymbol{\\tilde{p}}} = \\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}} \\textcolor{Orange}{{}^\\boldsymbol{B}\\boldsymbol{\\tilde{p}}} = \\begin{pmatrix} \\textcolor{Maroon}{{}^\\boldsymbol{A}\\boldsymbol{R}_\\boldsymbol{B}} & \\textcolor{ForestGreen}{{}^\\boldsymbol{A}\\boldsymbol{t}_\\boldsymbol{B}} \\\\ \\boldsymbol{0} & 1 \\end{pmatrix} {}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}\n\\]\n\\[\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\\\ 1  \\end{bmatrix} =\n{\\begin{bmatrix} \\cos{\\textcolor{Maroon}{\\theta}} & -\\sin{\\textcolor{Maroon}{\\theta}} & \\textcolor{ForestGreen}{{t_x}} \\\\ \\sin{\\textcolor{Maroon}{\\theta}} & \\cos{\\textcolor{Maroon}{\\theta}} & \\textcolor{ForestGreen}{{t_y}} \\\\ 0 & 0 & 1 \\end{bmatrix}}\n\\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1 \\end{bmatrix}\n\\]\n\n\n\n\n\n\n\n\n\nUn robot \\(\\textbf{A}\\) se encuentra en la posición \\((2,1)\\) con orientación \\(30^\\circ\\) en coordenadas del \\(\\textit{Mundo}\\)\nUn robot \\(\\textbf{B}\\) se encuentra en la posición \\((0.5,\\tfrac{\\sqrt{3}}{2})\\) con orientación \\(60^\\circ\\) en el sistema de coordenadas del robot \\(\\textbf{A}\\)\nUn obstáculo \\({}^W \\boldsymbol{O}_1 = (0, 3)\\) en coordenadas del \\(\\textit{Mundo}\\)\nUn obstáculo \\({}^A \\boldsymbol{O}_2 = (\\sqrt{3}, -1)\\) en coordenadas del robot \\(\\textbf{A}\\)\n\n\n\n\n\n\n\n\n\n\nPuedes dibujarlos en una cuadrícula o utilizar variables en python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipOpcional"
  },
  {
    "objectID": "clases/07/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/07/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 07 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/07/lab.html#práctica-de-marcos-de-referencia-y-transformaciones",
    "href": "clases/07/lab.html#práctica-de-marcos-de-referencia-y-transformaciones",
    "title": "Clase 07 - Laboratorio",
    "section": "",
    "text": "Un robot \\(\\textbf{A}\\) se encuentra en la posición \\((2,1)\\) con orientación \\(30^\\circ\\) en coordenadas del \\(\\textit{Mundo}\\)\nUn robot \\(\\textbf{B}\\) se encuentra en la posición \\((0.5,\\tfrac{\\sqrt{3}}{2})\\) con orientación \\(60^\\circ\\) en el sistema de coordenadas del robot \\(\\textbf{A}\\)\nUn obstáculo \\({}^W \\boldsymbol{O}_1 = (0, 3)\\) en coordenadas del \\(\\textit{Mundo}\\)\nUn obstáculo \\({}^A \\boldsymbol{O}_2 = (\\sqrt{3}, -1)\\) en coordenadas del robot \\(\\textbf{A}\\)\n\n\n\n\n\n\n\n\n\n\nPuedes dibujarlos en una cuadrícula o utilizar variables en python\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nTipOpcional"
  },
  {
    "objectID": "clases/07/lab.html#parte-2.-transformaciones-estáticas-y-dinámicas",
    "href": "clases/07/lab.html#parte-2.-transformaciones-estáticas-y-dinámicas",
    "title": "Clase 07 - Laboratorio",
    "section": "Parte 2. Transformaciones estáticas y dinámicas",
    "text": "Parte 2. Transformaciones estáticas y dinámicas\n\n1. Crear un archivo launch que recree el escenario de la parte 1 utilizando el nodo static_transform_publisher\n\nPublique la transformación de cada uno de los marcos de referencia y puntos de interés\nEl nodo static_transform_publisher recibe sus valores mediante argumentos, no parámetros. Por lo tanto utilizar el campo arguments de la acción Node del launch\n\n    Node(\n        ...\n        arguments=[\n                '--x', '&lt;x&gt;',\n                '--y', '&lt;y&gt;',\n                '--z', '&lt;z&gt;',\n                '--roll', '&lt;yaw&gt;',\n                '--pitch', '&lt;yaw&gt;',\n                '--yaw', '&lt;yaw&gt;',\n                '--frame-id', '&lt;marco_referencia&gt;',\n                '--child-frame-id', '&lt;marco_objetivo&gt;'\n        ],\n        ...\n    ),\n\n\n\n\n\n\n\nPuede utilizar el paquete rqt_tf_tree o rviz2 para verificar el resultado\n\n\n\n\n\n2. Mediante el comando ros2 run tf2_ros tf2_echo verifique los resultados obtenidos en la parte 1\n\n\n3. Implementar un nodo que publique una transformación en movimiento\n\nUtilice como marco de referencia fijo aquel que haya utilizado como \\(\\textit{Mundo}\\) en la parte 1, y utilice robotC como nombre para el marco móvil\nGenerar las coordenadas \\(x\\) e \\(y\\) mediante las siguientes ecuaciones:\n\n\\[\n\\begin{align}\nx &= R \\cdot \\cos(t) \\\\\ny &= R \\cdot \\sin(t)\n\\end{align}\n\\]\n\n\n\n\n\n\nPuede crear un parámetro para configurar el radio \\(R\\) del círculo\n\n\n\n\nPara obtener el tiempo \\(t\\) puede utilizar la función get_clock()del nodo:\n\nseconds, nanoseconds = self.get_clock().now().seconds_nanoseconds()\nt = (nanoseconds / 1E9 + seconds) * (np.pi / 2.0)   # 1 vuelta cada 4 segundos\n\nPuede utilizar una coordenada \\(z = 0\\) constante u otro valor aproximado\n\nPara calcular la orientación, se debe obtener el ángulo de la tangente a la trayectoria, para esto se podrá utilizar la función arctan2 de numpy:\n\nyaw = np.arctan2(np.cos(t), -np.sin(t))\n\n\n\n\n\n\nRecuerde que en rotaciones 2D el cuaternion para rotar un ángulo \\(\\alpha\\) puede definirse de la siguiente forma \\[\n\\boldsymbol{q} = \\begin{pmatrix} 0 & 0 & \\sin{\\tfrac{\\alpha}{2}} & \\cos{\\tfrac{\\alpha}{2}} \\end{pmatrix}^T\n\\]\n\n\n\n\nPublique las transformaciones a más de 30 [Hz] para ver una animación fluida\n\n\n\n\n\n\n\nPuede crear un parámetro para configurar la frecuencia de actualización\n\n\n\n\nModifique el launch del ejercicio anterior para añadir este nuevo nodo al escenario\n\n\n\n\n\n\n\nRecuerde siempre completar las dependencias e instalarlas, configurar adecuadamente el archivo setup.py de instalación, compilar el workspace y configurar el entorno local"
  },
  {
    "objectID": "clases/08/index.html#urdf-unified-robot-definition-format",
    "href": "clases/08/index.html#urdf-unified-robot-definition-format",
    "title": "Robótica",
    "section": "URDF: Unified Robot Definition Format",
    "text": "URDF: Unified Robot Definition Format\n\nPermite describir geometría y características del robot\n\n\nCuando se desarrolla un robot, pueden existir muchos componentes de software diferentes que necesitan conocer características físicas del robot. Lo ideal es mantener esa información en una sola ubicación donde todos puedan acceder y hacer referencia\nEn ROS -&gt; robot description o descripción del robot; y se hace a través de archivos Unified Robot Description Format (URDF)\n\n\n\nFormato XML: La información se representa a través de etiquetas anidadas\n\n\nEl estándar URDF se basa en XML (Visto en archivos package.xml) -&gt; todo está representado a través de tags (etiquetas) que se pueden anidar\n\n\n\n\nEtiquetas principales: &lt;robot&gt;, &lt;link&gt;, &lt;joint&gt;\n\n\n\nExisten muchos tipos (los cuales están estandarizados) pero tres principales\n\n\n\nDocumentación"
  },
  {
    "objectID": "clases/08/index.html#urdf-2-elementos-fundamentales",
    "href": "clases/08/index.html#urdf-2-elementos-fundamentales",
    "title": "Robótica",
    "section": "URDF: 2 Elementos fundamentales",
    "text": "URDF: 2 Elementos fundamentales\n\n\nEslabones: &lt;link&gt;\n\n\n\n\nJuntas: &lt;joint&gt;\n\n\n\n\n\n \n\n\nLink \n\n\n \n\n\nJoint \n\n\n \n\n\n\n\nLa estructura es un arbol de links conectados por joints. Los links (eslabones) representan partes o componentes físicos del robot y las joints (juntas) representan como se mueve un link con respecto a otro definiendo la ubicación del link en el espacio."
  },
  {
    "objectID": "clases/08/index.html#urdf-links-y-joints",
    "href": "clases/08/index.html#urdf-links-y-joints",
    "title": "Robótica",
    "section": "URDF: links y joints",
    "text": "URDF: links y joints\n\n\n\n\n\n\n\nMuy importante\n\n\nIdentificar de forma conveniente como dividir la estructura física del robot en links y joints\n\n\n\n\n\nUna parte que se mueve relativa a otra \nUna parte que no se mueve pero es conveniente conocer su marco de referencia \nCadena de transformaciones para los casos anteriores\n\n\nCuando se describe un robot a través de un URDF es necesario identificar como dividir el robot de forma conveniente/inteligente en links y joints"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-robot..robot",
    "href": "clases/08/index.html#etiqueta-robot..robot",
    "title": "Robótica",
    "section": "Etiqueta <robot>..<\\robot>",
    "text": "Etiqueta &lt;robot&gt;..&lt;\\robot&gt;\n\nEtiqueta raíz (todo el contenido se encuentra dentro)\n1 solo atributo: el nombre\n\n\nEl tag de robot (y la declaración XML) -&gt; Todos los archivos XML empiezan con la declaración en la primera linea (propio de XML) y luego para archivos URDF existe una única etiqueta denominada raíz donde todas las otras etiquetas conviven (están dentro de). Esta etiqueta es el robot tag, y el único atributo que posee es el nombre del robot name=”mi_robot”\n\n\n&lt;?xml version=\"1.0\"?&gt;\n\n&lt;robot name=\"mi_robot\"&gt;\n    ...\n    &lt;!-- Contenido --&gt;\n    ... \n&lt;/robot&gt;"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link",
    "href": "clases/08/index.html#etiqueta-link..link",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\n1 solo atributo: el nombre\n\n\n\n\n\n\n\nPor convención el nombre tiene sufijo ‘_link’\n\n\n\n\n\n3 posibles geometrías: &lt;visual&gt;, &lt;collision&gt; y &lt;inertial&gt;\n\n&lt;link name=\"parteA_link\"&gt;\n    &lt;visual&gt;..&lt;/visual&gt;\n    &lt;collision&gt;..&lt;/collision&gt;\n    &lt;inertial&gt;..&lt;/inertial&gt; \n&lt;/link&gt;\n\n\nlink -&gt; Permite especificar el nombre además de otras características como la apariencia visual, las propiedades inerciales y de colisión\nvisual -&gt; Es lo que se visualiza en RViz y Gazebo\nCollision -&gt; Utilizado para el cálculo de colisión física en simulación"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link-1",
    "href": "clases/08/index.html#etiqueta-link..link-1",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\n\n\nGeometría visual &lt;visual&gt;..&lt;/visual&gt;\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n            rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nOrigin: Offset para la geometría en el caso de que no esté centrado en el origen del link\n\n\n\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nMaterial: El color (si se declara un material con nombre, puede utilizarse, si no los valores RGB)\n\n\n\n\nGeometría: prisma\n\n    &lt;box size=\"[largo-x] [ancho-y] [alto-z]\" /&gt;\n\nGeometry: con los parámetros de tamaño\n\n\n\n\nEjemplo:\n&lt;visual&gt;\n    &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n    &lt;geometry&gt;\n        &lt;box size=\"0.1 0.2 0.3\" /&gt;\n    &lt;/geometry&gt;\n    &lt;material name=\"Cyan\"&gt;\n        &lt;color rgba=\"0 1.0 1.0 1\"/&gt;\n    &lt;/material&gt;\n&lt;/visual&gt;"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link-2",
    "href": "clases/08/index.html#etiqueta-link..link-2",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\n\n\nGeometría visual &lt;visual&gt;..&lt;/visual&gt;\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n            rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nGeometría: cilindro\n\n    &lt;cylinder radius=\"[radio]\" length=\"[ancho]\" /&gt;\n\n\nEjemplo:\n&lt;visual&gt;\n    &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n    &lt;geometry&gt;\n        &lt;cylinder radius=\"0.1\" length=\"0.1\" /&gt;\n    &lt;/geometry&gt;\n    &lt;material name=\"Silver\"&gt;\n        &lt;color rgba=\"0.79 0.82 0.93 1\"/&gt;\n    &lt;/material&gt;\n&lt;/visual&gt;"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link-3",
    "href": "clases/08/index.html#etiqueta-link..link-3",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\n\n\nGeometría visual &lt;visual&gt;..&lt;/visual&gt;\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n            rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nGeometría: esfera\n\n    &lt;sphere radius=\"[radio]\" /&gt;"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link-4",
    "href": "clases/08/index.html#etiqueta-link..link-4",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\n\n\nGeometría visual &lt;visual&gt;..&lt;/visual&gt;\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n            rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nGeometría: malla\n\n    &lt;mesh filename=\"file://[nombre_del_archivo]\" /&gt;\n\n\nEjemplo:\n&lt;visual&gt;\n    &lt;origin xyz=\"0.0 0.0 0.0\" rpy=\"0.0 0.0 0.0\"/&gt;\n    &lt;geometry&gt;\n        &lt;mesh filename=\"file:///gear.stl\" scale=\"0.01 0.01 0.01\"/&gt;\n    &lt;/geometry&gt;\n    &lt;material name=\"Orange\"&gt;\n        &lt;color rgba=\"1 0.3 0.1 1\"/&gt;\n    &lt;/material&gt;\n&lt;/visual&gt;"
  },
  {
    "objectID": "clases/08/index.html#etiqueta-link..link-5",
    "href": "clases/08/index.html#etiqueta-link..link-5",
    "title": "Robótica",
    "section": "Etiqueta <link>..</link>",
    "text": "Etiqueta &lt;link&gt;..&lt;/link&gt;\n\nGeometría para simulación &lt;collision&gt;..&lt;/collision&gt;\n\n\nGeneralmente por razones de computabilidad, se busca que sea una forma más simple que la visual para simplificar los cálculos.\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\" rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\n\n\nGeometría: box, cylinder, sphere, mesh\n\n    &lt;box size=\"[largo-x] [ancho-y] [alto-z]\" /&gt;\n\n    &lt;cylinder radius=\"[radio]\" length=\"[ancho]\" /&gt;\n\n    &lt;sphere radius=\"[radio]\" /&gt;\n\n    &lt;mesh filename=\"file://[nombre_del_archivo]\" /&gt;\n\nGeometry y Origin: igual que para el caso visual."
  },
  {
    "objectID": "clases/08/index.html#etiqueta-joint..joint",
    "href": "clases/08/index.html#etiqueta-joint..joint",
    "title": "Robótica",
    "section": "Etiqueta <joint>..</joint>",
    "text": "Etiqueta &lt;joint&gt;..&lt;/joint&gt;\n\n2 atributos: el nombre y tipo\n\n\n\n\n\n\n\nPor convención el nombre tiene sufijo ‘_joint’\n\n\n\n\n\n2 elementos requeridos: link padre e hijo\n\n&lt;joint name=\"parteB_joint\" type=\"tipo\"&gt;\n    &lt;parent link=\"parteA_link\"/&gt;\n    &lt;child link=\"parteB_link\"/&gt;\n    ...\n&lt;/joint&gt;\n\n\nParent -&gt; link padre\nChild -&gt; link hijo (para definir la relación de un link (hijo) respecto a otro (padre))\n\n\n\n\nSon los que realmente almacenan la información de cómo se compone la estructura del robot, define la ubicación de los link y como se mueven entre sí. (Similar a tf donde se tienen los marcos, pero lo que importan son las transformaciones)\nAtributos:\n\nname -&gt; Nombre de cada junta\ntype -&gt; Tipo"
  },
  {
    "objectID": "clases/08/index.html#tipos-de-juntas",
    "href": "clases/08/index.html#tipos-de-juntas",
    "title": "Robótica",
    "section": "Tipos de juntas",
    "text": "Tipos de juntas\n\n\n\n\nFija (fixed)\n\n\n\n\n1 elemento: &lt;origin .. /&gt;\n\n&lt;joint name=\"parteA_joint\" type=\"fixed\"&gt;\n    &lt;parent link=\"padre_link\"/&gt;\n    &lt;child link=\"parteA_link\"/&gt;\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n        rpy=\"[roll] [pitch] [yaw]\"/&gt;\n&lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\n\nEl link hijo está conectado de forma rígida con el link padre\nOrigin -&gt; Origen de la relación antes de cualquier movimiento (como se inicia)"
  },
  {
    "objectID": "clases/08/index.html#tipos-de-juntas-1",
    "href": "clases/08/index.html#tipos-de-juntas-1",
    "title": "Robótica",
    "section": "Tipos de juntas",
    "text": "Tipos de juntas\n\n\n\nFija (fixed)\nContinua (continuous)\n\n\n\n2 elementos: &lt;origin .. /&gt;\n&lt;axis ../&gt;\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n    &lt;parent link=\"padre_link\"/&gt;\n    &lt;child link=\"parteA_link\"/&gt;\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n        rpy=\"[roll] [pitch] [yaw]\"/&gt;\n    &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n&lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\n\nMovimiento rotacional sin límites\nAxis -&gt; El eje en el cual se desarrolla el movimiento"
  },
  {
    "objectID": "clases/08/index.html#tipos-de-juntas-2",
    "href": "clases/08/index.html#tipos-de-juntas-2",
    "title": "Robótica",
    "section": "Tipos de juntas",
    "text": "Tipos de juntas\n\n\n\nFija (fixed)\nContinua (continuous)\nRevolución (revolute)\n\n\n\n3 elementos: &lt;origin .. /&gt;\n&lt;axis ../&gt; y &lt;limit ../&gt;\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n    &lt;parent link=\"padre_link\"/&gt;\n    &lt;child link=\"parteA_link\"/&gt;\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n        rpy=\"[roll] [pitch] [yaw]\"/&gt;\n    &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n    &lt;limit lower=\"[min_rad]\" upper=\"[max_rad]\"\n        velocity=\"[rad_por_seg]\"\n        effort=\"[effort]\" /&gt;\n&lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\n\nMovimiento rotacional con ángulos máximos y mínimos\nLimits -&gt; Límites de actuación física, pueden ser (lower|upper|velocity|effort)"
  },
  {
    "objectID": "clases/08/index.html#tipos-de-juntas-3",
    "href": "clases/08/index.html#tipos-de-juntas-3",
    "title": "Robótica",
    "section": "Tipos de juntas",
    "text": "Tipos de juntas\n\n\n\nFija (fixed)\nContinua (continuous)\nRevolución (revolute)\nPrismática (prismatic)"
  },
  {
    "objectID": "clases/08/index.html#xacro-macros-en-xml",
    "href": "clases/08/index.html#xacro-macros-en-xml",
    "title": "Robótica",
    "section": "XACRO: Macros en XML",
    "text": "XACRO: Macros en XML\n\nCuanto más complejos los sistemas, más largos y pesados se hacen los URDF, por lo que separarlos en diferentes archivos permite encontrar las cosas de forma fácil y modificar de forma rápida, además de que al usar controles de versión los cambios quedan mejor ordenados\n\n\n\nFacilita la codificación de URDF\nHerramienta para dividir código y evitar duplicar\nProvee estructuras de ‘programacion’\n\n\nHerramienta para escribir URDF facilmente. Dos características principales: dividir el código en varios archivos y evitar duplicar código.\n\n\n\n\nAgregar al tag robot\n\n&lt;robot name=\"mi_robot\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\" &gt;\n    ...\n    &lt;!-- Contenido --&gt;\n    ... \n&lt;/robot&gt;\n\n\n\nDocumentación"
  },
  {
    "objectID": "clases/08/index.html#xacro-macros-en-xml-1",
    "href": "clases/08/index.html#xacro-macros-en-xml-1",
    "title": "Robótica",
    "section": "XACRO: Macros en XML",
    "text": "XACRO: Macros en XML\n\nSe necesita un paso de compilación:\n  $ xacro description.urdf.xacro\n\n\n\n\n\n\n\n\n\nActualizar dependencias: &lt;exec_depend&gt;xacro&lt;/exec_depend&gt;"
  },
  {
    "objectID": "clases/08/index.html#partición-de-los-componentes",
    "href": "clases/08/index.html#partición-de-los-componentes",
    "title": "Robótica",
    "section": "Partición de los componentes",
    "text": "Partición de los componentes\n\n\nEjemplos:\n\nLa geometría principal (links y joints)\nMateriales\nSensores\nSimulador (y parámetros de simulación)\nMacros\n\n\n📂 paquete_description\n    📁 paquete_description\n    📂 launch\n        📄 description.launch.py\n        ...\n    📂 urdf\n        📄 description.urdf.xacro\n        📄 materials.xacro\n        📄 my_macro.xacro\n        📄 sim_sensor.xacro\n        ...\n    📄 package.xml\n    📄 setup.py\n    ...\n\n\nLa división depende del escenario y la persona que lo programa, pero generalmente se sigue el siguiente esquema: Nucleo o core del robot (links y joints), lista de materiales (colores), sensores (links y joints) y los correspondientes a gazebo, macros"
  },
  {
    "objectID": "clases/08/index.html#inclusión-de-archivos",
    "href": "clases/08/index.html#inclusión-de-archivos",
    "title": "Robótica",
    "section": "Inclusión de archivos",
    "text": "Inclusión de archivos\n\nArchivo principal:\n\nse lo nombre con extensión ‘.urdf.xacro’\ncontiene el tag robot con nombre\n\nArchivos incluidos:\n\nextensión ‘.xacro’\nsolo contienen el tag robot (sin nombre)\n\n\n\nSe tiene un archivo principal o ‘main’ que representa el robot con el tag de ‘robot’ con nombre y la extensión ‘.urdf.xacro’.\nEl archivo incluido debe ser también de tipo xacro, con el tag ‘robot’ pero esta vez sin el atributo de ‘name’.\nNo existe límite para incluir archivos\n\n\n\n\n\nSe incluyen las partes mediante el tag &lt;xacro:include .. /&gt;\n\n\n\n\nDentro del archivo se incluyen los otros mediante xacro:include."
  },
  {
    "objectID": "clases/08/index.html#ejemplo-xacroinclude",
    "href": "clases/08/index.html#ejemplo-xacroinclude",
    "title": "Robótica",
    "section": "Ejemplo xacro:include",
    "text": "Ejemplo xacro:include\n\n\n\nmaterials.xacro\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;robot xmlns:xacro=\"http://www.ros.org/wiki/xacro\" &gt;\n    &lt;material name=\"Orange\"&gt;\n        &lt;color rgba=\"1 0.3 0.1 1\"/&gt;\n    &lt;/material&gt;\n&lt;/robot&gt;\n\n\n\n\n\n\n\ndescription.urdf.xacro\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"MyBot\" ...&gt;\n    &lt;xacro:include filename=\"materials.xacro\" /&gt;\n    ...\n    &lt;link name=\"base_link\"&gt;\n        &lt;visual&gt;\n            ...\n            &lt;geometry&gt; ... &lt;/geometry&gt;\n            &lt;material name=\"Orange\"&gt;\n        &lt;/visual&gt;\n    &lt;/link&gt;\n    ...\n&lt;/robot&gt;"
  },
  {
    "objectID": "clases/08/index.html#parametrización-de-atributos",
    "href": "clases/08/index.html#parametrización-de-atributos",
    "title": "Robótica",
    "section": "Parametrización de atributos",
    "text": "Parametrización de atributos\n\nOperaciones matemáticas: ${..}\nPropiedades xacro:property: Nombre y valor\n\n\n&lt;?xml version=\"1.0\"?&gt;\n&lt;robot name=\"MyBot\" ...&gt;\n    &lt;xacro:property name=\"diametro\" value=\"2.1\" /&gt;\n    &lt;xacro:property name=\"ancho\" value=\"4.5\" /&gt;\n    &lt;xacro:property name=\"alpha\" value=\"${30/180*pi}\" /&gt;\n    ...\n        &lt;geometry type=\"cylinder\"\n            radius=\"${diametro / 2}\" length=\"${ancho}\" /&gt;\n        ...\n        &lt;origin xyz=\"0 0 0\" rpy=\"0 0 ${alpha}\" /&gt;\n    ...\n&lt;/robot&gt;"
  },
  {
    "objectID": "clases/08/index.html#comandos-de-rospack",
    "href": "clases/08/index.html#comandos-de-rospack",
    "title": "Robótica",
    "section": "Comandos de rospack",
    "text": "Comandos de rospack\n\nArgumentos xacro:args: Nombre y valor por defecto\n\n    &lt;xacro:arg name=\"arg1\" default=\"false\"/&gt;\n\n\nBuscar paquetes $(find ..):\n\n    &lt;xacro:include filename=\"$(find &lt;nombre_paquete&gt;)/&lt;nombre_archivo&gt;.xacro\" /&gt;"
  },
  {
    "objectID": "clases/08/index.html#bloques-condicionales",
    "href": "clases/08/index.html#bloques-condicionales",
    "title": "Robótica",
    "section": "Bloques condicionales",
    "text": "Bloques condicionales\n\nEtiqueta xacro:if para true y xacro:unless para false\n\n&lt;xacro:if value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es verdadera: 'true' o 1 --&gt;\n&lt;/xacro:if&gt;\n&lt;xacro:unless value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es falsa: 'false' o 0  --&gt;\n&lt;/xacro:unless&gt;"
  },
  {
    "objectID": "clases/08/index.html#macros",
    "href": "clases/08/index.html#macros",
    "title": "Robótica",
    "section": "Macros",
    "text": "Macros\n\nPorciones de código a reutilizar (plantillas)\nxacro:macro: Nombre y parámetros a recibir\n\n\n\n\n\nmacro.xacro\n\n&lt;xacro:macro name=\"rueda_esferica\"\n    params=\"prefijo link_padre radio \n            pos_x:=0 pos_y:=0 pos_z:=0\"&gt;\n    &lt;xacro:property name=\"nombre_link\"\n        value=\"${prefijo}_link\" /&gt;\n    &lt;link name=\"${nombre_link}\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"${radio}\" /&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"black\" /&gt;\n        &lt;/visual&gt;\n        ...\n    &lt;/link&gt;\n    &lt;joint name=\"${prefijo}_joint\" type=\"fixed\"&gt;\n        &lt;parent link=\"${link_padre}$\"/&gt;\n        &lt;child link=\"${nombre_link}\"/&gt;\n        &lt;origin xyz=\"${pos_x} ${pos_y} ${pos_z}\"\n            rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;\n&lt;/xacro:macro&gt;\n\n\n\n&lt;xacro:rueda_esferica prefix=\"rueda_delantera\"\n    link_padre=\"base_link\" radio=\"1.0\" pos_x=\"0.5\" /&gt; \n\n\n\nResultado:\n\n    &lt;link name=\"rueda_delantera_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"1.0\" /&gt;\n            &lt;/geometry&gt;\n            &lt;material name=\"black\" /&gt;\n        &lt;/visual&gt;\n        ...\n    &lt;/link&gt;\n    &lt;joint name=\"rueda_delantera_joint\" type=\"fixed\"&gt;\n        &lt;parent link=\"base_link\"/&gt;\n        &lt;child link=\"rueda_delantera_link\"/&gt;\n        &lt;origin xyz=\"0.5 0 0\" rpy=\"0 0 0\"/&gt;\n    &lt;/joint&gt;"
  },
  {
    "objectID": "clases/08/index.html#similitudes-entre",
    "href": "clases/08/index.html#similitudes-entre",
    "title": "Robótica",
    "section": "Similitudes entre",
    "text": "Similitudes entre\n\n\n\n\n\n\n\n\nURDF\n\ntf2\n\n\n\n\narbol de ..\n\narbol de ..\n\n\nlinks\n\nframes\n\n\nconectados por ..\n\nconectados por ..\n\n\njoints\n\ntransforms\n\n\n\n\n\n\n\n\n\n\nTip\n\n\nInterpretando los links y joints del robot description puedo publicar los frames y tf correspondientes"
  },
  {
    "objectID": "clases/08/index.html#paquete-robot_state_publisher",
    "href": "clases/08/index.html#paquete-robot_state_publisher",
    "title": "Robótica",
    "section": "Paquete robot_state_publisher",
    "text": "Paquete robot_state_publisher\n\nDescripción del robot ➡️ /robot_description\nJuntas fijas (transformaciones estáticas) ➡️ /tf_static\nJuntas móviles ➡️ /joint_states ➡️ transformaciones dinámicas ➡️ /tf\n\n\n\n\n\n\n\n\n\nEl paquete robot_state_publisher toma el archivo URDF y automaticamente transmite todas las transformaciones necesarias\nAdemás publica el contenido en el topic /robot_description así todos los otros nodos que necesitan la descripción del robot utilizan el mismo archivo\nPara las joints que son fijas, se publica la transformación estática\nPara las móviles se necesitan datos externos (angulo o distancia) para calcular la transformación dinámica para cada instante de tiempo.\nPara esto el nodo se subscribe al topic /joint_states"
  },
  {
    "objectID": "clases/08/index.html#topic-joint_states",
    "href": "clases/08/index.html#topic-joint_states",
    "title": "Robótica",
    "section": "Topic /joint_states",
    "text": "Topic /joint_states\n\nListado de juntas con sus respectivos estados:\n\n        sensor_msgs/JointState\n        ├── std_msgs/Header header\n        ├── string[] name\n        ├── float64[] position\n        ├── float64[] velocity\n        └── float64[] effort\n\n\n\n\n\n\nQuién publica en el /joint_states?\n\n\n\n\n\n\n\n\n\n\nUtilizando el paquete joint_state_publisher_gui se puede controlar la posición de la junta.\nPublica posiciones ficticias de cada una de las juntas."
  },
  {
    "objectID": "clases/08/index.html#sistema-completo",
    "href": "clases/08/index.html#sistema-completo",
    "title": "Robótica",
    "section": "Sistema completo",
    "text": "Sistema completo\n\nURDF + XACRO + robot_state_publisher + joint_state_publisher_gui"
  },
  {
    "objectID": "clases/08/index.html#comandos-de-cada-paquete",
    "href": "clases/08/index.html#comandos-de-cada-paquete",
    "title": "Robótica",
    "section": "Comandos de cada paquete",
    "text": "Comandos de cada paquete\n\nrobot_state_publisher\n\n    $ ros2 run robot_state_publisher robot_state_publisher\n                --ros-args -p robot_description:='&lt;robot_description&gt;'\n\njoint_state_publisher_gui\n\n    $ ros2 run joint_state_publisher_gui joint_state_publisher_gui"
  },
  {
    "objectID": "clases/08/index.html#taller-de-resolución-1",
    "href": "clases/08/index.html#taller-de-resolución-1",
    "title": "Robótica",
    "section": "Taller de resolución",
    "text": "Taller de resolución\nEjercicios 1 y 2"
  },
  {
    "objectID": "clases/19/index.html#navegación-1",
    "href": "clases/19/index.html#navegación-1",
    "title": "Robótica",
    "section": "Navegación",
    "text": "Navegación\n\nÁrea más desafiante en robótica móvil\n\n4 pilares\n\nPercepción\nLocalización\nControl\nCognición (o inteligencia)"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estado-finito-fsm",
    "href": "clases/19/index.html#máquinas-de-estado-finito-fsm",
    "title": "Robótica",
    "section": "Máquinas de estado finito (fsm)",
    "text": "Máquinas de estado finito (fsm)\n\nMáquina abstracta que consiste en:\n\nUn conjunto de estados \\(S\\) (incluyendo uno inicial \\(s_0\\))\nUn alfabeto de posibles entradas (\\(\\Sigma\\)) \nFunciones de transición que relacionan un estado con otro para una entrada dada: \\[\ns_i \\stackrel{c}{\\rightarrow} s_j\n\\] cada transición tiene una condición \\(c\\) que determina cuando se aplica\n\n\n\nSalidas: Según el tipo de fsm es que dependen cómo y cuando se producen las salidas"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estado-finito-fsm-1",
    "href": "clases/19/index.html#máquinas-de-estado-finito-fsm-1",
    "title": "Robótica",
    "section": "Máquinas de estado finito (fsm)",
    "text": "Máquinas de estado finito (fsm)\n\nSe pueden representar como una cinco-tupla\n\n\n\n\n\n\\[\n\\hspace{18em} \\LARGE \\left( \\Sigma, \\Gamma, S, s_0, \\delta \\right)\n\\]\n\n\n\n\n\n\\(\\Sigma\\): Entradas (conjunto no vacío finito)\n\\(\\Gamma\\): Salidas\n\\(S\\): Estados\n\\(s_0 \\in S\\): Estado inicial\n\\(\\delta\\): Funciones de transición \\(\\delta: S \\times \\Sigma \\to S \\times \\Gamma\\)"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm",
    "href": "clases/19/index.html#ejemplo-de-fsm",
    "title": "Robótica",
    "section": "Ejemplo de fsm",
    "text": "Ejemplo de fsm\n\nProcedimiento de autenticación para un sistema, app, página web, etc.\n\n\nComportamiento\n\nEspera el nombre de usuario y la contraseña\nSi los datos son correctos, permite el acceso\nSi los datos son incorrectos, muestra un mensaje y vuelve al estado inicial\nSi el usuario cierra sesión, vuelve al estado inicial"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión",
    "text": "Ejemplo de fsm: Inicio de sesión\n\n\\[\n\\def\\sc#1{\\dosc#1\\csod}\n\\def\\dosc#1#2\\csod{{\\rm #1{\\small #2}}}\n\\]\n\n\nEstados \\[S = \\left\\{ \\sc{ESPERANDO}\\sc{CREDENCIALES}, \\sc{ACCESO}\\sc{PERMITIDO} \\right\\}\\]\nEntradas: \\[\\Sigma = \\left\\{ \\sc{CREDENCIALES}\\sc{VALIDAS}, \\sc{CREDENCIALES}\\sc{INVALIDAS}, \\sc{CERRAR}\\sc{SESION} \\right\\}\\]\nSalidas: \\[\\Gamma = \\left\\{ \\sc{PERMITIR}\\sc{ACCESO}, \\sc{MENSAJE}\\sc{CREDENCIALES}\\sc{INVALIDAS},\\\\ \\sc{MENSAJE}\\sc{SESION}\\sc{CERRADA} \\right\\}\\]\nEstado inicial: \\[s_0 = \\sc{ESPERANDO}\\sc{CREDENCIALES}\\]\nFunciones de transición: \\(\\delta ?\\)"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-1",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-1",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión",
    "text": "Ejemplo de fsm: Inicio de sesión\n\nTabla de transición y de salida\n\n\nLa función de transición \\(\\delta\\) se puede representar mediante una tabla\n\nFilas \\(\\to\\) Estados \\(S\\)\nColumnas \\(\\to\\) Entradas \\(\\Sigma\\)\nCelda \\(\\to\\) Tupla \\(s,\\sigma\\) indicando el siguiente estado y la salida"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-2",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-2",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión",
    "text": "Ejemplo de fsm: Inicio de sesión\n\nTabla de transición y de salida\n\n\n\n\n\n\n\n\n\n\n\nCredenciales válidas\nCredenciales inválidas\nCerrar sesión\n\n\n\n\nEsperando credenciales\nAcceso permitido;Permitir acceso\nEsperando credenciales;Mensaje credenciales inválidas\n-\n\n\nAcceso permitido\n-\n-\nEsperando credenciales;Mensaje sesión cerrada"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-3",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-3",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión",
    "text": "Ejemplo de fsm: Inicio de sesión\n\nLas máquinas de estado pueden representarse mediante diagramas de estado"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estado-finito-1",
    "href": "clases/19/index.html#máquinas-de-estado-finito-1",
    "title": "Robótica",
    "section": "Máquinas de estado finito",
    "text": "Máquinas de estado finito\n\nEstados\n\n\nEl estado de un sistema es una condición en un punto particular en el tiempo\nAfecta a cómo el sistema reacciona a las entradas\nEs un “resúmen” del pasado"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estado-finito-2",
    "href": "clases/19/index.html#máquinas-de-estado-finito-2",
    "title": "Robótica",
    "section": "Máquinas de estado finito",
    "text": "Máquinas de estado finito\n\nTransiciones\n\n\nLa definición de una fsm no determina “cuando” evaluar las funciones de transición\nPor lo tanto puede reaccionar:\n\nCuando se aplica una entrada ➡️ disparada por evento\nA intervalos regulares ➡️ disparada por tiempo\n\n\n\n\nNada define “cuando” una fsm debe evaluar las funciones de transición\nAl ser un sistema discreto no se menciona explícitamente cuanto tiempo debe pasar entre transiciones\nEl contexto de operación define cuando deben reaccionar"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estado-finito-3",
    "href": "clases/19/index.html#máquinas-de-estado-finito-3",
    "title": "Robótica",
    "section": "Máquinas de estado finito",
    "text": "Máquinas de estado finito\n\nDos tipos: George Mealy y Edward Moore\n\n\n\nfsm de tipo Moore: La salida solo depende del estado actual\n\n\n\nfsm de tipo Mealy: La salida depende del estado actual y la entrada"
  },
  {
    "objectID": "clases/19/index.html#mealy-vs-moore",
    "href": "clases/19/index.html#mealy-vs-moore",
    "title": "Robótica",
    "section": "Mealy vs Moore",
    "text": "Mealy vs Moore\n\nCualquier máquina de Moore puede convertirse en una de Mealy equivalente\nNo siempre una de Mealy puede convertirse en una de Moore\nLas de tipo Mealy tienden a ser más compactas (menos estados) y la salida es instantánea a la entrada\nLas de tipo Moore se utilizan para una salida persistente"
  },
  {
    "objectID": "clases/19/index.html#máquinas-de-estados-extendidas-1",
    "href": "clases/19/index.html#máquinas-de-estados-extendidas-1",
    "title": "Robótica",
    "section": "Máquinas de estados extendidas",
    "text": "Máquinas de estados extendidas\n\nLa notación se vuelve engorrosa al aumentar la cantidad de estados\nMuchas aplicaciones requiren múltiples fuentes de entrada\nSolución: Modelo extendido de fsm\n\nVariables de estado interna\nTransiciones activadas por expresiones booleanas\nSalidas pueden ser llamadas a funciones"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-v2",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-v2",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión V2",
    "text": "Ejemplo de fsm: Inicio de sesión V2\n\nMejora de seguridad: Luego de múltiples intentos fallidos, bloquear la cuenta\n\n\nEstados\n\n\\[S = \\left\\{ \\sc{ESPERANDO}\\sc{CREDENCIALES}, \\sc{ACCESO}\\sc{PERMITIDO},\\\\ \\boxed{\\sc{CUENTA}\\sc{BLOQUEADA}} \\right\\}\\]\n\nVariable interna: \\(\\sc{INTENTOS}\\)\nEstado inicial: \\[s_0 = \\sc{ESPERANDO}\\sc{CREDENCIALES}, \\sc{INTENTOS} = 0\\]\nParámetros: \\(\\sc{MAXIMO}\\sc{INTENTOS} = 3\\)"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-v2-1",
    "href": "clases/19/index.html#ejemplo-de-fsm-inicio-de-sesión-v2-1",
    "title": "Robótica",
    "section": "Ejemplo de fsm: Inicio de sesión V2",
    "text": "Ejemplo de fsm: Inicio de sesión V2"
  },
  {
    "objectID": "clases/19/index.html#aplicación-de-fsm-a-robótica",
    "href": "clases/19/index.html#aplicación-de-fsm-a-robótica",
    "title": "Robótica",
    "section": "Aplicación de fsm a robótica",
    "text": "Aplicación de fsm a robótica\n\nEjemplo 1: Seguimiento de punto o Point follower (sin obstáculos)\n\n\n\n\n\\(\\require{color}\\)\n\n\nSea una posición y orientación inicial arbitraria del robot \\(\\textcolor{Maroon}{\\boldsymbol{P}(t_0)}\\)\nSea una posición objetivo \\(\\textcolor{Blue}{\\boldsymbol{G}}\\)\nSe debe diseñar un algoritmo que mediante una serie de controles \\(\\textcolor{ForestGreen}{\\nu(t)}\\) y \\(\\textcolor{Orange}{\\omega(t)}\\) conduzca el robot al punto objetivo"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-1-point-follower",
    "href": "clases/19/index.html#ejemplo-1-point-follower",
    "title": "Robótica",
    "section": "Ejemplo 1: Point follower",
    "text": "Ejemplo 1: Point follower\n\n3 posibles casos\n\n\n\n\nCaso trivial: el robot se encuentra en el objetivo\n\n\\[ \\textcolor{Maroon}{\\boldsymbol{P}} \\equiv \\textcolor{Blue}{\\boldsymbol{G}} \\]\n\nComandos:\n\n\\[\n\\begin{cases}\n\\textcolor{ForestGreen}{\\nu} = 0\\\\ %\\nu = 0\\\\\n\\textcolor{Orange}{\\omega} = 0 %\\omega = 0\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-1-point-follower-1",
    "href": "clases/19/index.html#ejemplo-1-point-follower-1",
    "title": "Robótica",
    "section": "Ejemplo 1: Point follower",
    "text": "Ejemplo 1: Point follower\n\n3 posibles casos\n\n\n\n\nCaso sencillo: el eje \\(\\textcolor{Maroon}{\\boldsymbol{x}_R}\\) del robot apunta al objetivo\n\n\\[\\textcolor{Maroon}{\\boldsymbol{\\gamma}} = 0\\]\n\nComandos:\n\n\\[\n\\begin{cases}\n\\textcolor{ForestGreen}{\\nu} &gt; 0\\\\\n\\textcolor{Orange}{\\omega} = 0\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-1-point-follower-2",
    "href": "clases/19/index.html#ejemplo-1-point-follower-2",
    "title": "Robótica",
    "section": "Ejemplo 1: Point follower",
    "text": "Ejemplo 1: Point follower\n\n3 posibles casos\n\n\n\n\nCaso general: el eje \\(\\textcolor{Maroon}{\\boldsymbol{x}_R}\\) del robot no apunta al objetivo\n\n\\[\\textcolor{Maroon}{\\boldsymbol{\\gamma}} \\neq 0\\]\n\n\n\n\n\n\n\nAl ser no-holonómico, primero se debe establecer el curso al objetivo"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-1-point-follower-3",
    "href": "clases/19/index.html#ejemplo-1-point-follower-3",
    "title": "Robótica",
    "section": "Ejemplo 1: Point follower",
    "text": "Ejemplo 1: Point follower\n\n\nAlgoritmo\n\nPaso 1: El curso es lo suficientemente bueno?\n\n✔️ Continuar al paso 2\n❌ Enderezar\n\nPaso 2: Está cercano al punto?\n\n✔️ Finalizar\n❌ Avanzar"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm",
    "href": "clases/19/index.html#point-follower-con-fsm",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\nIdentificar los componentes de la máquina\n\n\n\n\nEstados: \\(S = \\left\\{ \\textrm{Girar}, \\textrm{Avanzar} \\right\\}\\)\nEntradas: \\(\\Sigma = \\left\\{ \\boldsymbol{P}, \\theta \\right\\}\\)\nSalidas: \\(\\Gamma = \\left\\{ \\nu, \\omega \\right\\}\\)\nParámetro: \\(\\boldsymbol{G}\\)\nVariable: \\(\\gamma\\)\nEstado inicial: \\(s_0 = \\textrm{Girar}\\)\nFunciones de transición: \\(\\delta ?\\)"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-1",
    "href": "clases/19/index.html#point-follower-con-fsm-1",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\nTabla de transición y de salida\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\gamma &lt; 0\\)\n\\(\\gamma = 0\\)\n\\(\\gamma &gt; 0\\)\n\\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\neq 0\\)\n\\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert = 0\\)\n\n\n\n\nGirar\nGirar\\[\\nu = 0\\\\ \\omega &lt; 0\\]\nAvanzar\\[\\nu = 0\\\\ \\omega = 0\\]\nGirar\\[\\nu = 0\\\\ \\omega &gt; 0\\]\n-\n-\n\n\nAvanzar\n-\n-\n-\nAvanzar\\[\\nu &gt; 0\\\\ \\omega = 0\\]\nAvanzar\\[\\nu = 0\\\\ \\omega = 0\\]"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-2",
    "href": "clases/19/index.html#point-follower-con-fsm-2",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\nMáquina de estado de tipo Mealy"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-3",
    "href": "clases/19/index.html#point-follower-con-fsm-3",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\nMáquina de estado de tipo Moore"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-4",
    "href": "clases/19/index.html#point-follower-con-fsm-4",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\n\n\nImplementación fsm tipo Moore\n\n\nLas transiciones y las salidas son independientes\nLa función de control aplica los comandos según la variable state:\n\n0: Girar a izquierda\n1: Girar a derecha\n2: Avanzar\n3: Finalizar\n\n\n\nclass GoToPoint(Node):\n  def __init__(self):\n    #...\n    # Creación del publisher\n    self.pub = self.create_publisher(\n        Twist, 'cmd_vel', 10)\n    \n    # Creación del timer\n    self.timer = self.create_timer(\n        0.1, self.timer_callback)\n    self.state = 0\n    self.msg = Twist()\n\n  def timer_callback(self):        \n    if self.state == 0:\n      # Corregir curso izquierda\n      self.msg.linear.x = 0.0\n      self.msg.angular.z = np.pi/4\n    elif self.state == 1:\n      # Corregir curso derecha\n      self.msg.linear.x = 0.0\n      self.msg.angular.z = -np.pi/4\n    elif self.state == 2:\n      # Avanzar\n      self.msg.linear.x = 0.25\n      self.msg.angular.z = 0.0\n    elif self.state == 3:\n      # Finalizar\n      # Publicar un comando de Twist para detenerse\n      self.pub.publish(Twist())\n      self.get_logger().info(\"Done\")\n      # Terminar la ejecución\n      self.destroy_node()\n      raise SystemExit\n    else:\n      self.msg = Twist()\n      self.get_logger().error(\"Estado desconocido\")\n  \n  self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-5",
    "href": "clases/19/index.html#point-follower-con-fsm-5",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\n\n\nAntes de continuar será necesario definir las comparaciones por \\(\\approx\\) y \\(\\not\\approx\\)\nSe introducen dos parámetros:\n\nTolerancia angular: \\(\\epsilon_\\theta\\)\nTolerancia posicional: \\(\\epsilon_\\boldsymbol{P}\\)\n\n\n\\[\n\\gamma \\approx 0 \\to |\\gamma| &lt; \\epsilon_\\theta\\\\\n\\gamma \\not\\approx 0 \\to |\\gamma| &gt; \\epsilon_\\theta\\\\\n\\]\n\\[\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\approx 0 \\to \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\epsilon_\\boldsymbol{P}\\\\\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\not\\approx 0 \\to \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &gt; \\epsilon_\\boldsymbol{P}\n\\]"
  },
  {
    "objectID": "clases/19/index.html#point-follower-con-fsm-6",
    "href": "clases/19/index.html#point-follower-con-fsm-6",
    "title": "Robótica",
    "section": "Point-follower con fsm",
    "text": "Point-follower con fsm\n\n\n\nImplementación\n\n\nLa función de transición depende solo de la posición y orientación del robot\nPor lo tanto las transiciones se pueden implementar en el callback de odom\n\n\ndef sub_callback(self, msg: Odometry):\n    # Obtener la posición y la orientación del robot\n    x, y, theta = #...\n    # Calculo del error respecto del objetivo\n    e_x = self.x_goal - x\n    e_y = self.y_goal - y\n    e_pos = np.hypot(e_x, e_y)\n    \n    theta_d = np.arctan2(e_y, e_x)\n    # Corregir discontinuidad de arctan2(.)\n    # ...\n    e_theta = theta_d - theta\n\n    ### TRANSICIONES\n    if np.abs(e_theta) &gt; self.angular_tolerance \\\n      and e_theta &gt; 0.0:\n        self.cambiar_estado(0)\n    elif np.abs(e_theta) &gt; self.angular_tolerance \\\n      and e_theta &lt; 0.0:\n        self.cambiar_estado(1)\n    elif np.abs(e_theta) &lt;= self.angular_tolerance \\\n      and e_pos &gt; self.goal_tolerance:\n        self.cambiar_estado(2)\n    elif np.abs(e_theta) &lt;= self.angular_tolerance \\\n      and e_pos &lt;= self.goal_tolerance:\n        self.cambiar_estado(3)\n\ndef cambiar_estado(self, nuevo_estado):\n    if self.state != nuevo_estado:\n        self.state = nuevo_estado\n\n        self.get_logger().info(f\"Cambio de estado \\\n            {self.state} -&gt; {nuevo_estado}\")"
  },
  {
    "objectID": "clases/19/index.html#aplicación-de-fsm-a-robótica-1",
    "href": "clases/19/index.html#aplicación-de-fsm-a-robótica-1",
    "title": "Robótica",
    "section": "Aplicación de fsm a robótica",
    "text": "Aplicación de fsm a robótica\n\nEjemplo 2: Seguidor de obstáculo o Wall follower\n\n\n\n\nObjetivo: Dada una pared (u obstáculo), recorrer el perímetro siempre hacia el mismo lado\nRequiere un tipo de sensor de proximidad, se utilizará el de tipo LIDAR"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-2-wall-follower",
    "href": "clases/19/index.html#ejemplo-2-wall-follower",
    "title": "Robótica",
    "section": "Ejemplo 2: Wall follower",
    "text": "Ejemplo 2: Wall follower\nAlgoritmo\n\nPaso 1: Hay una pared u obstáculo al frente?\n\n✔️ Continuar al paso 2\n❌ Buscar la pared u obstáculo (girar a la izquierda)\n\nPaso 2: La pared u obstáculo está a la derecha?\n\n✔️ Continuar al paso 3\n❌ Hay una pared u obstáculo al frente?\n\n✔️ Girar a la izquierda (para que la pared u obstáculo quede a la derecha)\n❌ Volver al paso 1\n\n\nPaso 3: El obstáculo sigue a la derecha?\n\n✔️ Avanzar\n❌ Volver al paso 2"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-2-wall-follower-1",
    "href": "clases/19/index.html#ejemplo-2-wall-follower-1",
    "title": "Robótica",
    "section": "Ejemplo 2: Wall follower",
    "text": "Ejemplo 2: Wall follower\n\nDetección de obstáculos con LIDAR\n\n\n\n\nImplementación simple: dividir la rotación completa en zonas\nPor cada zona obtener la mínima medición\nComparar el valor con un umbral definido"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm",
    "href": "clases/19/index.html#wall-follower-con-fsm",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nIdentificar los componentes de la máquina\n\n\nEstados: \\(S = \\left\\{ \\textrm{BuscarObstaculo}, \\textrm{GirarIzquierda}, \\textrm{Avanzar} \\right\\}\\)\nEntradas: \\(\\Sigma = \\left\\{  R_\\textrm{F}, R_\\textrm{FL}, R_\\textrm{FR} \\right\\}\\)\nSalidas: \\(\\Gamma = \\left\\{ \\nu, \\omega \\right\\}\\)\nParámetro: \\(d = \\textrm{DistanciaPared}\\)\nEstado inicial: \\(s_0 = \\textrm{BuscarObstaculo}\\)\nFunciones de transición: \\(\\delta ?\\)"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-1",
    "href": "clases/19/index.html#wall-follower-con-fsm-1",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\n\\[\n\\require{color}\n\\def\\obstacle{\\textcolor{Maroon}{\\boldsymbol{&lt;}}}\n\\]\n\n\nTabla de condiciones\n\n\n\n\n\n\n\n\n\n\n\n\n\\(R_\\textrm{F} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FL} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FR} \\stackrel{?}{\\lessgtr} d\\)\nSiguiente estado\n\n\n\n\nSin obstáculos\n\\(&gt;\\)\n\\(&gt;\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nAl frente\n\\(\\obstacle\\)\n\\(&gt;\\)\n\\(&gt;\\)\nGirar Izquierda\n\n\nA izquierda\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA derecha\n\\(&gt;\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nAvanzar\n\n\nAl frente e izquierda\n\\(\\obstacle\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nGirar Izquierda\n\n\nAl frente y derecha\n\\(\\obstacle\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nGirar Izquierda\n\n\nA izquierda y derecha\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nBuscar Obstáculo\n\n\nFrente, izquierda y derecha\n\\(\\obstacle\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nGirar Izquierda"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-2",
    "href": "clases/19/index.html#wall-follower-con-fsm-2",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nTabla de condiciones\n\n\n\n\n\n\n\n\n\n\n\n\n\\(R_\\textrm{F} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FL} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FR} \\stackrel{?}{\\lessgtr} d\\)\nSiguiente estado\n\n\n\n\nSin obstáculos\n\\(&gt;\\)\n\\(&gt;\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nAl frente\n\\(\\obstacle\\)\n\\(&gt;\\)\n\\(&gt;\\)\nGirar Izquierda\n\n\nA izquierda\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA derecha\n\\(&gt;\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nAvanzar\n\n\nAl frente e izquierda\n\\(\\obstacle\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nGirar Izquierda\n\n\nAl frente y derecha\n\\(\\obstacle\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nGirar Izquierda\n\n\nA izquierda y derecha\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nBuscar Obstáculo\n\n\nFrente, izquierda y derecha\n\\(\\obstacle\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nGirar Izquierda"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-3",
    "href": "clases/19/index.html#wall-follower-con-fsm-3",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nTabla de transición\n\n\n\n\n\n\n\n\n\n\n\\[R_\\textrm{F} &lt; d\\]\n\\(\\dots\\)\n\n\n\n\nBuscar Obstáculo\nGirar Izquierda\n\\(\\dots\\)\n\n\nGirar Izquierda\nGirar Izquierda\n\\(\\dots\\)\n\n\nAvanzar\nGirar Izquierda\n\\(\\dots\\)"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-4",
    "href": "clases/19/index.html#wall-follower-con-fsm-4",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nTabla de condiciones\n\n\n\n\n\n\n\n\n\n\n\n\n\\(R_\\textrm{F} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FL} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FR} \\stackrel{?}{\\lessgtr} d\\)\nSiguiente estado\n\n\n\n\nSin obstáculos\n\\(&gt;\\)\n\\(&gt;\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA izquierda\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA derecha\n\\(&gt;\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nAvanzar\n\n\nA izquierda y derecha\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nBuscar Obstáculo\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\[R_\\textrm{F} &lt; d\\]\n\\[R_\\textrm{F} &gt; d \\wedge R_\\textrm{FL} &gt; d \\wedge R_\\textrm{FR} &lt; d\\]\n\n\n\n\nBuscar Obstáculo\nGirar Izquierda\nAvanzar\n\n\nGirar Izquierda\nGirar Izquierda\nAvanzar\n\n\nAvanzar\nGirar Izquierda\nAvanzar"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-5",
    "href": "clases/19/index.html#wall-follower-con-fsm-5",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nTabla de condiciones\n\n\n\n\n\n\n\n\n\n\n\n\n\\(R_\\textrm{F} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FL} \\stackrel{?}{\\lessgtr} d\\)\n\\(R_\\textrm{FR} \\stackrel{?}{\\lessgtr} d\\)\nSiguiente estado\n\n\n\n\nSin obstáculos\n\\(&gt;\\)\n\\(&gt;\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA izquierda\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(&gt;\\)\nBuscar Obstáculo\n\n\nA derecha\n\\(&gt;\\)\n\\(&gt;\\)\n\\(\\obstacle\\)\nAvanzar\n\n\nA izquierda y derecha\n\\(&gt;\\)\n\\(\\obstacle\\)\n\\(\\obstacle\\)\nBuscar Obstáculo\n\n\n\n\n\n\n\n\n\n\n\n\n\\[R_\\textrm{F} &lt; d\\]\n\\[R_\\textrm{F} &gt; d \\wedge R_\\textrm{FL} &gt; d \\wedge R_\\textrm{FR} &lt; d\\]\n\n\n\n\nBuscar Obstáculo\nGirar Izquierda\nAvanzar\n\n\nGirar Izquierda\nGirar Izquierda\nAvanzar\n\n\nAvanzar\nGirar Izquierda\nAvanzar"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-6",
    "href": "clases/19/index.html#wall-follower-con-fsm-6",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nTabla de transición\n\n\n\n\n\n\n\n\n\n\n\n\\[R_\\textrm{F} &lt; d\\]\n\\[R_\\textrm{F} &gt; d \\\\ R_\\textrm{FL} &gt; d \\\\ R_\\textrm{FR} &lt; d\\]\n\\[R_\\textrm{F} &gt; d \\wedge R_\\textrm{FL} &lt; d \\wedge R_\\textrm{FR} &lt; d\\\\R_\\textrm{F} &gt; d \\wedge R_\\textrm{FR} &gt; d\\]\n\n\n\n\nBuscar Obstáculo\nGirar Izquierda\nAvanzar\nBuscar Obstáculo\n\n\nGirar Izquierda\nGirar Izquierda\nAvanzar\nBuscar Obstáculo\n\n\nAvanzar\nGirar Izquierda\nAvanzar\nBuscar Obstáculo"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-7",
    "href": "clases/19/index.html#wall-follower-con-fsm-7",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nMáquina de estado de tipo Moore"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-8",
    "href": "clases/19/index.html#wall-follower-con-fsm-8",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\n\n\nImplementación fsm tipo Moore\n\n\nLas transiciones y las salidas son independientes\nLa función de control aplica los comandos según la variable state:\n\n0: Buscar obstáculo\n1: Girar a izquierda\n2: Avanzar\n\n\n\nclass GoToPoint(Node):\n  def __init__(self):\n    #...\n    # Creación del publisher\n    self.pub = self.create_publisher(\n        Twist, 'cmd_vel', 10)\n    \n    # Creación del timer\n    self.timer = self.create_timer(\n        0.1, self.timer_callback)\n    self.state = 0\n    self.msg = Twist()\n\n  def timer_callback(self):        \n    if self.state == 0:\n      # Buscar obstáculo\n      self.msg.linear.x = 0.2\n      self.msg.angular.z = -np.pi/4\n    elif self.state == 1:\n      # Girar a izquierda\n      self.msg.linear.x = 0.0\n      self.msg.angular.z = np.pi/4\n    elif self.state == 2:\n      # Avanzar\n      self.msg.linear.x = 0.25\n      self.msg.angular.z = 0.0\n    else:\n      self.msg = Twist()\n      self.get_logger().error(\"Estado desconocido\")\n  \n  self.pub.publish(self.msg)"
  },
  {
    "objectID": "clases/19/index.html#wall-follower-con-fsm-9",
    "href": "clases/19/index.html#wall-follower-con-fsm-9",
    "title": "Robótica",
    "section": "Wall-follower con fsm",
    "text": "Wall-follower con fsm\n\nImplementación\n\n\nLa función de transición depende solo de las mediciones del LIDAR\nPor lo tanto las transiciones se pueden implementar en el callback de scan\n\ndef sub_callback(self, msg: LaserScan):\n    # Convertir mediciones a vector de numpy\n    # y acotar entre rango máximo y mínimo\n    ranges = np.clip(np.array(msg.ranges), msg.range_min, msg.range_max)\n    \n    # Segmentar por regiones\n    regiones = {\n        'RIGHT':        np.min(ranges[ZONES[2]]),\n        'FRONT_RIGHT':  np.min(ranges[ZONES[3]]),\n        'FRONT':        np.min(ranges[ZONES[4]]),\n        'FRONT_LEFT':   np.min(ranges[ZONES[5]]),\n        'LEFT':         np.min(ranges[ZONES[6]]),\n    }\n\n    ### TRANSICIONES\n    _d = self.wall_distance\n    if regiones['FRONT'] &gt; _d and regiones['FRONT_LEFT'] &gt; _d and regiones['FRONT_RIGHT'] &gt; _d:\n        # Ninguna pared detectada\n        self.cambiar_estado(0)\n    elif regiones['FRONT'] &lt; _d and regiones['FRONT_LEFT'] &gt; _d and regiones['FRONT_RIGHT'] &gt; _d:\n        # Pared al frente\n        self.cambiar_estado(1)\n    elif regiones['FRONT'] &gt; _d and regiones['FRONT_LEFT'] &lt; _d and regiones['FRONT_RIGHT'] &gt; _d:\n        # Pared a la izquierda\n        self.cambiar_estado(0)\n    elif regiones['FRONT'] &gt; _d and regiones['FRONT_LEFT'] &gt; _d and regiones['FRONT_RIGHT'] &lt; _d:\n        # Pared a la derecha\n        self.cambiar_estado(2)\n    elif regiones['FRONT'] &lt; _d and regiones['FRONT_LEFT'] &lt; _d and regiones['FRONT_RIGHT'] &gt; _d:\n        # Pared al frente e izquierda\n        self.cambiar_estado(1)\n    elif regiones['FRONT'] &lt; _d and regiones['FRONT_LEFT'] &gt; _d and regiones['FRONT_RIGHT'] &lt; _d:\n        # Pared al frente y derecha\n        self.cambiar_estado(1)\n    elif regiones['FRONT'] &lt; _d and regiones['FRONT_LEFT'] &lt; _d and regiones['FRONT_RIGHT'] &lt; _d:\n        # Frente, izquierda y derecha\n        self.cambiar_estado(1)\n    elif regiones['FRONT'] &gt; _d and regiones['FRONT_LEFT'] &lt; _d and regiones['FRONT_RIGHT'] &lt; _d:\n        # Solo izquierda y derecha\n        self.cambiar_estado(0)\n    else:\n        self.get_logger().warning(\"Caso desconocido\")"
  },
  {
    "objectID": "clases/19/index.html#aplicación-de-fsm-a-robótica-2",
    "href": "clases/19/index.html#aplicación-de-fsm-a-robótica-2",
    "title": "Robótica",
    "section": "Aplicación de fsm a robótica",
    "text": "Aplicación de fsm a robótica\n\nEjemplo 3: Go-To-Point con evasión de obstáculo\n\n\n\n\nSeguir el contorno de cada obstáculo en el camino hacia el objetivo \\(\\boldsymbol{G}\\)\nAlgoritmo de evasión más simple\nConocido como Bug0"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-3-bug0",
    "href": "clases/19/index.html#ejemplo-3-bug0",
    "title": "Robótica",
    "section": "Ejemplo 3: Bug0",
    "text": "Ejemplo 3: Bug0\n\n\nAlgoritmo\n\nPaso 1: El camino al objetivo está libre?\n\n✔️ Ir al objetivo\n❌ Continuar al paso 2\n\nPaso 2: Hay un obstáculo para evadir?\n\n✔️ Rodear obstáculo\n❌ Continuar al paso 1\n\n\n\n\n\n\n\n\n\nSe pueden combinar los dos algoritmos anteriores: Go-To-Point y Wall-follower"
  },
  {
    "objectID": "clases/19/index.html#composición-de-fsm",
    "href": "clases/19/index.html#composición-de-fsm",
    "title": "Robótica",
    "section": "Composición de fsm",
    "text": "Composición de fsm\n\nDesventaja de las fsm: La mayoría de sistemas reales el número de estados es grande (a veces infinito)\nProblemas para representar directamente el gran espacio de estados\n\n\n\nDivide y vencerás: resolver un problema difícil, dividiéndolo en partes más simples"
  },
  {
    "objectID": "clases/19/index.html#composición-de-fsm-1",
    "href": "clases/19/index.html#composición-de-fsm-1",
    "title": "Robótica",
    "section": "Composición de fsm",
    "text": "Composición de fsm\n\nDiferentes tipos de composición:\n\n\nConcurrente:\n\nSegún la reacción:\n\nSincrónica (o simultánea)\nAsincrónica (o independiente)\n\nSegún el orden:\n\nParalelo (side-by-side)\nSerie (cascada)\nRe-alimentación (feedback)\n\n\nJerárquica"
  },
  {
    "objectID": "clases/19/index.html#composición-jerárquica-de-fsm",
    "href": "clases/19/index.html#composición-jerárquica-de-fsm",
    "title": "Robótica",
    "section": "Composición jerárquica de fsm",
    "text": "Composición jerárquica de fsm\n\nLa idea principal es el refinamiento del estado (definición sencilla)\n\n\n\n\n\n\n\n\nQué pasa si la máquina está en el estado \\(C\\) y \\(g_1\\) se activa al mismo tiempo que \\(g_4\\)?"
  },
  {
    "objectID": "clases/19/index.html#composición-jerárquica-de-fsm-1",
    "href": "clases/19/index.html#composición-jerárquica-de-fsm-1",
    "title": "Robótica",
    "section": "Composición jerárquica de fsm",
    "text": "Composición jerárquica de fsm\n\nSe evalúa la transición más profunda (o más refinada), luego la máquina de estado contenedor, luego su contenedora, y así sucesivamente\n\n\nEjemplo de composición jerárquica y su equivalente"
  },
  {
    "objectID": "clases/19/index.html#bug0-con-fsm-jerárquica",
    "href": "clases/19/index.html#bug0-con-fsm-jerárquica",
    "title": "Robótica",
    "section": "Bug0 con fsm jerárquica",
    "text": "Bug0 con fsm jerárquica\n\n\n\nEjemplo 3: Bug0\n\nAlgoritmo\n\nPaso 1: El camino al objetivo está libre?\n\n✔️ Ir al objetivo\n❌ Continuar al paso 2\n\nPaso 2: Hay un obstáculo para evadir?\n\n✔️ Rodear obstáculo\n❌ Continuar al paso 1"
  },
  {
    "objectID": "clases/19/index.html#bug0-con-fsm-jerárquica-1",
    "href": "clases/19/index.html#bug0-con-fsm-jerárquica-1",
    "title": "Robótica",
    "section": "Bug0 con fsm jerárquica",
    "text": "Bug0 con fsm jerárquica\n\n\n\nImplementación\n\n\nSe definen 2 estados independientes para \\(\\mathbf{M_1}\\) y \\(\\mathbf{M_2}\\):\n\nGo-to-point: g2p_state\nWall-follower: wf_state\n\nSe reutiliza el código de ambas fsm\nSe redefine la función de control y se predefinen los comandos de Twist\n\n\nclass GoToPoint(Node):\n  #...\n  def timer_callback(self):        \n    if self.wf_state == 0 and self.g2p_state != 3:\n      # Si no hay pared al frente\n      if self.g2p_state == 0:\n        self.msg = self.corregir_curso_izq()\n      elif self.g2p_state == 1:\n        self.msg = self.corregir_curso_der()\n      elif self.g2p_state == 2:\n        self.msg = self.avanzar()\n    elif self.wf_state == 1 and self.g2p_state != 3:\n      # Si tiene una pared al frente y \n      #   no llegó a destino\n      self.msg = self.girar_izq()\n    elif self.wf_state == 2 and self.g2p_state != 3:\n      # Si la pared está a la derecha y \n      #   no llegó a destino\n      self.msg = self.seguir_obstáculo()\n    elif self.g2p_state == 3:\n      self.finalizar()\n    else:\n      self.msg = Twist()\n      self.get_logger().error(\"Estado desconocido\")\n      pass"
  },
  {
    "objectID": "clases/19/index.html#bug0-con-fsm-jerárquica-2",
    "href": "clases/19/index.html#bug0-con-fsm-jerárquica-2",
    "title": "Robótica",
    "section": "Bug0 con fsm jerárquica",
    "text": "Bug0 con fsm jerárquica\n\nProblema: Al ser un algoritmo básico tiene casos donde falla"
  },
  {
    "objectID": "clases/19/index.html#alternativa-a-bug0-bug1",
    "href": "clases/19/index.html#alternativa-a-bug0-bug1",
    "title": "Robótica",
    "section": "Alternativa a Bug0: Bug1",
    "text": "Alternativa a Bug0: Bug1\n\nEjemplo 4: algoritmo Bug1\n\n\n\n\nAl encontrar un obstáculo, guardar la posición actual \\(H\\) y la distancia al objetivo \\(d_H\\)\nRodear completamente el obstáculo hasta volver a \\(H\\) obteniendo el punto de menor distancia al objetivo \\(L\\) tal que \\(d_L \\leq d_H\\)\nDirigirse nuevamente a \\(L\\) rodeando el objetivo, corregir el curso y continuar al objetivo\n\n\n\n\n\n\n\n\nAlgoritmo ineficiente pero eficaz"
  },
  {
    "objectID": "clases/19/index.html#alternativa-a-bug1-bug2",
    "href": "clases/19/index.html#alternativa-a-bug1-bug2",
    "title": "Robótica",
    "section": "Alternativa a Bug1: Bug2",
    "text": "Alternativa a Bug1: Bug2\n\nEjemplo 5: algoritmo Bug2\n\n\n\n\nSe traza una recta entre el punto inicial y el objetivo\nAvanzar por la recta hasta que:\n\nSe alcance el objetivo (Fin)\nSe encuentra un obstáculo\n\nSeguir el contorno del objeto hasta que:\n\nSe alcance el objetivo (Fin)\nSe cruza la recta en un punto a menor distancia que la del punto de contacto (vuelve al paso anterior)"
  },
  {
    "objectID": "clases/19/index.html#ejemplo-5-bug2",
    "href": "clases/19/index.html#ejemplo-5-bug2",
    "title": "Robótica",
    "section": "Ejemplo 5: Bug2",
    "text": "Ejemplo 5: Bug2\n\n\nAlgoritmo\n\n\nPaso 1: El camino al objetivo está libre?\n\n✔️ Girar al objetivo y avanzar\n❌ Continuar al paso 2\n\nPaso 2: Guardar la posición y rodear el obstáculo hacia la izquierda\nPaso 3: La posición actual cruza la recta?\n\n✔️ Si la distancia al objetivo es menor, volver al paso 1\n❌ El objetivo no puede alcanzarse"
  },
  {
    "objectID": "clases/19/index.html#bug2-con-fsm",
    "href": "clases/19/index.html#bug2-con-fsm",
    "title": "Robótica",
    "section": "Bug2 con fsm",
    "text": "Bug2 con fsm\n\nIdentificar los componentes de la máquina\n\n\nEstados: \\(S = \\left\\{ \\textrm{GirarAlObjetivo}, \\textrm{Avanzar}, \\textrm{RodearObstaculo} \\right\\}\\)\nEntradas: \\(\\Sigma = \\left\\{ \\boldsymbol{P}, \\theta \\right\\} + \\left\\{  R_\\textrm{F}, R_\\textrm{FL}, R_\\textrm{FR} \\right\\}\\)\nSalidas: \\(\\Gamma = \\left\\{ \\nu, \\omega \\right\\}\\)\nParámetro: \\(\\boldsymbol{G}, d = \\textrm{DistanciaPared}\\)\nVariable: \\(\\gamma = \\textrm{CursoAlObjetivo}, \\boldsymbol{H} = \\textrm{PuntoContacto}, \\boldsymbol{P}_0 = \\textrm{Posición inicial}\\)\nEstado inicial: \\(s_0 = \\textrm{GirarAlObjetivo}\\)"
  },
  {
    "objectID": "clases/19/index.html#bug2-con-fsm-1",
    "href": "clases/19/index.html#bug2-con-fsm-1",
    "title": "Robótica",
    "section": "Bug2 con fsm",
    "text": "Bug2 con fsm\n\nTabla de transición\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\gamma \\not\\approx 0\\)\n\\(\\gamma \\approx 0\\)\n\\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\approx 0\\)\n\\(R_\\textrm{F} &lt; d\\) \\[\\small \\begin{cases}R_\\textrm{F} &gt; d \\\\ R_\\textrm{FL} &gt; d \\\\ R_\\textrm{FR} &lt; d\\end{cases}\\]\n\\(\\boldsymbol{P} \\in \\overline{\\boldsymbol{P}_0 \\boldsymbol{G}}\\) \\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\lVert \\boldsymbol{H} - \\boldsymbol{G} \\rVert\\)\n\n\n\n\nGirar al objetivo\nGirar al objetivo\nAvanzar\n-\n-\n-\n\n\nAvanzar\nGirar al objetivo\n-\nFinalizar\nRodear obstáculo\\(\\boldsymbol{H}:=\\boldsymbol{P}\\)\n-\n\n\nRodear obstáculo\n-\n-\nFinalizar\nRodear obstáculo\nGirar al objetivo"
  },
  {
    "objectID": "clases/19/index.html#bug2-con-fsm-2",
    "href": "clases/19/index.html#bug2-con-fsm-2",
    "title": "Robótica",
    "section": "Bug2 con fsm",
    "text": "Bug2 con fsm\n\nMáquina de estado"
  },
  {
    "objectID": "clases/19/index.html#laboratorio-1",
    "href": "clases/19/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nImplementación Bug2 con fsm"
  },
  {
    "objectID": "clases/18/index.html#point-follower-con-evasión-de-obstáculos",
    "href": "clases/18/index.html#point-follower-con-evasión-de-obstáculos",
    "title": "Robótica",
    "section": "Point-follower con evasión de obstáculos",
    "text": "Point-follower con evasión de obstáculos\n\n\\[\n\\require{color}\n\\]\n\n\n\n\nDefinición del problema\n\n\nSea una posición y orientación arbitraria del robot \\(\\textcolor{Maroon}{\\boldsymbol{P}(t)}\\) en el tiempo \\(t\\)\nSea una posición objetivo \\(\\textcolor{Blue}{\\boldsymbol{G}}\\) en el tiempo incial \\(t_0\\)\nSe debe encontrar una ley que mediante una serie de controles \\(\\textcolor{ForestGreen}{\\nu(t)}\\) y \\(\\textcolor{Orange}{\\omega(t)}\\) conduzca el robot del punto inicial \\(\\textcolor{Maroon}{\\boldsymbol{P}(t_0)}\\) al punto objetivo \\(\\textcolor{Blue}{\\boldsymbol{G}}\\) mientras se evaden los obstáculos"
  },
  {
    "objectID": "clases/18/index.html#point-follower-con-evasión-de-obstáculos-1",
    "href": "clases/18/index.html#point-follower-con-evasión-de-obstáculos-1",
    "title": "Robótica",
    "section": "Point-follower con evasión de obstáculos",
    "text": "Point-follower con evasión de obstáculos\n\nEnfoque: campos potenciales (existen muchos otros)\n\n\nBasado en conceptos físicos: carga eléctrica, potencial eléctrico y ppio. de superposición\nDos alternativas:\n\nOff-line (con memoria o mapa)\nOn-line (dinámico sin memoria)"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-matemáticos",
    "href": "clases/18/index.html#revisión-conceptos-matemáticos",
    "title": "Robótica",
    "section": "Revisión conceptos matemáticos",
    "text": "Revisión conceptos matemáticos\n\n\n\nFunción \\(\\boldsymbol{\\mathcal{f}}: \\mathbb{R} \\to \\mathbb{R}\\) asocia a cada punto un valor escalar\n\n\nDerivada de la función \\(d \\boldsymbol{\\mathcal{f}}\\) es la pendiente de la recta tangente en un punto \\(p\\) que indica la tasa de cambio de la función en dicho punto"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-matemáticos-1",
    "href": "clases/18/index.html#revisión-conceptos-matemáticos-1",
    "title": "Robótica",
    "section": "Revisión conceptos matemáticos",
    "text": "Revisión conceptos matemáticos\n\n\n\nCampo escalar: una función que a cada punto en una región del espacio le asocia un valor escalar \\[\\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}\\]\n\n\n\n\n\n\n\n\nCampo vectorial: una función que a cada punto en una región del espacio le asocia un valor vectorial \\[\\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}^{n}\\]"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-matemáticos-2",
    "href": "clases/18/index.html#revisión-conceptos-matemáticos-2",
    "title": "Robótica",
    "section": "Revisión conceptos matemáticos",
    "text": "Revisión conceptos matemáticos\n\n\n\nCampo escalar: una función que a cada punto en una región del espacio le asocia un valor escalar \\[\\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}\\]\n\n\n\n\n\n\n\n\nCampo vectorial: una función que a cada punto en una región del espacio le asocia un valor vectorial \\[\\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}^{n}\\]"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-matemáticos-3",
    "href": "clases/18/index.html#revisión-conceptos-matemáticos-3",
    "title": "Robótica",
    "section": "Revisión conceptos matemáticos",
    "text": "Revisión conceptos matemáticos\n\nPara una función escalar \\(\\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}\\) el gradiente \\(\\nabla \\boldsymbol{\\mathcal{f}} : \\mathbb{R}^{n} \\to \\mathbb{R}^n\\) es tal que evaluado en un punto \\(\\boldsymbol{p} = (x_1, x_2, \\dots , x_n)\\) indica la dirección en la que la función \\(\\boldsymbol{\\mathcal{f}}\\) aumenta más rápidamente desde \\(p\\), y su módulo representa la tasa de variación de \\(\\boldsymbol{\\mathcal{f}}\\) en la dirección del vector gradiente.\n\n\\[\n\\nabla \\mathcal{f}(\\boldsymbol{p}) =\n\\begin{bmatrix}\n\\frac{\\partial \\mathcal{f}}{\\partial x_1} (\\boldsymbol{p}) \\\\\n\\frac{\\partial \\mathcal{f}}{\\partial x_2} (\\boldsymbol{p}) \\\\\n\\vdots\\\\\n\\frac{\\partial \\mathcal{f}}{\\partial x_n} (\\boldsymbol{p}) \\\\\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-matemáticos-4",
    "href": "clases/18/index.html#revisión-conceptos-matemáticos-4",
    "title": "Robótica",
    "section": "Revisión conceptos matemáticos",
    "text": "Revisión conceptos matemáticos\n\n\n\nCampo escalar \\(f(x,y)\\)\nLas flechas representan el gradiente \\(\\nabla f(x,y)\\)\nApuntan en la dirección de mayor crecimiento"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos",
    "href": "clases/18/index.html#revisión-conceptos-físicos",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\n\nCampo eléctrico de una carga puntual\n\n\nSea en el punto de origen \\(\\mathcal{O}\\) una carga \\(q\\) y el punto \\(P\\) donde se desea determinar el campo\nSea el vector distancia \\(\\vec{\\boldsymbol{r}} = \\overrightarrow{\\mathcal{O} P}\\), y el vector unitario asociado \\(\\hat{\\boldsymbol{r}} = \\vec{\\boldsymbol{r}} / r\\) donde \\(r = \\lVert\\vec{\\boldsymbol{r}}\\rVert\\)\nLa dirección y magnitud del campo \\(\\vec{\\boldsymbol{E}} (q, \\vec{\\boldsymbol{r}})\\) se define como\n\n\n\n\\[\n\\vec{\\boldsymbol{E}} = \\underbrace{\\frac{1}{4 \\pi \\epsilon_0}}_{\\textrm{constante}} \\cdot \\overbrace{\\frac{q}{r^2}}^{\\textrm{magnitud}} \\cdot \\underbrace{\\hat{\\boldsymbol  {r}}}_{\\textrm{dirección}}\n\\]\n\n\n\nLa magnitud es proporcional al tamaño de la carga \\(q\\) e inversamente proporcional al cuadrado de la distancia (\\(r^2\\))"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-1",
    "href": "clases/18/index.html#revisión-conceptos-físicos-1",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nCampo eléctrico de una carga puntual\n\n\n\n\n\n\nApunta alejandose de la carga\n\n\n\n\n\n\nApunta acercándose a la carga"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-2",
    "href": "clases/18/index.html#revisión-conceptos-físicos-2",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nPrincipio de superposición de campos eléctricos\n\n\n\n\nEl efecto de múltiples cargas es la suma vectorial de los campos debido a cada carga puntual\n\n\\[\n\\vec{\\boldsymbol{E}_T} = \\vec{\\boldsymbol{E}_1} + \\vec{\\boldsymbol{E}_2} + \\vec{\\boldsymbol{E}_3} + \\dots\n\\]"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-3",
    "href": "clases/18/index.html#revisión-conceptos-físicos-3",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nLínea de campo eléctrico\n\n\n\n\nCurva imaginaria tangente en cualquier punto a la dirección del vector \\(\\vec{\\boldsymbol{E}}\\)\nSe alejan de las cargas positivas y van hacia las cargas negativas\nNunca se cruzan"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-4",
    "href": "clases/18/index.html#revisión-conceptos-físicos-4",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nLínea de campo eléctrico\n\n\n\n\nCurva imaginaria tangente en cualquier punto a la dirección del vector \\(\\vec{\\boldsymbol{E}}\\)\nSe alejan de las cargas positivas y van hacia las cargas negativas\nNunca se cruzan"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-5",
    "href": "clases/18/index.html#revisión-conceptos-físicos-5",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nEnergía potencial eléctrica\n\n\nPara multiples cargas puntuales, la energía potencial asociada a la carga de prueba \\(q_0\\) es la suma algebraica\n\n\\[\nU = \\frac{q_0}{4 \\pi \\epsilon_0} \\sum_{i} \\frac{q_i}{r_i}\n\\]\ndonde \\(r_i\\) es la distancia entre la carga \\(q_0\\) y \\(q_1\\)"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-6",
    "href": "clases/18/index.html#revisión-conceptos-físicos-6",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nPotencial eléctrico\n\n\nSe define el potencial \\(V\\) como la energía potencial \\(U\\) por unidad de carga\n\n\\[\nV = \\frac{U}{q_0}\n\\]\n\nPara calcular el potencial debido a un conjunto de cargas puntuales:\n\n\\[\nV = \\frac{1}{4 \\pi \\epsilon_0} \\sum_{i} \\frac{q_i}{r_i}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-7",
    "href": "clases/18/index.html#revisión-conceptos-físicos-7",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nSuperficies equipotenciales\n\n\n\n\nSuperficie en la cual el potencial eléctrico \\(V\\) es el mismo\nSe asemejan a curvas de nivel en un mapa topográfico\n\n\n\n\n\n\n\nLas líneas de campo y las superﬁcies equipotenciales siempre son perpendiculares entre sí"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-8",
    "href": "clases/18/index.html#revisión-conceptos-físicos-8",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nSuperficies equipotenciales\n\n\n\n\nSuperficie en la cual el potencial eléctrico \\(V\\) es el mismo\nSe asemejan a curvas de nivel en un mapa topográfico\n\n\n\n\n\n\n\nLas líneas de campo y las superﬁcies equipotenciales siempre son perpendiculares entre sí"
  },
  {
    "objectID": "clases/18/index.html#revisión-conceptos-físicos-9",
    "href": "clases/18/index.html#revisión-conceptos-físicos-9",
    "title": "Robótica",
    "section": "Revisión conceptos físicos",
    "text": "Revisión conceptos físicos\n\nGradiente potencial\n\n\nEl campo \\(\\vec{\\boldsymbol{E}}\\) es igual al gradiente negativo de \\(V\\)\n\n\\[\n\\vec{\\boldsymbol{E}} = - \\vec{\\nabla} V\n\\]\n\nPara el caso de un campo tri-dimensional, donde \\(\\vec{\\boldsymbol{E}} = \\hat{\\boldsymbol{\\mathcal{i}}} E_x + \\hat{\\boldsymbol{\\mathcal{j}}} E_y + \\hat{\\boldsymbol{\\mathcal{k}}} E_z\\):\n\n\\[\n\\vec{\\boldsymbol{E}} =\n\\begin{bmatrix}\nE_x \\\\\nE_y \\\\\nE_z\n\\end{bmatrix} =\n\\begin{bmatrix}\n\\frac{\\partial V}{\\partial x}\\\\\n\\frac{\\partial V}{\\partial y} \\\\\n\\frac{\\partial V}{\\partial z}\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#campos-potenciales-artificiales-1",
    "href": "clases/18/index.html#campos-potenciales-artificiales-1",
    "title": "Robótica",
    "section": "Campos potenciales artificiales",
    "text": "Campos potenciales artificiales\n\n\n\nConstruir un campo potencial \\(\\mathcal{C}\\) donde el robot sea representado como una carga \\(q^+\\)\n\nAtraído por el objetivo \\(\\boldsymbol{G}\\) (\\({q_G}^-\\))\nRepelido por la región del obstáculo \\(\\mathcal{C}_O\\) (\\({q_O}^+\\))\n\n\n\nPor ppio. de superposición el campo total \\(U\\) será la suma de los potenciales de atracción y repulsión"
  },
  {
    "objectID": "clases/18/index.html#campos-potenciales-artificiales-2",
    "href": "clases/18/index.html#campos-potenciales-artificiales-2",
    "title": "Robótica",
    "section": "Campos potenciales artificiales",
    "text": "Campos potenciales artificiales\n\nEl gradiente negativo \\(-\\vec{\\nabla} U(\\boldsymbol{P})\\) indicará la dirección de movimiento más prometedora"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo",
    "href": "clases/18/index.html#potencial-atractivo",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\nObjetivo: guiar al robot al punto objetivo \\(\\boldsymbol{G}\\)\n\n\nSea la distancia entre el robot en \\(\\boldsymbol{P}\\) y el punto objetivo \\(\\boldsymbol{G}\\):\n\n\\[\n\\boldsymbol{e}(\\boldsymbol{P}) =\n\\begin{bmatrix}\ne_x \\\\\ne_y \\\\\n\\end{bmatrix}\n= \\boldsymbol{P} - \\boldsymbol{G} =\n\\begin{bmatrix}\nx_\\boldsymbol{P} - x_\\boldsymbol{G} \\\\\ny_\\boldsymbol{P} - y_\\boldsymbol{G} \\\\\n\\end{bmatrix}\n\\]\n\nSe define la magnitud de \\(\\boldsymbol{e}(\\boldsymbol{P})\\)\n\n\\[\n\\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert =  \\sqrt{(x_\\boldsymbol{P} - x_\\boldsymbol{G})^2 + (y_\\boldsymbol{P} - y_\\boldsymbol{G})^2}\\\\\n\\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2 =  (x_\\boldsymbol{P} - x_\\boldsymbol{G})^2 + (y_\\boldsymbol{P} - y_\\boldsymbol{G})^2 = \\boldsymbol{e}^\\top \\boldsymbol{e}\\\\\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo-1",
    "href": "clases/18/index.html#potencial-atractivo-1",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\nObjetivo: guiar al robot al punto objetivo \\(\\boldsymbol{G}\\)\n\nDos ejemplos para \\(\\mathcal{C}\\) en \\(\\mathbb{R}^2\\):\n\nLineal con la distancia:\n\n\\[\nU^{A}(\\boldsymbol{P}) = \\alpha \\cdot \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert\n\\]\n\nCuadrático con la distancia:\n\n\\[\nU^{B}(\\boldsymbol{P}) = \\alpha \\cdot \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo-2",
    "href": "clases/18/index.html#potencial-atractivo-2",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\nLineal o cónico (\\(\\alpha = k_a &gt; 0\\))\n\n\\[\nU^{A}(\\boldsymbol{P}) = k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert\n\\]\n\nFuerza de atracción resultante es constante\n\n\\[\n\\boldsymbol{F}^{A}(\\boldsymbol{P}) = - \\nabla U^{A}(\\boldsymbol{P}) = k_a \\underbrace{\\frac{\\boldsymbol{e}(\\boldsymbol{P})}{\\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert}}_{\\textrm{direccion}}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo-3",
    "href": "clases/18/index.html#potencial-atractivo-3",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\nCuadrático o paraboloide (\\(\\alpha = \\tfrac{1}{2} k_a &gt; 0\\))\n\n\\[\nU^{B}(\\boldsymbol{P}) = \\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2 = \\tfrac{1}{2} k_a {\\boldsymbol{e}(\\boldsymbol{P})}^\\top \\boldsymbol{e}(\\boldsymbol{P})\n\\]\n\nFuerza de atracción resultante es lineal en \\(\\boldsymbol{e}\\)\n\n\\[\n\\boldsymbol{F}^{B}(\\boldsymbol{P}) = - \\nabla U^{B}(\\boldsymbol{P}) = k_a \\boldsymbol{e}(\\boldsymbol{P})\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo-4",
    "href": "clases/18/index.html#potencial-atractivo-4",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\n\nCuál utilizar?\n\n\n\\(\\boldsymbol{F}^{B}\\) se comporta mejor en la vecindad de \\(\\boldsymbol{G}\\) que \\(\\boldsymbol{F}^{A}\\)\n\\(\\boldsymbol{F}^{B}\\) crece indefinidamente con \\(\\boldsymbol{e}\\), no así \\(\\boldsymbol{F}^{A}\\)\n\n\n\nUna solución conveniente sería combinar los dos perfiles\n\nLineal fuera del objetivo\nCuadrático cerca del objetivo\n\n\n\n\n\\[\nU_A (\\boldsymbol{P}) =\n\\begin{cases}\n\\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2  &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\nk_b \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho \\\\\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-atractivo-5",
    "href": "clases/18/index.html#potencial-atractivo-5",
    "title": "Robótica",
    "section": "Potencial atractivo",
    "text": "Potencial atractivo\n\n\nCuál utilizar?\n\n\nLa continuidad para \\(\\boldsymbol{F}^A(\\boldsymbol{P})\\) requiere que\n\n\\[\n\\lim_{ \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\to \\rho^- } U_A (\\boldsymbol{P}) = \\lim_{ \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\to \\rho^+ } U_A (\\boldsymbol{P})\n\\]\n\nPor lo que\n\n\\[\nk_a \\boldsymbol{e}(\\boldsymbol{P}) =  k_b \\frac{\\boldsymbol{e}(\\boldsymbol{P})}{\\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert} \\quad \\textrm{para} \\quad \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert = \\rho\n\\]\npor lo tanto \\(\\boxed{k_b = \\rho k_a}\\)"
  },
  {
    "objectID": "clases/18/index.html#potencial-repulsivo",
    "href": "clases/18/index.html#potencial-repulsivo",
    "title": "Robótica",
    "section": "Potencial repulsivo",
    "text": "Potencial repulsivo\n\nObjetivo: mantener el robot alejado de los obstáculos (zona \\(\\mathcal{C}^O\\))\n\n\nSe asume que \\(\\mathcal{C}^O\\) fue particionada en partes convexas \\(\\mathcal{C}_i^O\\) (a partir de ahora \\(\\mathcal{C}_i\\))\nPara cada \\(\\mathcal{C}_i\\) se define un campo de repulsión\n\n\\[\nU_{i}(\\boldsymbol{P}) =\n\\begin{cases}\n\\frac{k^R_{i}}{\\gamma} \\left( \\frac{1}{\\eta_i (\\boldsymbol{P})} - \\frac{1}{\\eta^0_{i}} \\right)^{\\gamma}  &\\textrm{si} \\; \\eta_i(\\boldsymbol{P}) \\leq \\eta^0_{i} \\\\\n0                        &\\textrm{si}  \\; \\eta_i(\\boldsymbol{P}) &gt; \\eta^0_{i}   \\\\\n\\end{cases}\n\\]\ndonde:\n\n\\(k^R_{i} &gt; 0\\) y \\(\\gamma \\in \\mathbb{Z}\\) son los parámetros de “forma” de la función\n\\(\\eta^0_{i}\\) es el límite del rango de influencia de \\(\\mathcal{C}_i\\)\n\\(\\eta_i (\\boldsymbol{P})\\) es el despeje entre el robot en \\(\\boldsymbol{P}\\) y el obstáculo \\(\\boldsymbol{O}_i\\)"
  },
  {
    "objectID": "clases/18/index.html#potencial-repulsivo-1",
    "href": "clases/18/index.html#potencial-repulsivo-1",
    "title": "Robótica",
    "section": "Potencial repulsivo",
    "text": "Potencial repulsivo\n\nAnálisis función de repulsión"
  },
  {
    "objectID": "clases/18/index.html#potencial-repulsivo-2",
    "href": "clases/18/index.html#potencial-repulsivo-2",
    "title": "Robótica",
    "section": "Potencial repulsivo",
    "text": "Potencial repulsivo\n\n\n\nSuperficies equipotenciales siguen la forma del obstáculo\nFuerzas repulsivas son ortogonales\nSe incrementan a medida que se acercan al obstáculo"
  },
  {
    "objectID": "clases/18/index.html#potencial-repulsivo-3",
    "href": "clases/18/index.html#potencial-repulsivo-3",
    "title": "Robótica",
    "section": "Potencial repulsivo",
    "text": "Potencial repulsivo\n\nLa fuerza de repulsión resultante queda definida como\n\n\\[\n\\boldsymbol{F}^{R}_i(\\boldsymbol{P}) = - \\nabla U^R_{i}(\\boldsymbol{P}) =\n\\begin{cases}\n\\frac{k^R_{i}}{\\eta_i^2 (\\boldsymbol{P})} \\left( \\frac{1}{\\eta_i (\\boldsymbol{P})} - \\frac{1}{\\eta^0_{i}} \\right)^{\\gamma - 1} \\nabla \\eta_i (\\boldsymbol{P})  &\\textrm{si} \\; \\eta_i(\\boldsymbol{P}) \\leq \\eta^0_{i} \\\\\n0                        &\\textrm{si}  \\; \\eta_i(\\boldsymbol{P}) &gt; \\eta^0_{i}   \\\\\n\\end{cases}\n\\]\n\n\\(\\boldsymbol{F}^{R}_i\\) es ortogonal a las superficies equipotenciales pasando a través de \\(\\boldsymbol{P}\\) y los puntos apuntando fuera del obstáculo\n\\(\\boldsymbol{F}^{R}_i\\) es continua gracias a la convexidad de la partición en \\(\\mathcal{C}^O\\)\nPor ppio. de superposición: \\[\nU_R (\\boldsymbol{P}) = \\sum_{i=1}^{m} U^R_{i}(\\boldsymbol{P})\n\\]"
  },
  {
    "objectID": "clases/18/index.html#potencial-total",
    "href": "clases/18/index.html#potencial-total",
    "title": "Robótica",
    "section": "Potencial total",
    "text": "Potencial total\n\n\n\n\nDado el potencial de atracción y el de repulsión, por principio de superposición:\n\n\\[\nU_T (\\boldsymbol{P}) = U_A (\\boldsymbol{P}) + U_R (\\boldsymbol{P})\n\\]\n\nEl campo de fuerza total \\(\\boldsymbol{F}_T\\) queda definido como:\n\n\\[\n\\begin{align*}\n\\boldsymbol{F}_T (\\boldsymbol{P}) &= - \\nabla U_T (\\boldsymbol{P}) \\\\\n\\boldsymbol{F}_T (\\boldsymbol{P}) &= \\boldsymbol{F}^A(\\boldsymbol{P}) + \\sum_{i=1}^{m} \\boldsymbol{F}^R_i(\\boldsymbol{P})\n\\end{align*}\n\\]\n\n\n\n\n\n\nLa fuerza total determinará la dirección y la velocidad de avance"
  },
  {
    "objectID": "clases/18/index.html#potencial-total-1",
    "href": "clases/18/index.html#potencial-total-1",
    "title": "Robótica",
    "section": "Potencial total",
    "text": "Potencial total"
  },
  {
    "objectID": "clases/18/index.html#fuerza-de-atracción",
    "href": "clases/18/index.html#fuerza-de-atracción",
    "title": "Robótica",
    "section": "Fuerza de atracción",
    "text": "Fuerza de atracción\n\\[\n\\boldsymbol{F}^A (\\boldsymbol{P}) =\n- \\nabla  U_A (\\boldsymbol{P}) = -\n\\begin{bmatrix}\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial x} \\\\\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial y}\n\\end{bmatrix}\n\\]\n\nEl gradiente en dirección \\(x\\): \\[\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial x} =\n\\begin{cases}\n\\frac{\\partial}{\\partial x} \\left( \\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2 \\right)  &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\n\\frac{\\partial}{\\partial x} \\left( \\rho k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\right) &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho\n\\end{cases}\n\\]\nEl gradiente en dirección \\(y\\): \\[\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial y} =\n\\begin{cases}\n\\frac{\\partial}{\\partial y} \\left( \\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2 \\right)  &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\n\\frac{\\partial}{\\partial y} \\left( \\rho k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\right) &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerza-de-atracción-1",
    "href": "clases/18/index.html#fuerza-de-atracción-1",
    "title": "Robótica",
    "section": "Fuerza de atracción",
    "text": "Fuerza de atracción\n\nEl gradiente de la función \\(\\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2\\) con respecto a \\(x\\):\n\n\\[\n\\frac{\\partial}{\\partial x} \\left( \\tfrac{1}{2} k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert^2 \\right) =\n\\tfrac{1}{2} k_a \\frac{\\partial}{\\partial x} \\left( {e_x}^2 + {e_y}^2 \\right) =\n\\tfrac{1}{2} k_a \\left( 2 e_x \\right) =\nk_a e_x\n\\]\n\nEl gradiente de la función \\(\\rho k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert\\) con respecto a \\(x\\):\n\n\\[\n\\begin{align}\n\\frac{\\partial}{\\partial x} \\left( \\rho k_a \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\right) &=\n\\rho k_a \\frac{\\partial}{\\partial x} \\left( \\sqrt{{e_x}^2 + {e_y}^2} \\right) \\\\\n&= \\rho k_a \\frac{1}{2 \\sqrt{{e_x}^2 + {e_y}^2} } \\frac{\\partial}{\\partial x} \\left( {e_x}^2 + {e_y}^2 \\right) =\\\\\n&= \\rho k_a \\frac{1}{2 \\sqrt{{e_x}^2 + {e_y}^2} } \\left( 2 e_x \\right) = \\rho k_a \\frac{e_x}{\\lVert \\boldsymbol{e} \\rVert}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerza-de-atracción-2",
    "href": "clases/18/index.html#fuerza-de-atracción-2",
    "title": "Robótica",
    "section": "Fuerza de atracción",
    "text": "Fuerza de atracción\n\n\nReemplazando en el gradiente en dirección \\(x\\):\n\n\\[\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial x} =\n\\begin{cases}\nk_a e_x                                           &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\n\\rho k_a \\frac{e_x}{\\lVert \\boldsymbol{e} \\rVert} &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho\n\\end{cases}\n\\]\n\nLo mismo para el gradiente en dirección \\(y\\):\n\n\\[\n\\frac{\\partial U_A (\\boldsymbol{P}) }{\\partial y} =\n\\begin{cases}\nk_a e_y                                           &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\n\\rho k_a \\frac{e_y}{\\lVert \\boldsymbol{e} \\rVert} &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerza-de-atracción-3",
    "href": "clases/18/index.html#fuerza-de-atracción-3",
    "title": "Robótica",
    "section": "Fuerza de atracción",
    "text": "Fuerza de atracción\n\nCon ambos resultados\n\n\\[\n\\boldsymbol{F}^A =\n- \\nabla  U_A =\n\\begin{cases}\n- k_a \\begin{bmatrix}\ne_y \\\\\ne_x\n\\end{bmatrix} &\\textrm{si} \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert \\leq \\rho \\\\\n- \\rho k_a \\frac{1}{\\lVert \\boldsymbol{e} \\rVert} \\begin{bmatrix}\ne_y \\\\\ne_x\n\\end{bmatrix} &\\textrm{si}  \\; \\lVert \\boldsymbol{e}(\\boldsymbol{P}) \\rVert &gt; \\rho\n\\end{cases}\n\\]\n\nReemplazando \\(\\boldsymbol{e}(\\boldsymbol{P}) = \\boldsymbol{P} - \\boldsymbol{G}\\):\n\n\\[\n\\boldsymbol{F}^A =\n- \\nabla  U_A =\n\\begin{cases}\n- k_a \\begin{bmatrix}\nx_\\boldsymbol{P} - x_\\boldsymbol{G} \\\\\ny_\\boldsymbol{P} - y_\\boldsymbol{G} \\\\\n\\end{bmatrix} &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\leq \\rho \\\\\n- \\rho k_a \\frac{1}{\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert} \\begin{bmatrix}\nx_\\boldsymbol{P} - x_\\boldsymbol{G} \\\\\ny_\\boldsymbol{P} - y_\\boldsymbol{G} \\\\\n\\end{bmatrix} &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &gt; \\rho\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerzas-de-repulsión",
    "href": "clases/18/index.html#fuerzas-de-repulsión",
    "title": "Robótica",
    "section": "Fuerzas de repulsión",
    "text": "Fuerzas de repulsión\n\nSe definen los siguientes parámetros para la función potencial de repulsión:\n\nExponente \\(\\gamma = 2\\)\nUn valor constante para \\(k^R_{i} = k_R\\)\nUn valor constante para \\(\\eta^0_{i} = \\eta_0\\)\n\n\n\\[\n\\boldsymbol{F}^{R}_i(\\boldsymbol{P}) = - \\nabla U^R_{i}(\\boldsymbol{P}) =\n\\begin{cases}\n\\frac{k_R}{\\eta_i^2 (\\boldsymbol{P})} \\left( \\frac{1}{\\eta_i (\\boldsymbol{P})} - \\frac{1}{\\eta_0} \\right) \\nabla \\eta_i (\\boldsymbol{P})  &\\textrm{si} \\; \\eta_i(\\boldsymbol{P}) \\leq \\eta_0 \\\\\n0                        &\\textrm{si}  \\; \\eta_i(\\boldsymbol{P}) &gt; \\eta_0   \\\\\n\\end{cases}\n\\]\n\nResta obtener la expresión de \\(\\nabla \\eta_i (\\boldsymbol{P})\\)"
  },
  {
    "objectID": "clases/18/index.html#fuerzas-de-repulsión-1",
    "href": "clases/18/index.html#fuerzas-de-repulsión-1",
    "title": "Robótica",
    "section": "Fuerzas de repulsión",
    "text": "Fuerzas de repulsión\n\nSea \\(\\eta_i (\\boldsymbol{P})\\) el despeje entre el robot en \\(\\boldsymbol{P}\\) y el punto más cercano \\(\\boldsymbol{O}_i\\) del obstáculo \\(\\mathcal{C}_i\\):\n\n\\[\n\\eta_i (\\boldsymbol{P}) = \\min_{\\boldsymbol{O}_i \\in \\mathcal{C}_i} \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert = \\sqrt{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})^2 + (y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})^2}\n\\]\n\nPor lo tanto:\n\n\\[\n\\begin{align*}\n\\frac{\\partial \\eta_i (\\boldsymbol{P}) }{\\partial x} =\n\\frac{\\partial}{\\partial x} \\left( \\sqrt{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})^2 + (y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})^2} \\right) &=\n%\\frac{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})}{\\sqrt{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})^2 + (y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})^2}} =\n\\frac{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})}{\\eta_i (\\boldsymbol{P})}\n\\\\\n\\frac{\\partial \\eta_i (\\boldsymbol{P}) }{\\partial y} =\n\\frac{\\partial}{\\partial y} \\left( \\sqrt{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})^2 + (y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})^2} \\right) &=\n%\\frac{(y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})}{\\sqrt{(x_\\boldsymbol{P} - x_{\\boldsymbol{O}_i})^2 + (y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})^2}} =\n\\frac{(y_\\boldsymbol{P} - y_{\\boldsymbol{O}_i})}{\\eta_i (\\boldsymbol{P})}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerzas-de-repulsión-2",
    "href": "clases/18/index.html#fuerzas-de-repulsión-2",
    "title": "Robótica",
    "section": "Fuerzas de repulsión",
    "text": "Fuerzas de repulsión\n\nQueda definido\n\n\\[\n\\nabla \\eta_i (\\boldsymbol{P}) =\n\\begin{bmatrix}\n\\frac{\\partial \\eta_i (\\boldsymbol{P}) }{\\partial x} \\\\\n\\frac{\\partial \\eta_i (\\boldsymbol{P}) }{\\partial y}\n\\end{bmatrix} =\n\\frac{1}{\\eta_i (\\boldsymbol{P})}\n\\begin{bmatrix}\nx_\\boldsymbol{P} - x_{\\boldsymbol{O}_i} \\\\\ny_\\boldsymbol{P} - y_{\\boldsymbol{O}_i}\n\\end{bmatrix}\n\\]\n\nReemplazando en la expresión de las fuerzas repulsivas \\(\\boldsymbol{F}^{R}_i(\\boldsymbol{P})\\)\n\n\\[\n\\boldsymbol{F}^{R}_i(\\boldsymbol{P}) = - \\nabla U^R_{i}(\\boldsymbol{P}) =\n\\begin{cases}\n\\frac{k_R}{\\eta_i^3 (\\boldsymbol{P})} \\left( \\frac{1}{\\eta_i (\\boldsymbol{P})} - \\frac{1}{\\eta_0} \\right) \\begin{bmatrix}\nx_\\boldsymbol{P} - x_{\\boldsymbol{O}_i} \\\\\ny_\\boldsymbol{P} - y_{\\boldsymbol{O}_i}\n\\end{bmatrix}  &\\textrm{si} \\; \\eta_i(\\boldsymbol{P}) \\leq \\eta_0 \\\\\n0                        &\\textrm{si}  \\; \\eta_i(\\boldsymbol{P}) &gt; \\eta_0   \\\\\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#fuerza-total",
    "href": "clases/18/index.html#fuerza-total",
    "title": "Robótica",
    "section": "Fuerza total",
    "text": "Fuerza total\n\nEl campo de fuerza total \\(\\boldsymbol{F}_T\\) queda definido como:\n\n\\[\n\\boldsymbol{F}_T = \\boldsymbol{F}^A + \\sum_{i=1}^{m} \\boldsymbol{F}^R_i\n\\]\ndonde:\n\\[\n\\begin{align*}\n\\boldsymbol{F}^A &=\n\\begin{cases}\n- k_a \\left( \\boldsymbol{P} - \\boldsymbol{G} \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\leq \\rho \\\\\n- \\rho k_a \\frac{\\boldsymbol{P} - \\boldsymbol{G}}{\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert} &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &gt; \\rho\n\\end{cases}\\\\[2em]\n\\boldsymbol{F}^{R}_i &=\n\\begin{cases}\n\\frac{k_R}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert^3} \\left( \\frac{1}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert} - \\frac{1}{\\eta_0} \\right) \\left( \\boldsymbol{P} - \\boldsymbol{O}_i \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert \\leq \\eta_0 \\\\\n0                        &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert &gt; \\eta_0   \\\\\n\\end{cases}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-1",
    "href": "clases/18/index.html#diseño-del-controlador-1",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\n\n\nSe deben diseñar dos señales de control \\(\\textcolor{ForestGreen}{\\nu(t)}\\) y \\(\\textcolor{Orange}{\\omega(t)}\\), que lleven el robot desde la posición actual a la posición objetivo\nDebido a las restricciones no-holonómicas la resultante \\(\\boldsymbol{F}_T\\) no puede imponerse directamente"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-2",
    "href": "clases/18/index.html#diseño-del-controlador-2",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\n\nEl modelo cinemático se puede expresar como \\(\\boldsymbol{\\dot{P}} = \\boldsymbol{\\mathcal{g}}(\\boldsymbol{P}) \\boldsymbol{u}\\)\n\n\\[\n\\underbrace{\n\\sideset{^I}{}{\n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{\\theta}\n\\end{bmatrix}}}_{\\boldsymbol{\\dot{P}}} =\n\\underbrace{\n\\begin{bmatrix}\n\\cos{\\theta} & 0\\\\\n\\sin{\\theta} & 0\\\\\n0            & 1\n\\end{bmatrix}}_{\\boldsymbol{g}(\\boldsymbol{P})}\n\\underbrace{\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}}_{\\boldsymbol{u}}\n\\]\n\nDado que \\(\\boldsymbol{g}_{n \\times m}\\) es rectangular con \\(n &gt; m\\), es imposible calcular \\(\\boldsymbol{u}\\) para un \\(\\boldsymbol{\\dot{P}}\\) deseado"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-3",
    "href": "clases/18/index.html#diseño-del-controlador-3",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\nSolución: obtener las velocidades factibles mediante una pseudoinversión\n\n\nSe propone utilizar una solución de mínimos cuadrados\n\n\\[\n\\boldsymbol{u} = \\boldsymbol{\\tilde{g}}(\\boldsymbol{P}) \\, \\boldsymbol{\\dot{P}} = \\boldsymbol{\\tilde{g}}(\\boldsymbol{P}) \\, \\boldsymbol{F}_T\n\\]\ndonde\n\\[\n\\boldsymbol{\\tilde{g}}(\\boldsymbol{P}) = \\left( \\boldsymbol{g}^\\top(\\boldsymbol{P}) \\boldsymbol{g}(\\boldsymbol{P}) \\right)^{-1}  \\boldsymbol{g}^\\top(\\boldsymbol{P})\n\\]\n\\[\n\\boldsymbol{g}(\\boldsymbol{P}) =\n\\begin{bmatrix}\n\\cos{\\theta} & 0\\\\\n\\sin{\\theta} & 0\\\\\n0            & 1\n\\end{bmatrix} \\quad \\to \\quad\n\\boldsymbol{\\tilde{g}}(\\boldsymbol{P}) =\n\\begin{bmatrix}\n\\cos{\\theta} & \\sin{\\theta} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-4",
    "href": "clases/18/index.html#diseño-del-controlador-4",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\nSolución: obtener las velocidades factibles mediante una pseudoinversión\n\n\\[\n\\boldsymbol{g} =\n\\begin{bmatrix}\n\\cos{\\theta} & 0\\\\\n\\sin{\\theta} & 0\\\\\n0            & 1\n\\end{bmatrix} \\quad\n\\boldsymbol{g}^\\top =\n\\begin{bmatrix}\n\\cos{\\theta} & \\sin{\\theta} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]\n\\[\n\\boldsymbol{g}^\\top \\, \\boldsymbol{g} =\n\\begin{bmatrix}\n\\cos{\\theta} & \\sin{\\theta} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\cos{\\theta} & 0\\\\\n\\sin{\\theta} & 0\\\\\n0            & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n\\cos^2{\\theta} + \\sin^2{\\theta} & 0\\\\\n0 & 1\n\\end{bmatrix} =\n\\begin{bmatrix}\n1 & 0\\\\\n0 & 1\n\\end{bmatrix} = \\mathbb{I}\n\\]\n\\[\n\\left( \\boldsymbol{g}^\\top \\, \\boldsymbol{g} \\right)^{-1}  = \\mathbb{I}^{-1} = \\mathbb{I}\n\\]\n\\[\n\\left( \\boldsymbol{g}^\\top \\, \\boldsymbol{g} \\right)^{-1} \\boldsymbol{g}^\\top = \\mathbb{I} \\, \\boldsymbol{g}^\\top = \\boldsymbol{g}^\\top =\n\\begin{bmatrix}\n\\cos{\\theta} & \\sin{\\theta} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-5",
    "href": "clases/18/index.html#diseño-del-controlador-5",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\nReemplazando\n\n\\[\n\\boldsymbol{u} = \\boldsymbol{\\tilde{g}}(\\boldsymbol{P}) \\, \\boldsymbol{F}_T =\n\\begin{bmatrix}\n\\cos{\\theta} & \\sin{\\theta} & 0\\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\, \\boldsymbol{F}_T\n\\]\n\nPor lo tanto, la solución por mínimos cuadrados para una fuerza artificial \\(\\boldsymbol{F}_T = \\left[{F_T}_x , {F_T}_y , {F_T}_\\theta \\right]^\\top\\) es\n\n\\[\n\\boldsymbol{u}\n\\begin{cases}\n\\nu =  {F_T}_x \\cos{\\theta} + {F_T}_y \\sin{\\theta} \\\\\n\\omega = {F_T}_\\theta\n\\end{cases}\n\\]\n\nSe puede interpretar \\(\\nu\\) como la proyección de la fuerza \\(\\boldsymbol{F}_T\\) sobre el eje del robot \\(\\boldsymbol{X_R}\\)"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-6",
    "href": "clases/18/index.html#diseño-del-controlador-6",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\n\n\nEl campo potencial no produce una “componente giratoria” \\({F_T}_\\theta\\)\nEste grado de libertad puede utilizarse para forzar al robot a alinearse con el campo vectorial \\(\\boldsymbol{F}_T\\)\n\n\\[\n\\omega = {F_T}_\\theta = k_\\theta (\\theta_{\\boldsymbol{F}_T} - \\theta) %\\quad \\textrm{con} \\quad \\theta_{\\boldsymbol{F}_T} = \\arctan 2 \\left( {F_T}_y , {F_T}_x \\right)\n\\]\ndonde\n\\[\n\\theta_{\\boldsymbol{F}_T} = \\arctan 2 \\left( {F_T}_y , {F_T}_x \\right)\n\\]"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-8",
    "href": "clases/18/index.html#diseño-del-controlador-8",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\nValores de la función \\(\\arctan2(x, y)\\): discontinuidad en \\(\\pm \\pi\\)"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-9",
    "href": "clases/18/index.html#diseño-del-controlador-9",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\n\n\nCasos particulares de \\(\\theta\\) y el ángulo de \\(\\boldsymbol{F}_T\\)\n\n\nCaso A:\n\n\\[\n\\begin{gather*}\n\\tfrac{\\pi}{2}  &lt;     \\theta                      \\leq  \\pi \\\\\n-\\pi            \\leq  \\theta_{\\boldsymbol{F}_T}   &lt;     -\\tfrac{\\pi}{2}\n\\end{gather*}\n\\]\n\\[\n(\\theta_{\\boldsymbol{F}_T} - \\theta) \\in \\left[ -2 \\pi ; -\\pi \\right) \\to \\omega \\ngtr 0\n\\]\nPor lo tanto se redefine \\[\n\\omega = k_\\theta ((\\theta_{\\boldsymbol{F}_T} + 2 \\pi) - \\theta)\n\\]\npara \\(\\boldsymbol{F}_T\\) en el 3er cuadrante y \\(\\boldsymbol{x}_R\\) en el 2do"
  },
  {
    "objectID": "clases/18/index.html#diseño-del-controlador-10",
    "href": "clases/18/index.html#diseño-del-controlador-10",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\n\n\nCasos particulares de \\(\\theta\\) y el ángulo de \\(\\boldsymbol{F}_T\\)\n\n\nCaso B:\n\n\\[\n\\begin{gather*}\n-\\pi            \\leq  \\theta                    &lt;     -\\tfrac{\\pi}{2}\\\\\n\\tfrac{\\pi}{2}  &lt;     \\theta_{\\boldsymbol{F}_T} \\leq  \\pi\n\\end{gather*}\n\\]\n\\[\n(\\theta_{\\boldsymbol{F}_T} - \\theta) \\in \\left[ 2 \\pi ; \\pi \\right) \\to \\omega \\nless 0\n\\]\nPor lo tanto se redefine \\[\n\\omega = k_\\theta (\\theta_{\\boldsymbol{F}_T} - (\\theta + 2 \\pi))\n\\]\npara \\(\\boldsymbol{F}_T\\) en el 2do cuadrante y \\(\\boldsymbol{x}_R\\) en el 3er"
  },
  {
    "objectID": "clases/18/index.html#implementación-1",
    "href": "clases/18/index.html#implementación-1",
    "title": "Robótica",
    "section": "Implementación",
    "text": "Implementación\n\n\n\nImplementación on-line\nGenerar un potencial repulsivo solo para obstáculos percibidos\n\n\\[\n\\eta_0 &lt; \\textcolor{ForestGreen}{L}\n\\]\n\nPara calcular la fuerza \\(\\boldsymbol{F}^{R}_i\\) solo es necesario conocer el despeje \\(\\eta_i\\) con respecto al obstáculo \\(i\\)"
  },
  {
    "objectID": "clases/18/index.html#mediciones-del-lidar",
    "href": "clases/18/index.html#mediciones-del-lidar",
    "title": "Robótica",
    "section": "Mediciones del LIDAR",
    "text": "Mediciones del LIDAR\n\n\n\nSea la posición del robot \\(\\textcolor{Maroon}{\\boldsymbol{r_P}}\\) y su orientación \\(\\textcolor{Orange}{\\theta}\\)\nDadas las mediciones del LIDAR \\(\\textcolor{Plum}{(d, \\alpha)}\\), es posible calcular la coordenada de \\(\\textcolor{Plum}{\\boldsymbol{O}}\\) en el marco inercial \\(\\textcolor{Blue}{\\left\\{\\boldsymbol{x}_I, \\boldsymbol{y}_I \\right\\}}\\)\n\n\\[\n\\begin{align*}\n\\textcolor{Plum}{x_\\boldsymbol{O}} &= \\textcolor{Maroon}{x_\\boldsymbol{P}} + \\textcolor{Plum}{d} \\cdot \\cos{(\\textcolor{ForestGreen}{\\gamma})}\\\\\n\\textcolor{Plum}{y_\\boldsymbol{O}} &= \\textcolor{Maroon}{y_\\boldsymbol{P}} + \\textcolor{Plum}{d} \\cdot \\sin{(\\textcolor{ForestGreen}{\\gamma})}\n\\end{align*}\n\\]\ndonde \\[\n\\textcolor{ForestGreen}{\\gamma} = \\textcolor{Orange}{\\theta} + \\textcolor{Plum}{\\alpha}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#mediciones-del-lidar-1",
    "href": "clases/18/index.html#mediciones-del-lidar-1",
    "title": "Robótica",
    "section": "Mediciones del LIDAR",
    "text": "Mediciones del LIDAR\n\n\n\nPara el caso de las fuerzas repulsivas el valor de \\(\\eta_i = \\lVert \\textcolor{Maroon}{\\boldsymbol{P}} - \\textcolor{Plum}{\\boldsymbol{O}_i} \\rVert\\) se corresponde directamente con el valor medido por el lidar \\(\\textcolor{Plum}{d}\\)\nSolo se debe calcular la posición en \\(\\textcolor{Blue}{\\boldsymbol{x}_I}\\) e \\(\\textcolor{Blue}{\\boldsymbol{y}_I}\\) para obtener el vector\n\n\\[\n\\overrightarrow{\\textcolor{Maroon}{\\boldsymbol{P}}\\textcolor{Plum}{\\boldsymbol{O}_i}} = \\textcolor{Maroon}{\\boldsymbol{P}} - \\textcolor{Plum}{\\boldsymbol{O}_i}\n\\]"
  },
  {
    "objectID": "clases/18/index.html#mediciones-del-lidar-2",
    "href": "clases/18/index.html#mediciones-del-lidar-2",
    "title": "Robótica",
    "section": "Mediciones del LIDAR",
    "text": "Mediciones del LIDAR\n\nEl análisis se realizó simplificando el robot a un punto en el espacio\nPara la implementación se debe tener en cuenta las dimensiones reales del robot\nModelo simple: Asumir una forma circular con radio \\(\\kappa\\) que abarque toda el perímetro\n\n\nLos campos potenciales de repulsión se pueden obtener simplemente expandiendo la silueta del obstáculo \\(\\kappa\\), lo mismo que disminuir el despeje \\(\\eta_i = d_i - \\kappa\\)"
  },
  {
    "objectID": "clases/18/index.html#problemas-de-los-campos-potenciales",
    "href": "clases/18/index.html#problemas-de-los-campos-potenciales",
    "title": "Robótica",
    "section": "Problemas de los campos potenciales",
    "text": "Problemas de los campos potenciales\n\nSe pueden identificar 4 problemas significativos\n\n\nNo permite el paso entre obstáculos poco espaciados\nOscilaciones producidas por obstáculos\nOscilaciones en pasajes angostos\n“Trampas” en mínimos locales"
  },
  {
    "objectID": "clases/18/index.html#obstáculos-poco-espaciados",
    "href": "clases/18/index.html#obstáculos-poco-espaciados",
    "title": "Robótica",
    "section": "Obstáculos poco espaciados",
    "text": "Obstáculos poco espaciados\n\nAl intentar pasar a través de dos obstáculos cercanos (Ej.: el marco de una puerta) las fuerzas repulsivas combinadas apuntan hacia afuera de la abertura\nDependiendo de la magnitud relativa de la fuerza de atracción \\(\\boldsymbol{F}^A\\), el robot la atravesará o se alejará"
  },
  {
    "objectID": "clases/18/index.html#oscilaciones-debido-a-obstáculos",
    "href": "clases/18/index.html#oscilaciones-debido-a-obstáculos",
    "title": "Robótica",
    "section": "Oscilaciones debido a obstáculos",
    "text": "Oscilaciones debido a obstáculos\n\n\n\nExisten casos donde el robot puede entrar en un comportamiento oscilatorio donde se acerca y se aleja de los obstáculos de forma inestable\n\n\nSolución: Filtro pasa bajo para el comando de velocidad angular"
  },
  {
    "objectID": "clases/18/index.html#oscilaciones-en-pasajes-angostos",
    "href": "clases/18/index.html#oscilaciones-en-pasajes-angostos",
    "title": "Robótica",
    "section": "Oscilaciones en pasajes angostos",
    "text": "Oscilaciones en pasajes angostos\n\n\n\nUn caso particular del anterior\nEl robot se ve afectado por fuerzas repulsivas opuestas de forma simultánea\n\n\nSolución: dammping o amortiguación para el comando de velocidad"
  },
  {
    "objectID": "clases/18/index.html#mínimos-locales",
    "href": "clases/18/index.html#mínimos-locales",
    "title": "Robótica",
    "section": "Mínimos locales",
    "text": "Mínimos locales\nSi el robot entra en un mínimo local \\(\\boldsymbol{P}_m\\) de \\(U_T\\) se detendrá\n\\[\n\\boldsymbol{F}_T (\\boldsymbol{P}_m) = -\\nabla U_T(\\boldsymbol{P}_m) = 0\n\\]"
  },
  {
    "objectID": "clases/18/index.html#mínimos-locales-1",
    "href": "clases/18/index.html#mínimos-locales-1",
    "title": "Robótica",
    "section": "Mínimos locales",
    "text": "Mínimos locales\n\nSolución: Campos rotacionales\n\n\nReemplazar o combinar la fuerza de repulsión por una que fuerce el robot a rodear el obstáculo\nCampos rotacionales:\n\n\\[\n\\boldsymbol{F}^V_i(\\boldsymbol{P}) = \\pm \\nabla \\times U^R_{i}(\\boldsymbol{P}) =\n\\pm \\begin{bmatrix}\n\\frac{\\partial U^R_{i}}{\\partial y} \\\\\n-\\frac{\\partial U^R_{i}}{\\partial x}\n\\end{bmatrix}\n\\]\n\nEl vector resultante es tangente a la superficie equipotencial"
  },
  {
    "objectID": "clases/18/index.html#mínimos-locales-2",
    "href": "clases/18/index.html#mínimos-locales-2",
    "title": "Robótica",
    "section": "Mínimos locales",
    "text": "Mínimos locales"
  },
  {
    "objectID": "clases/18/index.html#resumen-1",
    "href": "clases/18/index.html#resumen-1",
    "title": "Robótica",
    "section": "Resumen",
    "text": "Resumen\n\nEn resumen\n\n\n\n\nEl guiado del robot se realizará a partir de la resultante de la suma de 2 fuerzas\n\nUna de atracción hacia el punto objetivo\nUna de repulsión de los obstáculos\n\nMediante campos potenciales se construyeron las expresiones para ambas fuerzas"
  },
  {
    "objectID": "clases/18/index.html#resumen-2",
    "href": "clases/18/index.html#resumen-2",
    "title": "Robótica",
    "section": "Resumen",
    "text": "Resumen\n\nEn resumen\n\n\nLa expresión para la fuerza de atracción \\(\\boldsymbol{F}^A\\) tiene dos parámetros de ajuste:\n\n\\(k_a\\) para controlar la intensidad\n\\(\\rho\\) para definir el límite de linealidad\n\nLa expresión para la fuerza de repulsión \\(\\boldsymbol{F}^{R}_i\\) tiene dos parámetros de ajuste:\n\n\\(k_R\\) para controlar la intensidad\n\\(\\eta_0\\) para definir el límite de influencia de los obstáculos"
  },
  {
    "objectID": "clases/18/index.html#resumen-3",
    "href": "clases/18/index.html#resumen-3",
    "title": "Robótica",
    "section": "Resumen",
    "text": "Resumen\n\nEn resumen\n\n\nPara las expresiones de velocidad lineal \\(\\nu\\) y velocidad angular \\(\\omega\\) se optó por utilizar mínimos cuadrados\nLa expresión de \\(\\nu\\) se puede interpretar como la proyección de \\(\\boldsymbol{F}_T\\) sobre el eje del robot \\(\\boldsymbol{X_R}\\)\nLa expresión de \\(\\omega\\) se utilizó para forzar al robot a alinearse con el vector \\(\\boldsymbol{F}_T\\)\nAl calcular el ángulo de \\(\\boldsymbol{F}_T\\) como \\(\\arctan 2 \\left( {F_T}_y , {F_T}_x \\right)\\) hay que considerar ciertos casos especiales"
  },
  {
    "objectID": "clases/18/index.html#resumen-4",
    "href": "clases/18/index.html#resumen-4",
    "title": "Robótica",
    "section": "Resumen",
    "text": "Resumen\n\nEn resumen\n\n\n\n\nUtilizando un sensor LIDAR los cáculos de las fuerzas de repulsión \\(\\boldsymbol{F}^{R}_i\\) se simplifican\nGenerar fuerzas repulsivas solo para obstáculos percibidos (\\(\\eta_i &lt; L\\))\nTener en cuenta la forma del robot al calcular los despejes \\(\\eta_i\\)"
  },
  {
    "objectID": "clases/18/index.html#laboratorio-1",
    "href": "clases/18/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nPoint-follower con campo potencial artificial"
  },
  {
    "objectID": "clases/20/index.html#marcas-fiduciarias-1",
    "href": "clases/20/index.html#marcas-fiduciarias-1",
    "title": "Robótica",
    "section": "Marcas fiduciarias",
    "text": "Marcas fiduciarias\n\nObjeto dentro del campo de visión de una imágen utilizado como referencia o medida\n\n\n\nMúltiples aplicaciones\n\nMedicina: se necesita precisión menor a 1 [mm]\nRealidad aumentada: detectar superficies y orientaciones de forma correcta\nMetrología, fabricación de PCB, imprenta, entre otros\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nLos marcadores fiduciales representan una herramienta eficaz para solucionar estos problemas en diversas aplicaciones y tareas de visión artificial, como la detección de objetos, la estimación de la posición de la cámara y cualquier tarea que requiera una fuente robusta de características de imagen."
  },
  {
    "objectID": "clases/20/index.html#marcas-fiduciarias-2",
    "href": "clases/20/index.html#marcas-fiduciarias-2",
    "title": "Robótica",
    "section": "Marcas fiduciarias",
    "text": "Marcas fiduciarias\n\nAplicaciones en visión computacional y robótica\n\n\n\n\nPermiten un seguimiento 3D preciso para calcular la posición, la orientación y la escala de los objetos\nFormas con patrones específicos diseñados para una fácil detección en diferentes condiciones de iluminación, ángulos y distancias\nCada marcador forma parte de un sistema con un algoritmo de detección y una codificación\n\n\n\n\n\n\n\n\n\n\nLos marcadores fiduciales son objetos creados, como cuadrículas en blanco y negro, tableros de ajedrez o formas con patrones específicos. Estos marcadores se colocan en un entorno o escena para ayudar a los sistemas de imagen a encontrar puntos de referencia.\nEl término «fiducial» proviene del latín «fiducia», que significa confianza, reflejando su función como puntos de referencia fiables para mediciones espaciales.\nPrecisión: ofrece puntos de referencia confiables para un posicionamiento, alineación y seguimiento precisos. Esta característica mejora la precisión espacial en sistemas complejos como dispositivos de imagen, robots y plataformas de realidad aumentada.\nAutomatización: optimiza la calibración y la alineación. Esta propiedad de los marcadores fiduciales permite que las máquinas operen con mínima intervención humana en robótica y procesos de inspección automatizados.\nRepetibilidad: garantiza resultados consistentes en imágenes repetidas. Este caso de uso es vital en imágenes médicas, escaneo 3D y fabricación automatizada.\nSimplificación: facilita tareas como la detección de objetos, la reconstrucción 3D y la navegación espacial.\nSeguimiento en tiempo real: proporciona información instantánea para aplicaciones como la captura de movimiento, la navegación de drones y las simulaciones interactivas.\nRelación calidad-precio: ofrece soluciones asequibles y de alto valor para una funcionalidad y un rendimiento mejorados.\nEstas ventajas de los marcadores fiduciales los convierten en elementos invaluables tanto para la investigación como para las aplicaciones comerciales.\nUna vez aplicados y configurados correctamente, ayudan con el seguimiento, la localización, la calibración de cámaras y la detección de objetos en aplicaciones como la robótica, la realidad aumentada y la fabricación."
  },
  {
    "objectID": "clases/20/index.html#apriltags",
    "href": "clases/20/index.html#apriltags",
    "title": "Robótica",
    "section": "AprilTags",
    "text": "AprilTags\n\nSistema visual muy utilizado en realidad aumentada y robótica\n\n\n\n\nLos marcadores pueden ser creados desde cualquier impresora\nEl software de detección calcula con precisión la posición y orientación 3D, junto con su ID\nSe diseño para una fácil integración en aplicaciones y sistemas embebidos\nEl algoritmo de detección está implementado en C y disponible Python, Matlab, Java e iOS\n\n\n\n\n\n\n\n\n\nDesarrollado por APRIL Robotics Laboratory at the University of Michigan\nAprilTag library implementation defines standards on how sets of tags should be designed\nAprilTags have been in development since 2011, and have been refined over the years to increase the robustness and speed of detection"
  },
  {
    "objectID": "clases/20/index.html#apriltags-1",
    "href": "clases/20/index.html#apriltags-1",
    "title": "Robótica",
    "section": "AprilTags",
    "text": "AprilTags\n\nCódigo binario en 2D, como el código QR\nEstán diseñados para codificar muchos menos datos (entre 4 y 12 bits)\nPermite detectarlas con mayor robustez y desde mayores distancias\n\n\n\n\n\n\n\n\\(\\approx\\) 9bits de información\n\n\n\n\n\n\n\n50 caracteres\n\n\n\n\n\n\nA popular camera-based technology is AprilTag, a scanned image similar to a QR Code. Its effectiveness and quick set-up on custom Signal Sleeves led to wide adoption"
  },
  {
    "objectID": "clases/20/index.html#apriltags-36h11",
    "href": "clases/20/index.html#apriltags-36h11",
    "title": "Robótica",
    "section": "AprilTags 36h11",
    "text": "AprilTags 36h11\n\n\n\nGrilla de 6x6 pixeles, cada celda representando 1 bit\nBorde adicional en blanco y luego negro alrededor\nTeoricamente \\(2^{36} = 68.719.476.736\\) valores, pero solo se utilizan \\(587\\):\n\nRobustez ante errores de color (bit-flip)\nNo incluir patrones simples (cuadrados o rayas)\nGarantizar asimetría para excluir rotaciones ambiguas\n\n\n\n\n\n\n\nID: 42"
  },
  {
    "objectID": "clases/20/index.html#procesamiento",
    "href": "clases/20/index.html#procesamiento",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-1",
    "href": "clases/20/index.html#procesamiento-1",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-2",
    "href": "clases/20/index.html#procesamiento-2",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación\nUmbral adaptativo"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-3",
    "href": "clases/20/index.html#procesamiento-3",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación\nUmbral adaptativo\nSegmentación"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-4",
    "href": "clases/20/index.html#procesamiento-4",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación\nUmbral adaptativo\nSegmentación\nDetección de cuadriláteros"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-5",
    "href": "clases/20/index.html#procesamiento-5",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación\nUmbral adaptativo\nSegmentación\nDetección de cuadriláteros\nDecodificación de datos"
  },
  {
    "objectID": "clases/20/index.html#procesamiento-6",
    "href": "clases/20/index.html#procesamiento-6",
    "title": "Robótica",
    "section": "Procesamiento",
    "text": "Procesamiento\n\n\n\nEscala de grises + decimación\nUmbral adaptativo\nSegmentación\nDetección de cuadriláteros\nDecodificación de datos\nResultado final\n\n\n\n\n\nhttps://docs.wpilib.org/en/stable/docs/software/vision-processing/apriltag/apriltag-intro.html#processing-technique"
  },
  {
    "objectID": "clases/20/index.html#apriltag_ros",
    "href": "clases/20/index.html#apriltag_ros",
    "title": "Robótica",
    "section": "apriltag_ros",
    "text": "apriltag_ros\n\nPaquete para la detección de AprilTags en tiempo real\n\n\nNodo para procesar imágenes con el algoritmo AprilTag 3\nSoporta múltiples familias de tags\nPublica poses 3D y transformaciones tf2 de cada etiqueta detectada\nInstalación:\n  $ sudo apt install ros-jazzy-apriltag-ros\n\n\n\n\n\n\n\n\n\n\ngraphname\n\n\n\nt___detections\n\n\n/detections\n\n\n\n\n\nt___camera_info\n\n\n/camera_info\n\n\n\n\n\nn___apriltag\n\n\n/apriltag\n\n\n\n\n\nt___camera_info-&gt;n___apriltag\n\n\n\n\n\nn___apriltag-&gt;t___detections\n\n\n\n\n\nn_n__tf\n\n\n\n\n\n/tf\n\n\n\n\n\nn___apriltag-&gt;n_n__tf\n\n\n\n\n\nn___ros_gz_bridge\n\n\n/ros_gz_bridge\n\n\n\n\n\nn___ros_gz_bridge-&gt;t___camera_info\n\n\n\n\n\nt___camera\n\n\n/camera\n\n\n\n\n\nn___ros_gz_bridge-&gt;t___camera\n\n\n\n\n\nt___camera-&gt;n___apriltag\n\n\n\n\n\n\n\n\nFigure 1"
  },
  {
    "objectID": "clases/20/index.html#nodo-apriltag_node",
    "href": "clases/20/index.html#nodo-apriltag_node",
    "title": "Robótica",
    "section": "Nodo apriltag_node",
    "text": "Nodo apriltag_node\n\nEjecución:\n  $ ros2 run apriltag_ros apriltag_node\nSuscribe:\n\n/image_rect de tipo sensor_msgs/Image\n/camera_info de tipo sensor_msgs/CameraInfo\n\nPublica:\n\n/detections de tipo apriltag_msgs/AprilTagDetectionArray\n/tf de tipo tf2_msgs/TFMessage"
  },
  {
    "objectID": "clases/20/index.html#mensajes-apriltagdetection",
    "href": "clases/20/index.html#mensajes-apriltagdetection",
    "title": "Robótica",
    "section": "Mensajes AprilTagDetection",
    "text": "Mensajes AprilTagDetection\n\nEl nodo publica un arreglo de todas las detecciones encontradas:\n\n\n\nAprilTagDetectionArray.msg\n\nstd_msgs/Header header\nAprilTagDetection[] detections      ⬅️\n\n\nPor cada detección se tienen los siguientes datos:\n\n\n\nAprilTagDetection.msg\n\nstring family\nint32 id\nint32 hamming\nfloat32 goodness\nfloat32 decision_margin\nPoint centre                    # Centro en coordenadas de píxeles (x,y)\nPoint[4] corners                # Esquinas de la etiqueta ((x1,y1),(x2,y2),...)\nfloat64[9] homography           # Matriz homográfica (para conversión a Pose 3D)\n\n\n\nfamily: Familia del tag detectado Ej.: tag36h11, tag25h9, etc.\nid: Identificador único dentro de la familia\nhamming: Número de bits distintos entre el tag detectado y la mejor coincidencia válida\ngoodness: Indica qué tan bien coincide el borde detectado con el borde esperado\ndecision_margin: Cuanto mayor, más clara la diferencia entre cuadrados blancos/negros\ncentre: Posición del centro del tag en la imagen\ncorners: Coordenadas de las 4 esquinas en pixeles\nhomography: Matriz que proyecta puntos del plano del tag -&gt; plano de la imagen"
  },
  {
    "objectID": "clases/20/index.html#nodo-apriltag_node-1",
    "href": "clases/20/index.html#nodo-apriltag_node-1",
    "title": "Robótica",
    "section": "Nodo apriltag_node",
    "text": "Nodo apriltag_node\n\nParámetros admitidos:\n\n\nfamily: Familia de etiquetas a detectar\nsize: Tamaño (por defecto) de las etiquetas\nmax_hamming: No aceptar etiquetasa con errores\ndetector:\n\ndecimate: Reducción de la resolución (min. \\(1.0\\))\nblur, refine y sharpening: Ajustar parámetros de la detección\ndebug: Mostrar resultados intermedios (False)\nthreads: Cantidad de hilos de CPU para detección (1)\n\npose_estimation_method: Algoritmo para estimar la Pose (pnp)\nimage_transport: Tipo de mensaje de imagen (raw o compressed)\n\n\nAdjustable Parameters\n\nDecimation: factor impacts how much the image is down-sampled before processing. Increasing it will increase detection speed, at the cost of not being able to see tags which are far away\nBlur: applies smoothing to the input image to decrease noise, which increases speed when fitting quads to pixels, at the cost of precision. For most good cameras, this may be left at zero.\nThreads changes the number of parallel threads which the algorithm uses to process the image. Certain steps may be sped up by allowing multithreading. In general, you want this to be approximately equal to the number of physical cores in your CPU, minus the number of cores which will be used for other processing tasks.\nTag size: https://github.com/AprilRobotics/apriltag#pose-estimation\n\nNote: The tag size should not be measured from the outside of the tag. The tag size is defined as the distance between the detection corners, or alternately, the length of the edge between the white border and the black border. The following illustration marks the detection corners with red Xs and the tag size with a red arrow for a tag from the 48h12Custom tag family."
  },
  {
    "objectID": "clases/20/index.html#nodo-apriltag_node-2",
    "href": "clases/20/index.html#nodo-apriltag_node-2",
    "title": "Robótica",
    "section": "Nodo apriltag_node",
    "text": "Nodo apriltag_node\n\nSe recomienda crear un archivo de configuración yaml en la carpeta config:\n\n\n\napriltag-config.yaml\n\napriltag:                 # Nombre del nodo\n  ros__parameters:\n    image_transport: raw \n    family: 36h11         # Familia de la etiqueta\n    size: 0.12            # Tamaño por defecto en metros\n    profile: false\n\n    # Ajuste de la detección\n    max_hamming: 0\n    detector:\n      threads: 1\n      decimate: 1.0       # Si la imágen tuviese mucha resolución se recominda reducir\n      blur: 0.0\n      refine: true\n      sharpening: 0.25\n      debug: false\n\n    pose_estimation_method: \"pnp\""
  },
  {
    "objectID": "clases/20/index.html#nodo-apriltag_node-3",
    "href": "clases/20/index.html#nodo-apriltag_node-3",
    "title": "Robótica",
    "section": "Nodo apriltag_node",
    "text": "Nodo apriltag_node\n\nAgregar al *.launch.py:\n\n    #.. \n    node_apriltag_detector = Node(\n        package = 'apriltag_ros',\n        executable = 'apriltag_node',\n        name = 'apriltag',\n        parameters = [\n            PathJoinSubstitution(\n              [FindPackageShare('&lt;NOMBRE_PAQUETE&gt;'), 'config', 'apriltag-config.yaml']\n            )\n        ],\n    )\n    #.."
  },
  {
    "objectID": "clases/20/index.html#imágen-rectificada",
    "href": "clases/20/index.html#imágen-rectificada",
    "title": "Robótica",
    "section": "Imágen rectificada",
    "text": "Imágen rectificada\n\nPara calcular correctamente la pose 3D del marcador se necesita trabajar con una imagen sin distorsión\nLas cámaras reales introducen distorsiones que deforman líneas rectas y afectan la geometría proyectada\nLa rectificación corrige esas deformaciones utilizando la calibración de la cámara\n\n\n\n\n\n\n\n\nSe utiliza el rectify_node del paquete image_proc\n\n\n\n\n\n\n\n\n\n\n\n\ngraphname\n\n\n\nt___camera_info\n\n\n/camera_info\n\n\n\n\n\nn___apriltag\n\n\n/apriltag\n\n\n\n\n\nt___camera_info-&gt;n___apriltag\n\n\n\n\n\nn___RectifyNode\n\n\n/RectifyNode\n\n\n\n\n\nt___camera_info-&gt;n___RectifyNode\n\n\n\n\n\nt___detections\n\n\n/detections\n\n\n\n\n\nn___apriltag-&gt;t___detections\n\n\n\n\n\nn_n__tf\n\n\n\n\n\n/tf\n\n\n\n\n\nn___apriltag-&gt;n_n__tf\n\n\n\n\n\nt___image_rect\n\n\n/image_rect\n\n\n\n\n\nn___RectifyNode-&gt;t___image_rect\n\n\n\n\n\nn___ros_gz_bridge\n\n\n/ros_gz_bridge\n\n\n\n\n\nn___ros_gz_bridge-&gt;t___camera_info\n\n\n\n\n\nt___camera\n\n\n/camera\n\n\n\n\n\nn___ros_gz_bridge-&gt;t___camera\n\n\n\n\n\nt___camera-&gt;n___RectifyNode\n\n\n\n\n\nt___image_rect-&gt;n___apriltag\n\n\n\n\n\n\n\n\nFigure 2"
  },
  {
    "objectID": "clases/20/index.html#launch-con-rectify_node",
    "href": "clases/20/index.html#launch-con-rectify_node",
    "title": "Robótica",
    "section": "Launch con rectify_node",
    "text": "Launch con rectify_node\n\n\nbringup.launch.py\n\n    #.. \n    node_image_proc = Node(\n        package = 'image_proc',\n        executable = 'rectify_node',\n        output = 'screen',\n        parameters = [{ 'use_sim_time': True }],\n        remappings=[\n            ('image', '/camera'),\n        ],\n    )\n    \n    apriltag_config_file = PathJoinSubstitution(\n        [FindPackageShare('&lt;NOMBRE_PAQUETE&gt;'), 'config', 'apriltag-config.yaml']\n    )\n    \n    node_apriltag_detector = Node(\n        package = 'apriltag_ros',\n        executable = 'apriltag_node',\n        name = 'apriltag',\n        output = 'screen',\n        parameters = [{ 'use_sim_time': True }, apriltag_config_file ],\n    )\n    #.."
  },
  {
    "objectID": "clases/20/index.html#entregable-2-1",
    "href": "clases/20/index.html#entregable-2-1",
    "title": "Robótica",
    "section": "Entregable 2",
    "text": "Entregable 2\nAplicación práctica para AprilTags"
  },
  {
    "objectID": "index.html#universidad-nacional-del-litoral-unl",
    "href": "index.html#universidad-nacional-del-litoral-unl",
    "title": "Robótica 2025",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/18/lab.html",
    "href": "clases/18/lab.html",
    "title": "Clase 18 - Laboratorio",
    "section": "",
    "text": "Implementar un controlador que dado un par de coordenadas objetivo envíe comandos de velocidad angular y velocidad lineal para conducir el robot a dicho punto\nA partir de las mediciones de LIDAR evadir obstáculos utilizando campos potenciales artificiales\n\n\n\n\n\nObtener la posición del robot \\(\\boldsymbol{P} = (x, y)\\) y la orientación \\(\\theta\\) en el marco de odometría\nDada las coordenadas del punto objetivo \\(\\boldsymbol{G}\\) y el parámetro \\(\\rho\\), calcular la fuerza de atracción \\(\\boldsymbol{F}^A\\)\n\n\\[\n\\boldsymbol{F}^A =\n\\begin{cases}\n- k_a \\left( \\boldsymbol{P} - \\boldsymbol{G} \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\leq \\rho \\\\\n- \\rho k_a \\frac{\\boldsymbol{P} - \\boldsymbol{G}}{\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert} &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &gt; \\rho\n\\end{cases}\n\\]\n\nDadas las mediciones del LIDAR realizar el procesamiento de las mismas\n\n\nPara identificar obstáculos, se realizará una segmentación a partir de discontinuidades en las mediciones. Es decir, si entre una medición \\(i\\) y una medición \\(i+n\\) existen mediciones de valor inf (es decir, rayos no reflejados) es que se produjo una espacio libre y la medición \\(i\\) pertenece a un obstáculo distinto de la medición \\(i+n\\).\n\n\nPara cada obstáculo, obtener la medición de menor distancia \\(\\textcolor{Plum}{d_i}\\), y mediante su ángulo \\(\\textcolor{Plum}{\\alpha}\\) correspondiente obtener las coordenadas de \\(\\textcolor{Plum}{\\boldsymbol{O}_i}\\) en el marco inercial\n\n\\[\n\\begin{align*}\n\\textcolor{Plum}{x_{\\boldsymbol{O}_i}} &= \\textcolor{Maroon}{x_\\boldsymbol{P}} + \\textcolor{Plum}{d_i} \\cdot \\cos{(\\textcolor{ForestGreen}{\\gamma_i})}\\\\\n\\textcolor{Plum}{y_{\\boldsymbol{O}_i}} &= \\textcolor{Maroon}{y_\\boldsymbol{P}} + \\textcolor{Plum}{d_i} \\cdot \\sin{(\\textcolor{ForestGreen}{\\gamma_i})}\n\\end{align*}\n\\]\ndonde \\[\n\\textcolor{ForestGreen}{\\gamma_i} = \\textcolor{Orange}{\\theta} + \\textcolor{Plum}{\\alpha_i}\n\\]\n\nCalcular la fuerza repulsiva para cada obstáculo\n\n\\[\n\\boldsymbol{F}^{R}_i =\n\\begin{cases}\n\\frac{k_R}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert^3} \\left( \\frac{1}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert} - \\frac{1}{\\eta_0} \\right) \\left( \\boldsymbol{P} - \\boldsymbol{O}_i \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert \\leq \\eta_0 \\\\\n0                        &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert &gt; \\eta_0   \\\\\n\\end{cases}\n\\]\ndonde \\(\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert\\) es la medición del LIDAR\n\nCalcular la fuerza total \\(\\boldsymbol{F}_T\\)\n\n\\[\n\\boldsymbol{F}_T = \\boldsymbol{F}^A + \\sum_{i=1}^{m} \\boldsymbol{F}^R_i\n\\]\n\nCalcular la componente angular \\({F_T}_\\theta\\)\n\n\\[\n{F_T}_\\theta = k_\\theta (\\theta_{\\boldsymbol{F}_T} - \\theta)\n\\]\ndonde\n\\[\n\\theta_{\\boldsymbol{F}_T} = \\arctan 2 \\left( {F_T}_y , {F_T}_x \\right)\n\\]\n\n\n\n\n\n\nConsiderar los casos especiales y la discontinuidad de la función \\(\\arctan2(x, y)\\)\n\n\n\n\nCalcular la velocidad angular y lineal\n\n\\[\n\\begin{cases}\n\\nu =  {F_T}_x \\cos{\\theta} + {F_T}_y \\sin{\\theta} \\\\\n\\omega = {F_T}_\\theta\n\\end{cases}\n\\]\n\n\n\n\nCree un nodo que reciba mediante parámetros las coordenadas del punto objetivo \\(\\boldsymbol{G} = (x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom\nObtenga las mediciones del LIDAR mediante el topic /scan de tipo LaserScan\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel\nParametrizar los coeficientes \\(k_a\\), \\(k_R\\) y \\(k_\\theta\\) junto con los parámetros \\(\\rho\\) y \\(\\eta_0\\) de las funciones potenciales\nUtilice dos parámetros adicionales, \\(\\nu_{max}\\) y \\(\\omega_{max}\\), para limitar el valor máximo de velocidad lineal y velocidad angular respectivamente\nUtilice un parámetro \\(\\epsilon_{tol}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo si\n\n\\[\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\epsilon_{tol}\n\\]\n\n\n\n\nCree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema, utilizando un mundo de Gazebo con obstáculos de prueba\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nRealizar diversas pruebas con distintas posiciones y orientaciones iniciales del robot, y además distintos puntos objetivo."
  },
  {
    "objectID": "clases/18/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/18/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 18 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/18/lab.html#algoritmo-para-el-campo-potencial-artificial",
    "href": "clases/18/lab.html#algoritmo-para-el-campo-potencial-artificial",
    "title": "Clase 18 - Laboratorio",
    "section": "",
    "text": "Obtener la posición del robot \\(\\boldsymbol{P} = (x, y)\\) y la orientación \\(\\theta\\) en el marco de odometría\nDada las coordenadas del punto objetivo \\(\\boldsymbol{G}\\) y el parámetro \\(\\rho\\), calcular la fuerza de atracción \\(\\boldsymbol{F}^A\\)\n\n\\[\n\\boldsymbol{F}^A =\n\\begin{cases}\n- k_a \\left( \\boldsymbol{P} - \\boldsymbol{G} \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\leq \\rho \\\\\n- \\rho k_a \\frac{\\boldsymbol{P} - \\boldsymbol{G}}{\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert} &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &gt; \\rho\n\\end{cases}\n\\]\n\nDadas las mediciones del LIDAR realizar el procesamiento de las mismas\n\n\nPara identificar obstáculos, se realizará una segmentación a partir de discontinuidades en las mediciones. Es decir, si entre una medición \\(i\\) y una medición \\(i+n\\) existen mediciones de valor inf (es decir, rayos no reflejados) es que se produjo una espacio libre y la medición \\(i\\) pertenece a un obstáculo distinto de la medición \\(i+n\\).\n\n\nPara cada obstáculo, obtener la medición de menor distancia \\(\\textcolor{Plum}{d_i}\\), y mediante su ángulo \\(\\textcolor{Plum}{\\alpha}\\) correspondiente obtener las coordenadas de \\(\\textcolor{Plum}{\\boldsymbol{O}_i}\\) en el marco inercial\n\n\\[\n\\begin{align*}\n\\textcolor{Plum}{x_{\\boldsymbol{O}_i}} &= \\textcolor{Maroon}{x_\\boldsymbol{P}} + \\textcolor{Plum}{d_i} \\cdot \\cos{(\\textcolor{ForestGreen}{\\gamma_i})}\\\\\n\\textcolor{Plum}{y_{\\boldsymbol{O}_i}} &= \\textcolor{Maroon}{y_\\boldsymbol{P}} + \\textcolor{Plum}{d_i} \\cdot \\sin{(\\textcolor{ForestGreen}{\\gamma_i})}\n\\end{align*}\n\\]\ndonde \\[\n\\textcolor{ForestGreen}{\\gamma_i} = \\textcolor{Orange}{\\theta} + \\textcolor{Plum}{\\alpha_i}\n\\]\n\nCalcular la fuerza repulsiva para cada obstáculo\n\n\\[\n\\boldsymbol{F}^{R}_i =\n\\begin{cases}\n\\frac{k_R}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert^3} \\left( \\frac{1}{\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert} - \\frac{1}{\\eta_0} \\right) \\left( \\boldsymbol{P} - \\boldsymbol{O}_i \\right) &\\textrm{si} \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert \\leq \\eta_0 \\\\\n0                        &\\textrm{si}  \\; \\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert &gt; \\eta_0   \\\\\n\\end{cases}\n\\]\ndonde \\(\\lVert \\boldsymbol{P} - \\boldsymbol{O}_i \\rVert\\) es la medición del LIDAR\n\nCalcular la fuerza total \\(\\boldsymbol{F}_T\\)\n\n\\[\n\\boldsymbol{F}_T = \\boldsymbol{F}^A + \\sum_{i=1}^{m} \\boldsymbol{F}^R_i\n\\]\n\nCalcular la componente angular \\({F_T}_\\theta\\)\n\n\\[\n{F_T}_\\theta = k_\\theta (\\theta_{\\boldsymbol{F}_T} - \\theta)\n\\]\ndonde\n\\[\n\\theta_{\\boldsymbol{F}_T} = \\arctan 2 \\left( {F_T}_y , {F_T}_x \\right)\n\\]\n\n\n\n\n\n\nConsiderar los casos especiales y la discontinuidad de la función \\(\\arctan2(x, y)\\)\n\n\n\n\nCalcular la velocidad angular y lineal\n\n\\[\n\\begin{cases}\n\\nu =  {F_T}_x \\cos{\\theta} + {F_T}_y \\sin{\\theta} \\\\\n\\omega = {F_T}_\\theta\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/18/lab.html#programación-del-nodo",
    "href": "clases/18/lab.html#programación-del-nodo",
    "title": "Clase 18 - Laboratorio",
    "section": "",
    "text": "Cree un nodo que reciba mediante parámetros las coordenadas del punto objetivo \\(\\boldsymbol{G} = (x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom\nObtenga las mediciones del LIDAR mediante el topic /scan de tipo LaserScan\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel\nParametrizar los coeficientes \\(k_a\\), \\(k_R\\) y \\(k_\\theta\\) junto con los parámetros \\(\\rho\\) y \\(\\eta_0\\) de las funciones potenciales\nUtilice dos parámetros adicionales, \\(\\nu_{max}\\) y \\(\\omega_{max}\\), para limitar el valor máximo de velocidad lineal y velocidad angular respectivamente\nUtilice un parámetro \\(\\epsilon_{tol}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo si\n\n\\[\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\epsilon_{tol}\n\\]"
  },
  {
    "objectID": "clases/18/lab.html#configuración-del-launch",
    "href": "clases/18/lab.html#configuración-del-launch",
    "title": "Clase 18 - Laboratorio",
    "section": "",
    "text": "Cree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema, utilizando un mundo de Gazebo con obstáculos de prueba\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nRealizar diversas pruebas con distintas posiciones y orientaciones iniciales del robot, y además distintos puntos objetivo."
  },
  {
    "objectID": "clases/19/lab.html",
    "href": "clases/19/lab.html",
    "title": "Clase 19 - Laboratorio",
    "section": "",
    "text": "Implementar un controlador que dado un par de coordenadas objetivo envíe comandos de velocidad angular y velocidad lineal para conducir el robot a dicho punto\nUtilizar como base el algoritmo Go-To-Point\nA partir de las mediciones de LIDAR evadir obstáculos utilizando el algoritmo de tipo Bug2\nUtilizar máquinas de estado finito para relacionar las entradas al sistema y las salidas de control\n\n\n\n\n\n\n\nPaso 1: El camino al objetivo está libre?\n\n✔️ Girar al objetivo y avanzar (Go-To-Point)\n❌ Continuar al paso 2\n\nPaso 2: Guardar la posición y rodear el obstáculo (Wall-follower)\nPaso 3: La posición actual cruza la recta?\n\n✔️ Si la distancia al objetivo es menor, volver al paso 1\n❌ El objetivo no puede alcanzarse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\gamma \\not\\approx 0\\)\n\\(\\gamma \\approx 0\\)\n\\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\approx 0\\)\n\\(R_\\textrm{F} &lt; d\\) \\(\\small \\begin{cases}R_\\textrm{F} &gt; d \\\\ R_\\textrm{FL} &gt; d \\\\ R_\\textrm{FR} &lt; d\\end{cases}\\)\n\\(\\boldsymbol{P} \\in \\overline{\\boldsymbol{P}_0 \\boldsymbol{G}}\\) \\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\lVert \\boldsymbol{H} - \\boldsymbol{G} \\rVert\\)\n\n\n\n\nGirar al objetivo\nGirar al objetivo\nAvanzar\n-\n-\n-\n\n\nAvanzar\nGirar al objetivo\n-\nFinalizar\nRodear obstáculo\\(\\boldsymbol{H}:=\\boldsymbol{P}\\)\n-\n\n\nRodear obstáculo\n-\n-\nFinalizar\nRodear obstáculo\nGirar al objetivo\n\n\n\n\n\n\n\n\nCree un nodo que reciba mediante parámetros las coordenadas del punto objetivo \\(\\boldsymbol{G} = (x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom. Calcule el error de posición \\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert\\) y orientación \\(\\theta\\) teniendo en cuenta la discontinuidad de la función \\(\\arctan2(\\cdot)\\)\nObtenga las mediciones del LIDAR mediante el topic /scan de tipo LaserScan. Segmente los puntos en las zonas correspondientes\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel\nParametrizar los coeficientes \\(\\epsilon_\\theta\\) y \\(d\\), para ajustar el curso del robot y la distancia al obstáculo respectivamente\nUtilice dos parámetros adicionales, \\(\\nu_{max}\\) y \\(\\omega_{max}\\), para limitar el valor máximo de velocidad lineal y velocidad angular respectivamente\nUtilice un parámetro \\(\\epsilon_{\\boldsymbol{P}}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo si\n\n\\[\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\epsilon_{\\boldsymbol{P}}\n\\]\n\n\n\n\nCree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema, utilizando un mundo de Gazebo con obstáculos de prueba\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nRealizar diversas pruebas con distintas posiciones y orientaciones iniciales del robot, y además de distintos puntos objetivo."
  },
  {
    "objectID": "clases/19/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/19/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 19 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/19/lab.html#algoritmo-bug2",
    "href": "clases/19/lab.html#algoritmo-bug2",
    "title": "Clase 19 - Laboratorio",
    "section": "",
    "text": "Paso 1: El camino al objetivo está libre?\n\n✔️ Girar al objetivo y avanzar (Go-To-Point)\n❌ Continuar al paso 2\n\nPaso 2: Guardar la posición y rodear el obstáculo (Wall-follower)\nPaso 3: La posición actual cruza la recta?\n\n✔️ Si la distancia al objetivo es menor, volver al paso 1\n❌ El objetivo no puede alcanzarse\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\\(\\gamma \\not\\approx 0\\)\n\\(\\gamma \\approx 0\\)\n\\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert \\approx 0\\)\n\\(R_\\textrm{F} &lt; d\\) \\(\\small \\begin{cases}R_\\textrm{F} &gt; d \\\\ R_\\textrm{FL} &gt; d \\\\ R_\\textrm{FR} &lt; d\\end{cases}\\)\n\\(\\boldsymbol{P} \\in \\overline{\\boldsymbol{P}_0 \\boldsymbol{G}}\\) \\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\lVert \\boldsymbol{H} - \\boldsymbol{G} \\rVert\\)\n\n\n\n\nGirar al objetivo\nGirar al objetivo\nAvanzar\n-\n-\n-\n\n\nAvanzar\nGirar al objetivo\n-\nFinalizar\nRodear obstáculo\\(\\boldsymbol{H}:=\\boldsymbol{P}\\)\n-\n\n\nRodear obstáculo\n-\n-\nFinalizar\nRodear obstáculo\nGirar al objetivo"
  },
  {
    "objectID": "clases/19/lab.html#programación-del-nodo",
    "href": "clases/19/lab.html#programación-del-nodo",
    "title": "Clase 19 - Laboratorio",
    "section": "",
    "text": "Cree un nodo que reciba mediante parámetros las coordenadas del punto objetivo \\(\\boldsymbol{G} = (x_G, y_G)\\) y ejecute el algoritmo de control a una frecuencia fija\nObtenga la posición del robot mediante el topic de odometría /odom. Calcule el error de posición \\(\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert\\) y orientación \\(\\theta\\) teniendo en cuenta la discontinuidad de la función \\(\\arctan2(\\cdot)\\)\nObtenga las mediciones del LIDAR mediante el topic /scan de tipo LaserScan. Segmente los puntos en las zonas correspondientes\nEscriba los comandos de velocidad lineal y angular en el topic /cmd_vel\nParametrizar los coeficientes \\(\\epsilon_\\theta\\) y \\(d\\), para ajustar el curso del robot y la distancia al obstáculo respectivamente\nUtilice dos parámetros adicionales, \\(\\nu_{max}\\) y \\(\\omega_{max}\\), para limitar el valor máximo de velocidad lineal y velocidad angular respectivamente\nUtilice un parámetro \\(\\epsilon_{\\boldsymbol{P}}\\) para configurar una tolerancia dentro de la cual se considerará alcanzado el punto objetivo si\n\n\\[\n\\lVert \\boldsymbol{P} - \\boldsymbol{G} \\rVert &lt; \\epsilon_{\\boldsymbol{P}}\n\\]"
  },
  {
    "objectID": "clases/19/lab.html#configuración-del-launch",
    "href": "clases/19/lab.html#configuración-del-launch",
    "title": "Clase 19 - Laboratorio",
    "section": "",
    "text": "Cree un archivo go_to_point.launch.py donde cargue la simulación y todo el sistema, utilizando un mundo de Gazebo con obstáculos de prueba\nConfigure adecuadamente los parámetros del controlador para poder alcanzar distintos puntos objetivo\nRealizar diversas pruebas con distintas posiciones y orientaciones iniciales del robot, y además de distintos puntos objetivo."
  },
  {
    "objectID": "clases/index.html",
    "href": "clases/index.html",
    "title": "Clases",
    "section": "",
    "text": "Note\n\n\n\nEl siguiente cronograma podrá ser actualizado con el correr del cursado\n\n\n\n\n\n\n\n\n\n\n\n\n\nSemana\nFecha\nTema\nSlides\nLab\nT.R\n\n\n\n\n1\n17/03\nIntroducción a la Robótica. Organización de la materia. Herramientas de trabajo.\n🖥️\n\n\n\n\n2\n24/03\nFeriado 24 de Marzo - Día nacional de la memoria por la verdad y la justicia\n\n\n\n\n\n3\n31/03\nROS2: Definición y propósito. Conceptos básicos (nodos, topics, mensajes). Instalación y ejemplos básicos.\n🖥️\n🧪\n\n\n\n4\n07/04\nROS2: Componentes adicionales (contexto, parámetros, servicios). Paquete y librerías. Ejercicios de aplicación.\n🖥️\n🧪\n\n\n\n5\n14/04\nRevisión conceptos clase anterior. Programación de nodos, compilación y ejecución.\n🖥️\n🧪\n\n\n\n6\n21/04\nProgramación Orientada a Objetos aplicada en ROS2. Ejemplos de aplicación.\n🖥️\n🧪\n\n\n\n7\n28/04\nParámetros en nodos y roslaunch, programación y ventajas de uso en proyectos de ROS2. Logging. Práctica integradora unidad 1.\n🖥️\n🧪\n\n\n\n8\n05/05\nTraslación y rotación 2D. Transformaciones homogéneas. ROS2 R.E.P. y paquete tf2.\n🖥️\n🧪\n\n\n\n9\n12/05\nU.R.D.F: Representación de geometría de un robot. Uso de XACRO, robot_state_publisher y tf2.\n🖥️\n\n🛠️\n\n\n10\n19/05\nGazebo: Entorno de simulación. Uso conjunto con ROS2. Paquete ros2_control y gz_ros2_contol. Hardware interface y controladores.\n🖥️\n\n🛠️\n\n\n11\n26/05\nCinemática y locomoción: modelo cinemático de un robot diferencial. Cinemática inversa y directa.\n🖥️\n\n🛠️\n\n\n12\n02/06\nOdometría: Cálculo de posición en base al modelo cinemático directo.\n🖥️\n\n🛠️\n\n\n13\n09/06\nPercepción: sensores. Clasificación y caracterización. Tipos y ejemplos según variable a medir.\n🖥️\n\n\n\n\n14\n16/06\nFeriado 17 de Junio - Paso a la inmortalidad del Gral. Martín de Güemes (trasladable, 16 de junio)\n\n\n\n\n\n15\n23/06\nPresentación entregable 1\n\n\n\n\n\n16\n13/08\nSimulación de sensores en Gazebo\n🖥️\n🧪\n\n\n\n17\n20/08\nRevisión entregable 1\n🖥️\n\n\n\n\n19\n03/09\nCaso práctico simulación de sensors. Cámara. Seguidor de línea.\n🖥️\n🧪\n\n\n\n20\n10/09\nCaso práctico simulación de sensors (cont.)\n\n\n\n\n\n21\n17/09\nLocalización con odometría. Incertidumbre y estimación de posición.\n🖥️\n🧪\n\n\n\n23\n01/10\nDiseño, análisis e implementación de un controlador a lazo cerrado, sin evasión de obstáculos\n🖥️\n🧪\n\n\n\n25\n15/10\nDiseño, análisis e implementación de un controlador a lazo cerrado, con evasión de obstáculos\n🖥️\n🧪\n\n\n\n27\n29/10\nCognición: Programación de comportamiento. Máquinas de estados finitos\n🖥️\n🧪\n\n\n\n30\n19/11\nMarcas fiduciarias y etiquetas visuales. Caso práctico con AprilTags\n🖥️"
  },
  {
    "objectID": "clases/index.html#universidad-nacional-del-litoral-unl",
    "href": "clases/index.html#universidad-nacional-del-litoral-unl",
    "title": "Clases",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/08/tres.html",
    "href": "clases/08/tres.html",
    "title": "Clase 08 - Taller de resolución",
    "section": "",
    "text": "Etiqueta raíz (todo el contenido se encuentra dentro)\n\n&lt;?xml version=\"1.0\"?&gt;\n\n&lt;robot name=\"mi_robot\"&gt;\n    ...\n    &lt;!-- Contenido URDF --&gt;\n    ... \n&lt;/robot&gt;\n\n\n\n\n1 solo atributo: el nombre\n3 posibles geometrías: &lt;visual&gt;, &lt;collision&gt; y &lt;inertial&gt;\n\n&lt;link name=\"parteA_link\"&gt;\n    &lt;visual&gt;..&lt;/visual&gt;\n    &lt;collision&gt;..&lt;/collision&gt;\n    &lt;inertial&gt;..&lt;/inertial&gt; \n&lt;/link&gt;\n\n\n\nLink\n\n\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\" rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nGeometría: &lt;geometry&gt; .. &lt;/geometry&gt;\n\nprisma:\n\n  &lt;box size=\"[largo-x] [ancho-y] [alto-z]\" /&gt;\n\ncilindro:\n\n  &lt;cylinder radius=\"[radio]\" length=\"[ancho]\" /&gt;\n\nesfera:\n\n  &lt;sphere radius=\"[radio]\" /&gt;\n\nmalla:\n\n  &lt;mesh filename=\"file://[nombre_del_archivo]\" /&gt;\n\n\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\" rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nGeometría: box, cylinder, sphere, mesh\n\n\n\n\n\n\n\n\n\nJoint\n\n\n\n2 atributos: el nombre y tipo\n2 elementos requeridos: link padre e hijo\nTipos:\n\nFija (fixed)\n\n&lt;joint name=\"parteA_joint\" type=\"fixed\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n&lt;/joint&gt;\n\nContinua (continuous)\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n  &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n&lt;/joint&gt;\n\nRevolución (revolute)\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n  &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n  &lt;limit lower=\"[min_rad]\" upper=\"[max_rad]\"\n      velocity=\"[rad_por_seg]\"\n      effort=\"[effort]\" /&gt;\n&lt;/joint&gt;\n\n\n\n\n\nAgregar al tag robot del URDF xmlns:xacro=\"http://www.ros.org/wiki/xacro\":\n&lt;robot name=\"mi_robot\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\" &gt;\n    ...\n    &lt;!-- Contenido --&gt;\n    ... \n&lt;/robot&gt;\n\n\n\nArchivo principal: extensión ‘.urdf.xacro’ y contiene el tag robot con nombre\nArchivos a incluir: extensión ‘.xacro’ y solo contienen el tag robot\nPara incluir:\n\n    &lt;xacro:include filename=\"[nombre_archivo]\" /&gt;\n\n\n\n\nPropiedades xacro:property: Nombre y valor\n\n    &lt;xacro:property name=\"diametro\" value=\"2.1\" /&gt;\n\nOperaciones matemáticas y acceso a variables: ${..}\n\n    &lt;geometry type=\"cylinder\" radius=\"${diametro / 2}\" length=\"${nombre_variable}\" /&gt;\n\nArgumentos xacro:args: Nombre y valor por defecto\n\n    &lt;xacro:arg name=\"[nombre_argumento]\" default=\"[valor_defecto]\"/&gt;\n\n\n\n\n\n\nLuego podemos ejecutar el comando XACRO con el valor del argumento nombre_argumento:=[valor]\n\n\n\n\nBuscar paquetes $(find ..):\n\n    &lt;xacro:include filename=\"$(find [nombre_paquete])/[nombre_archivo].xacro\" /&gt;\n\n\n\n\nEtiqueta xacro:if para true y xacro:unless para false\n\n&lt;xacro:if value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es verdadera: 'true' o 1 --&gt;\n&lt;/xacro:if&gt;\n&lt;xacro:unless value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es falsa: 'false' o 0  --&gt;\n&lt;/xacro:unless&gt;\n\n\n\n\nDefinir macro xacro:macro: Nombre y parámetros a recibir\n\n&lt;xacro:macro name=\"[nombre_macro]\" params=\"[param1] [param2]:=[valor_defecto]\"&gt;\n    &lt;!-- Codigo del macro: ejemplo con parámetros --&gt;\n    &lt;link name=\"${param1}\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"${param2}\" /&gt;\n            &lt;/geometry&gt;\n        &lt;/visual&gt;\n    &lt;/link&gt;\n&lt;/xacro:macro&gt;\n\nAplicar o ejecutar macro xacro:[nombre_macro] y los parámetros definidos:\n\n&lt;xacro:nombre_macro param1=\"[valor_param1]\" param2=\"[valor_param2]\" /&gt; \n\nSi ejecutamos el macro con los valores parteA_link y 1.0, la salida será:\n\n...\n    &lt;link name=\"parteA_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"1.0\" /&gt;\n            &lt;/geometry&gt;\n        &lt;/visual&gt;\n    &lt;/link&gt;\n...\n\n\n\n\nDesde consola\n  $ xacro [ubicacion_del_archivo/nombre_archivo.xacro.urdf]\nDesde launch\n\nImportar las librerías\n\nfrom launch.substitutions import Command, PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\nUbicar el archivo y procesarlo\n\n  # Ubicación del paquete y del archivo URDF\n  urdf_path = PathJoinSubstitution(\n      [FindPackageShare(\"[nombre_paquete]\"),  \"urdf\", \"[nombre_archivo].urdf.xacro\"]\n  )\n\n  # Procesar archivo URDF\n  urdf = Command(['xacro ', urdf_path])\n\n\n\n\n\n\nSe agrega la carpeta urdf para los archivos de descripción\n\n\n\nEjemplo de estructura\n\n📂 paquete_description\n    📁 paquete_description\n    📂 launch\n        📄 description.launch.py\n        ...\n    📂 urdf\n        📄 description.urdf.xacro\n        📄 materials.xacro\n        📄 my_macro.xacro\n        📄 sim_sensor.xacro\n        ...\n    📄 package.xml\n    📄 setup.py\n    ...\n\n\nConfiguración de setup.py\n\n\n\nsetup.py\n\n  # ... Otros parámetros\n  data_files=[\n    # ... Otros archivos\n    # Incluir todos los archivos de la carpeta launch\n    (os.path.join('share', package_name, 'launch'), glob('launch/*'))\n    # Incluir todos los archivos de la carpeta urdf\n    (os.path.join('share', package_name, 'urdf'), glob('urdf/*'))\n    # Incluir todos los archivos de la carpeta meshes\n    (os.path.join('share', package_name, 'meshes'), glob('meshes/*'))\n  ],"
  },
  {
    "objectID": "clases/08/tres.html#universidad-nacional-del-litoral-unl",
    "href": "clases/08/tres.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 08 - Taller de resolución",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/08/tres.html#urdf",
    "href": "clases/08/tres.html#urdf",
    "title": "Clase 08 - Taller de resolución",
    "section": "",
    "text": "Etiqueta raíz (todo el contenido se encuentra dentro)\n\n&lt;?xml version=\"1.0\"?&gt;\n\n&lt;robot name=\"mi_robot\"&gt;\n    ...\n    &lt;!-- Contenido URDF --&gt;\n    ... \n&lt;/robot&gt;\n\n\n\n\n1 solo atributo: el nombre\n3 posibles geometrías: &lt;visual&gt;, &lt;collision&gt; y &lt;inertial&gt;\n\n&lt;link name=\"parteA_link\"&gt;\n    &lt;visual&gt;..&lt;/visual&gt;\n    &lt;collision&gt;..&lt;/collision&gt;\n    &lt;inertial&gt;..&lt;/inertial&gt; \n&lt;/link&gt;\n\n\n\nLink\n\n\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\" rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nMaterial:\n\n    &lt;material name=\"nombre_material\"&gt;\n        &lt;color rgba=\"[R] [G] [B] [Alpha]\"/&gt;\n    &lt;/material&gt;\n\nGeometría: &lt;geometry&gt; .. &lt;/geometry&gt;\n\nprisma:\n\n  &lt;box size=\"[largo-x] [ancho-y] [alto-z]\" /&gt;\n\ncilindro:\n\n  &lt;cylinder radius=\"[radio]\" length=\"[ancho]\" /&gt;\n\nesfera:\n\n  &lt;sphere radius=\"[radio]\" /&gt;\n\nmalla:\n\n  &lt;mesh filename=\"file://[nombre_del_archivo]\" /&gt;\n\n\n\n\n\nOrigen:\n\n    &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\" rpy=\"[roll] [pitch] [yaw]\"/&gt;\n\nGeometría: box, cylinder, sphere, mesh\n\n\n\n\n\n\n\n\n\nJoint\n\n\n\n2 atributos: el nombre y tipo\n2 elementos requeridos: link padre e hijo\nTipos:\n\nFija (fixed)\n\n&lt;joint name=\"parteA_joint\" type=\"fixed\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n&lt;/joint&gt;\n\nContinua (continuous)\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n  &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n&lt;/joint&gt;\n\nRevolución (revolute)\n\n&lt;joint name=\"parteA_joint\" type=\"revolute\"&gt;\n  &lt;parent link=\"padre_link\"/&gt;\n  &lt;child link=\"parteA_link\"/&gt;\n  &lt;origin xyz=\"[pos_x] [pos_y] [pos_z]\"\n      rpy=\"[roll] [pitch] [yaw]\"/&gt;\n  &lt;axis xyz=\"[x] [y] [z]\"/&gt;\n  &lt;limit lower=\"[min_rad]\" upper=\"[max_rad]\"\n      velocity=\"[rad_por_seg]\"\n      effort=\"[effort]\" /&gt;\n&lt;/joint&gt;"
  },
  {
    "objectID": "clases/08/tres.html#xacro",
    "href": "clases/08/tres.html#xacro",
    "title": "Clase 08 - Taller de resolución",
    "section": "",
    "text": "Agregar al tag robot del URDF xmlns:xacro=\"http://www.ros.org/wiki/xacro\":\n&lt;robot name=\"mi_robot\" xmlns:xacro=\"http://www.ros.org/wiki/xacro\" &gt;\n    ...\n    &lt;!-- Contenido --&gt;\n    ... \n&lt;/robot&gt;\n\n\n\nArchivo principal: extensión ‘.urdf.xacro’ y contiene el tag robot con nombre\nArchivos a incluir: extensión ‘.xacro’ y solo contienen el tag robot\nPara incluir:\n\n    &lt;xacro:include filename=\"[nombre_archivo]\" /&gt;\n\n\n\n\nPropiedades xacro:property: Nombre y valor\n\n    &lt;xacro:property name=\"diametro\" value=\"2.1\" /&gt;\n\nOperaciones matemáticas y acceso a variables: ${..}\n\n    &lt;geometry type=\"cylinder\" radius=\"${diametro / 2}\" length=\"${nombre_variable}\" /&gt;\n\nArgumentos xacro:args: Nombre y valor por defecto\n\n    &lt;xacro:arg name=\"[nombre_argumento]\" default=\"[valor_defecto]\"/&gt;\n\n\n\n\n\n\nLuego podemos ejecutar el comando XACRO con el valor del argumento nombre_argumento:=[valor]\n\n\n\n\nBuscar paquetes $(find ..):\n\n    &lt;xacro:include filename=\"$(find [nombre_paquete])/[nombre_archivo].xacro\" /&gt;\n\n\n\n\nEtiqueta xacro:if para true y xacro:unless para false\n\n&lt;xacro:if value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es verdadera: 'true' o 1 --&gt;\n&lt;/xacro:if&gt;\n&lt;xacro:unless value=\"[expresion]\"&gt;\n    &lt;!-- Si la expresión es falsa: 'false' o 0  --&gt;\n&lt;/xacro:unless&gt;\n\n\n\n\nDefinir macro xacro:macro: Nombre y parámetros a recibir\n\n&lt;xacro:macro name=\"[nombre_macro]\" params=\"[param1] [param2]:=[valor_defecto]\"&gt;\n    &lt;!-- Codigo del macro: ejemplo con parámetros --&gt;\n    &lt;link name=\"${param1}\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"${param2}\" /&gt;\n            &lt;/geometry&gt;\n        &lt;/visual&gt;\n    &lt;/link&gt;\n&lt;/xacro:macro&gt;\n\nAplicar o ejecutar macro xacro:[nombre_macro] y los parámetros definidos:\n\n&lt;xacro:nombre_macro param1=\"[valor_param1]\" param2=\"[valor_param2]\" /&gt; \n\nSi ejecutamos el macro con los valores parteA_link y 1.0, la salida será:\n\n...\n    &lt;link name=\"parteA_link\"&gt;\n        &lt;visual&gt;\n            &lt;geometry&gt;\n                &lt;sphere radius=\"1.0\" /&gt;\n            &lt;/geometry&gt;\n        &lt;/visual&gt;\n    &lt;/link&gt;\n...\n\n\n\n\nDesde consola\n  $ xacro [ubicacion_del_archivo/nombre_archivo.xacro.urdf]\nDesde launch\n\nImportar las librerías\n\nfrom launch.substitutions import Command, PathJoinSubstitution\nfrom launch_ros.substitutions import FindPackageShare\n\nUbicar el archivo y procesarlo\n\n  # Ubicación del paquete y del archivo URDF\n  urdf_path = PathJoinSubstitution(\n      [FindPackageShare(\"[nombre_paquete]\"),  \"urdf\", \"[nombre_archivo].urdf.xacro\"]\n  )\n\n  # Procesar archivo URDF\n  urdf = Command(['xacro ', urdf_path])"
  },
  {
    "objectID": "clases/08/tres.html#adaptación-del-paquete",
    "href": "clases/08/tres.html#adaptación-del-paquete",
    "title": "Clase 08 - Taller de resolución",
    "section": "",
    "text": "Se agrega la carpeta urdf para los archivos de descripción\n\n\n\nEjemplo de estructura\n\n📂 paquete_description\n    📁 paquete_description\n    📂 launch\n        📄 description.launch.py\n        ...\n    📂 urdf\n        📄 description.urdf.xacro\n        📄 materials.xacro\n        📄 my_macro.xacro\n        📄 sim_sensor.xacro\n        ...\n    📄 package.xml\n    📄 setup.py\n    ...\n\n\nConfiguración de setup.py\n\n\n\nsetup.py\n\n  # ... Otros parámetros\n  data_files=[\n    # ... Otros archivos\n    # Incluir todos los archivos de la carpeta launch\n    (os.path.join('share', package_name, 'launch'), glob('launch/*'))\n    # Incluir todos los archivos de la carpeta urdf\n    (os.path.join('share', package_name, 'urdf'), glob('urdf/*'))\n    # Incluir todos los archivos de la carpeta meshes\n    (os.path.join('share', package_name, 'meshes'), glob('meshes/*'))\n  ],"
  },
  {
    "objectID": "clases/08/tres.html#robot_state_publisher",
    "href": "clases/08/tres.html#robot_state_publisher",
    "title": "Clase 08 - Taller de resolución",
    "section": "robot_state_publisher",
    "text": "robot_state_publisher\n\nEjecutar desde consola\n\n    $ ros2 run robot_state_publisher robot_state_publisher\n                --ros-args -p robot_description:='&lt;robot_description&gt;'\n\nCargar desde launch\n\n    Node(\n        package = 'robot_state_publisher',\n        executable = 'robot_state_publisher',\n        parameters=[{\n            'robot_description': '&lt;robot_description&gt;',\n        }]\n    )"
  },
  {
    "objectID": "clases/08/tres.html#joint_state_publisher_gui",
    "href": "clases/08/tres.html#joint_state_publisher_gui",
    "title": "Clase 08 - Taller de resolución",
    "section": "joint_state_publisher_gui",
    "text": "joint_state_publisher_gui\n\nEjecutar desde consola\n\n    $ ros2 run joint_state_publisher_gui joint_state_publisher_gui\n\nCargar desde launch:\n\n    Node(\n        package = 'joint_state_publisher_gui',\n        executable = 'joint_state_publisher_gui',\n        output = 'screen',\n    )"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-1",
    "href": "clases/07/index.html#posicionamiento-2d-1",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-2",
    "href": "clases/07/index.html#posicionamiento-2d-2",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-3",
    "href": "clases/07/index.html#posicionamiento-2d-3",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-4",
    "href": "clases/07/index.html#posicionamiento-2d-4",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-5",
    "href": "clases/07/index.html#posicionamiento-2d-5",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-6",
    "href": "clases/07/index.html#posicionamiento-2d-6",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-7",
    "href": "clases/07/index.html#posicionamiento-2d-7",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-8",
    "href": "clases/07/index.html#posicionamiento-2d-8",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-9",
    "href": "clases/07/index.html#posicionamiento-2d-9",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-10",
    "href": "clases/07/index.html#posicionamiento-2d-10",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D"
  },
  {
    "objectID": "clases/07/index.html#posicionamiento-2d-11",
    "href": "clases/07/index.html#posicionamiento-2d-11",
    "title": "Robótica",
    "section": "Posicionamiento 2D",
    "text": "Posicionamiento 2D\n\n\n\n\n\n\n\nMarcos de referencia: cómo convertirmos coordenadas entre ellos?"
  },
  {
    "objectID": "clases/07/index.html#notación",
    "href": "clases/07/index.html#notación",
    "title": "Robótica",
    "section": "Notación",
    "text": "Notación\n\n\n\nPunto: \\(\\require{color} \\textcolor{PineGreen}{d}_{2D} = \\begin{pmatrix} \\textcolor{Orange}{a} \\\\ \\textcolor{RedViolet}{b} \\end{pmatrix} \\;\\)\nVector: \\[\\require{color} {}^{\\textcolor{Blue}{A}}{\\boldsymbol{\\textcolor{LimeGreen}{p}}_\\textcolor{PineGreen}{d}} = \\textcolor{Orange}{a} \\boldsymbol{\\vec{i}} + \\textcolor{RedViolet}{b} \\boldsymbol{\\vec{j}}\\]"
  },
  {
    "objectID": "clases/07/index.html#transformaciones-lineales",
    "href": "clases/07/index.html#transformaciones-lineales",
    "title": "Robótica",
    "section": "Transformaciones lineales",
    "text": "Transformaciones lineales\nFunciones de la forma:\n\\[\nf(\\boldsymbol{p}) = \\boldsymbol{T} \\, \\boldsymbol{p}\n\\]\ndonde \\(\\boldsymbol{T}\\) será una matrix de \\(n \\times n\\), y \\(n\\) la dimensión de \\(\\boldsymbol{p}\\)\n\n\n\nPropiedad\nSe pueden encadenar como producto de matrices \\[f_3(f_2(f_1(\\boldsymbol{p}))) = \\boldsymbol{T}_3 \\, \\boldsymbol{T}_2 \\, \\boldsymbol{T}_1 \\, \\boldsymbol{p}\\]"
  },
  {
    "objectID": "clases/07/index.html#transformaciones-lineales-1",
    "href": "clases/07/index.html#transformaciones-lineales-1",
    "title": "Robótica",
    "section": "Transformaciones lineales",
    "text": "Transformaciones lineales\nPara el caso 2D\n\\[ \\boldsymbol{T} = \\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix} \\]\nentonces, dado \\(\\boldsymbol{p} =  \\begin{bmatrix} x_1 & y_1  \\end{bmatrix}^T\\)\n\\[ f(\\boldsymbol{p}) = \\begin{bmatrix} x_2 \\\\ y_2 \\end{bmatrix} =\n\\begin{bmatrix} a & b \\\\ c & d \\end{bmatrix}\n\\begin{bmatrix} x_1 \\\\ y_1 \\end{bmatrix} =\n\\begin{bmatrix} a x_1 + b y_1 \\\\ c x_1 + d y_1\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d",
    "href": "clases/07/index.html#rotación-2d",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\nDado un marco de referencia \\(\\textcolor{Orange}{\\{B\\}}\\) rotado un ángulo \\(\\textcolor{Plum}{\\theta}\\) respecto de un marco de referencia \\(\\textcolor{Blue}{\\{A\\}}\\). Encontrar la matriz de transformación que convierte las coordenadas del marco \\(\\textcolor{Orange}{B}\\) al \\(\\textcolor{Blue}{A}\\)."
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-1",
    "href": "clases/07/index.html#rotación-2d-1",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\n\n\\[\n{}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix} =\n\\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $}  \\\\  \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\end{pmatrix}\n\\]\n\n\n\\[\n{}^{\\textcolor{Blue}{\\boldsymbol{A}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} =\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})}  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})} \\end{pmatrix}\n\\]\n\n\nSabiendo:\n\n\\(\\sin{(A+B)} = \\sin{A} \\cos{B} + \\cos{A} \\sin{B}\\)\n\\(\\cos{(A+B)} = \\cos{A} \\cos{B} - \\sin{A} \\sin{B}\\)\n\n\n\n\\[\n\\begin{align}\n\\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} &=\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\cos{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} - \\sin{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\sin{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} + \\cos{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} - \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} + \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-2",
    "href": "clases/07/index.html#rotación-2d-2",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\n\\[\n{}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix} =\n\\begin{pmatrix} \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $}  \\\\  \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\end{pmatrix}\n\\]\n\\[\n{}^{\\textcolor{Blue}{\\boldsymbol{A}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} =\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})}  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})} \\end{pmatrix}\n\\]\nSabiendo:\n\n\\(\\sin{(A+B)} = \\sin{A} \\cos{B} + \\cos{A} \\sin{B}\\)\n\\(\\cos{(A+B)} = \\cos{A} \\cos{B} - \\sin{A} \\sin{B}\\)\n\n\\[\n\\begin{align}\n\\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} &=\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\cos{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} - \\sin{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\sin{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} + \\cos{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} - \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} + \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-3",
    "href": "clases/07/index.html#rotación-2d-3",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\n\\[\n{}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix} =\n\\begin{pmatrix} \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $}  \\\\  \\colorbox{lightgray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\end{pmatrix}\n\\]\n\\[\n{}^{\\textcolor{Blue}{\\boldsymbol{A}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} =\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})}  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})} \\end{pmatrix}\n\\]\nSabiendo:\n\n\\(\\sin{(A+B)} = \\sin{A} \\cos{B} + \\cos{A} \\sin{B}\\)\n\\(\\cos{(A+B)} = \\cos{A} \\cos{B} - \\sin{A} \\sin{B}\\)\n\n\\[\n\\begin{align}\n\\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} &=\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\cos{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} - \\sin{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\sin{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} + \\cos{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} - \\colorbox{lightgray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\colorbox{lightgray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} + \\colorbox{Gray}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-4",
    "href": "clases/07/index.html#rotación-2d-4",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\n\\[\n{}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix} =\n\\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $}  \\\\  \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\end{pmatrix}\n\\]\n\\[\n{}^{\\textcolor{Blue}{\\boldsymbol{A}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} =\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})}  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})} \\end{pmatrix}\n\\]\nSabiendo:\n\n\\(\\sin{(A+B)} = \\sin{A} \\cos{B} + \\cos{A} \\sin{B}\\)\n\\(\\cos{(A+B)} = \\cos{A} \\cos{B} - \\sin{A} \\sin{B}\\)\n\n\\[\n\\begin{align}\n\\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} &=\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\cos{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} - \\sin{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\sin{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} + \\cos{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} - \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} + \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} \\cos{\\textcolor{Plum}{\\theta}} - \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\cos{\\textcolor{Plum}{\\theta}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-5",
    "href": "clases/07/index.html#rotación-2d-5",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\n\\[\n{}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix} =\n\\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $}  \\\\  \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\end{pmatrix}\n\\]\n\\[\n{}^{\\textcolor{Blue}{\\boldsymbol{A}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} =\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})}  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{(\\textcolor{Maroon}{\\alpha}+\\textcolor{Plum}{\\theta})} \\end{pmatrix}\n\\]\nSabiendo:\n\n\\(\\sin{(A+B)} = \\sin{A} \\cos{B} + \\cos{A} \\sin{B}\\)\n\\(\\cos{(A+B)} = \\cos{A} \\cos{B} - \\sin{A} \\sin{B}\\)\n\n\\[\n\\begin{align}\n\\begin{pmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{pmatrix} &=\n\\begin{pmatrix} |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\cos{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} - \\sin{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\\\  |\\textcolor{ForestGreen}{\\boldsymbol{p}}| ( \\sin{\\textcolor{Maroon}{\\alpha}} \\cos{\\textcolor{Plum}{\\theta}} + \\cos{\\textcolor{Maroon}{\\alpha}} \\sin{\\textcolor{Plum}{\\theta}} )  \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} - \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\sin{\\textcolor{Maroon}{\\alpha}} $} \\cos{\\textcolor{Plum}{\\theta}} + \\colorbox{white}{$ |\\textcolor{ForestGreen}{\\boldsymbol{p}}| \\cos{\\textcolor{Maroon}{\\alpha}} $} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix} \\\\\n&= \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} \\cos{\\textcolor{Plum}{\\theta}} - \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\sin{\\textcolor{Plum}{\\theta}} \\\\ \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\cos{\\textcolor{Plum}{\\theta}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} \\sin{\\textcolor{Plum}{\\theta}} \\end{pmatrix}\n= \\begin{bmatrix} \\cos{\\textcolor{Plum}{\\theta}} & -\\sin{\\textcolor{Plum}{\\theta}} \\\\ \\sin{\\textcolor{Plum}{\\theta}} & \\cos{\\textcolor{Plum}{\\theta}}\\end{bmatrix} \\begin{pmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{pmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#rotación-2d-6",
    "href": "clases/07/index.html#rotación-2d-6",
    "title": "Robótica",
    "section": "Rotación 2D",
    "text": "Rotación 2D\n\n\nExpresado en forma matricial:\n\\[\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\end{bmatrix}\n= \\begin{bmatrix} \\cos{\\textcolor{Plum}{\\theta}} & -\\sin{\\textcolor{Plum}{\\theta}} \\\\ \\sin{\\textcolor{Plum}{\\theta}} & \\cos{\\textcolor{Plum}{\\theta}}\\end{bmatrix} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\end{bmatrix}\n\\]\n\n\\[\n{}^\\textcolor{Blue}{\\boldsymbol{A}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = \\boldsymbol{R}(\\textcolor{Plum}{\\theta}) {}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}}\n\\to\n{}^\\textcolor{Blue}{\\boldsymbol{A}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}} = {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{T}_{\\textcolor{Orange}{\\boldsymbol{B}}} {}^{\\textcolor{Orange}{\\boldsymbol{B}}}{\\textcolor{ForestGreen}{\\boldsymbol{p}}}\n\\]\ndonde: \\[\n{}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{T}_{\\textcolor{Orange}{\\boldsymbol{B}}} = \\boldsymbol{R}(\\textcolor{Plum}{\\theta})\n= \\begin{bmatrix} \\cos{\\textcolor{Plum}{\\theta}} & -\\sin{\\textcolor{Plum}{\\theta}} \\\\ \\sin{\\textcolor{Plum}{\\theta}} & \\cos{\\textcolor{Plum}{\\theta}}\\end{bmatrix}\n\\]\n\nMatriz ortogonal y ortonormal: \\[\\boldsymbol{R}(\\theta)^{-1} = \\boldsymbol{R}(\\theta)^{T}\\] \\[\\det{\\boldsymbol{R}(\\theta)} = 1\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-2d",
    "href": "clases/07/index.html#traslación-2d",
    "title": "Robótica",
    "section": "Traslación 2D",
    "text": "Traslación 2D\n\n\nDado un marco de referencia \\(\\textcolor{Orange}{\\{\\boldsymbol{B}\\}}\\) paralelo a un marco de referencia \\(\\textcolor{Blue}{\\{\\boldsymbol{A}\\}}\\) trasladado \\(\\textcolor{ForestGreen}{{}^\\boldsymbol{A}{\\boldsymbol{t}}_\\boldsymbol{B}}\\). Encontrar la matriz de transformación que convierte las coordenadas del marco \\(\\textcolor{Orange}{\\boldsymbol{B}}\\) al \\(\\textcolor{Blue}{\\boldsymbol{A}}\\).\n\n\\[\n\\textcolor{Blue}{{}^A{\\boldsymbol{p}}} = \\textcolor{ForestGreen}{{}^A\\boldsymbol{t}_B} + \\textcolor{Orange}{{}^B{\\boldsymbol{p}}}\n\\]\n\n\nPuede representarse como una transformación lineal? \\[\nf(\\boldsymbol{p}) = \\boldsymbol{T} \\, \\boldsymbol{p}\n\\]\n\n\n\n\n\n\n\n\nNo para un dimensión de \\(n=2\\)"
  },
  {
    "objectID": "clases/07/index.html#coordenadas-homogéneas",
    "href": "clases/07/index.html#coordenadas-homogéneas",
    "title": "Robótica",
    "section": "Coordenadas homogéneas",
    "text": "Coordenadas homogéneas\n\nQue sucede si representamos un punto 2D con un vector de 3 componentes?\n\nDado un vector \\({\\boldsymbol{p}} = {\\begin{pmatrix} a & b \\end{pmatrix}}^T\\), su correspondiente homogéneo:\n\\[\n{\\boldsymbol{\\tilde{p}}} = \\begin{pmatrix} \\tilde{a} \\\\ \\tilde{b} \\\\ c \\end{pmatrix} \\quad \\text{donde} \\;\n\\begin{cases}\n\\tilde{a} = \\tfrac{a}{c} \\\\\n\\tilde{b} = \\tfrac{b}{c} \\\\\nc \\neq 0\n\\end{cases}\n\\]\n\nCon \\(c = 1 \\to {\\boldsymbol{\\tilde{p}}} = {\\begin{pmatrix} a & b & 1 \\end{pmatrix}}^T\\)\n\n\nEn el problema de traslación 2D:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} = \\textcolor{ForestGreen}{{}^\\boldsymbol{A}\\boldsymbol{\\tilde{t}}_\\boldsymbol{B}} + \\textcolor{Orange}{{}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}} \\to\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\\\ 1  \\end{bmatrix} =\n{\\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} \\\\ \\textcolor{ForestGreen}{{t_y}} \\\\ 0 \\end{bmatrix}} + \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} =\n\\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{ForestGreen}{{t_y}} + \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-2d-en-c.h.",
    "href": "clases/07/index.html#traslación-2d-en-c.h.",
    "title": "Robótica",
    "section": "Traslación 2D en c.h.",
    "text": "Traslación 2D en c.h.\nEl problema expresado en coordenadas homogéneas:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} = \\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}} \\textcolor{Orange}{{}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}}\n\\] con \\({}^A\\boldsymbol{T}_B\\) de dimension \\(3 \\times 3\\)\n\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= \\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{ForestGreen}{{t_y}} + \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} \\\\\n%&= {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} =\n%\\begin{bmatrix} ? + ? \\\\ ? + ? \\\\ ? \\end{bmatrix}\n\\end{align}\n\\]\n\n\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = \\begin{bmatrix} ? \\\\ ? \\\\ ? \\end{bmatrix}\n%&= {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} =\n%\\begin{bmatrix} ? + ? \\\\ ? + ? \\\\ ? \\end{bmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-2d-en-c.h.-1",
    "href": "clases/07/index.html#traslación-2d-en-c.h.-1",
    "title": "Robótica",
    "section": "Traslación 2D en c.h.",
    "text": "Traslación 2D en c.h.\nEl problema expresado en coordenadas homogéneas:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} = \\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}} \\textcolor{Orange}{{}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}}\n\\] con \\({}^A\\boldsymbol{T}_B\\) de dimension \\(3 \\times 3\\)\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= \\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{ForestGreen}{{t_y}} + \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} \\\\\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ 0 & 0 & 1 \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = \\begin{bmatrix} ? \\\\ ? \\\\ 1 \\end{bmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-2d-en-c.h.-2",
    "href": "clases/07/index.html#traslación-2d-en-c.h.-2",
    "title": "Robótica",
    "section": "Traslación 2D en c.h.",
    "text": "Traslación 2D en c.h.\nEl problema expresado en coordenadas homogéneas:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} = \\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}} \\textcolor{Orange}{{}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}}\n\\] con \\({}^A\\boldsymbol{T}_B\\) de dimension \\(3 \\times 3\\)\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= \\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{ForestGreen}{{t_y}} + \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} \\\\\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= {\\begin{bmatrix} 1 & 0 & ? \\\\ 0 & 1 & ? \\\\ 0 & 0 & 1 \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} + ? \\\\ \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} + ? \\\\ 1 \\end{bmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-2d-en-c.h.-3",
    "href": "clases/07/index.html#traslación-2d-en-c.h.-3",
    "title": "Robótica",
    "section": "Traslación 2D en c.h.",
    "text": "Traslación 2D en c.h.\nEl problema expresado en coordenadas homogéneas:\n\\[\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} = \\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}} \\textcolor{Orange}{{}^\\boldsymbol{B}{\\boldsymbol{\\tilde{p}}}}\n\\] con \\({}^A\\boldsymbol{T}_B\\) de dimension \\(3 \\times 3\\)\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= \\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}} + \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{ForestGreen}{{t_y}} + \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = {\\begin{bmatrix} ? & ? & ? \\\\ ? & ? & ? \\\\ ? & ? & ? \\end{bmatrix}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} \\\\\n\\end{align}\n\\]\n\\[\n\\begin{align}\n\\textcolor{Blue}{{}^\\boldsymbol{A}{\\boldsymbol{\\tilde{p}}}} &= \\underbrace{\\begin{bmatrix} 1 & 0 &  \\textcolor{ForestGreen}{{t_x}} \\\\ 0 & 1 &  \\textcolor{ForestGreen}{{t_y}} \\\\ 0 & 0 & 1 \\end{bmatrix}}_{\\textcolor{Blue}{{}^\\boldsymbol{A}}\\boldsymbol{T}_\\textcolor{Orange}{\\boldsymbol{B}}} \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1  \\end{bmatrix} = \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}} +  \\textcolor{ForestGreen}{{t_x}} \\\\ \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} +  \\textcolor{ForestGreen}{{t_y}} \\\\ 1 \\end{bmatrix}\n\\end{align}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-y-rotación",
    "href": "clases/07/index.html#traslación-y-rotación",
    "title": "Robótica",
    "section": "Traslación y rotación",
    "text": "Traslación y rotación\n\n\n(traslación) \\(\\to {}^\\textcolor{Blue}{\\boldsymbol{A}}{\\boldsymbol{p}} = {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{t}_{\\textcolor{ForestGreen}{\\boldsymbol{C}}} + {}^\\textcolor{ForestGreen}{\\boldsymbol{C}}{\\boldsymbol{p}}\\)\n(rotación) \\(\\to {}^\\textcolor{ForestGreen}{\\boldsymbol{C}}{\\boldsymbol{p}} = {}^\\textcolor{ForestGreen}{\\boldsymbol{C}}\\boldsymbol{R}_\\textcolor{Orange}{\\boldsymbol{B}} {}^\\textcolor{Orange}{\\boldsymbol{B}}{\\boldsymbol{p}}\\)\n\n\nreemplazando \\[\n{}^\\textcolor{Blue}{\\boldsymbol{A}}{\\boldsymbol{p}} = {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{t}_{\\textcolor{ForestGreen}{\\boldsymbol{C}}} + {}^\\textcolor{ForestGreen}{\\boldsymbol{C}}\\boldsymbol{R}_\\textcolor{Orange}{\\boldsymbol{B}} {}^\\textcolor{Orange}{\\boldsymbol{B}}{\\boldsymbol{p}}\n\\]\n\n\n\ndado que \\(\\textcolor{ForestGreen}{\\boldsymbol{\\{C\\}}} \\parallel \\textcolor{Blue}{\\boldsymbol{\\{A\\}}}\\) y \\(\\textcolor{Orange}{\\boldsymbol{B}} \\equiv \\textcolor{ForestGreen}{\\boldsymbol{C}}\\):\n\\[\n{}^\\textcolor{Blue}{\\boldsymbol{A}}{\\boldsymbol{p}} = {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{t}_{\\textcolor{Orange}{\\boldsymbol{B}}} + {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{R}_\\textcolor{Orange}{\\boldsymbol{B}} {}^\\textcolor{Orange}{\\boldsymbol{B}}{\\boldsymbol{p}}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#traslación-y-rotación-1",
    "href": "clases/07/index.html#traslación-y-rotación-1",
    "title": "Robótica",
    "section": "Traslación y rotación",
    "text": "Traslación y rotación\n\\[\n{}^\\textcolor{Blue}{\\boldsymbol{A}}{\\boldsymbol{p}} = {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{R}_\\textcolor{Orange}{\\boldsymbol{B}} {}^\\textcolor{Orange}{\\boldsymbol{B}}{\\boldsymbol{p}} +  {}^\\textcolor{Blue}{\\boldsymbol{A}}\\boldsymbol{t}_{\\textcolor{Orange}{\\boldsymbol{B}}}\n\\]\n\n\\[\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}}  \\end{bmatrix} =\n{\\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} \\\\ \\sin{\\theta} & \\cos{\\theta} \\end{bmatrix}}  \\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}}  \\end{bmatrix} +\n\\begin{bmatrix} \\textcolor{ForestGreen}{{t_x}}  \\\\  \\textcolor{ForestGreen}{{t_y}}  \\end{bmatrix}\n\\]\n\n\nEn coordenadas homogéneas: \\[\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}}  \\end{bmatrix} =\n{\\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} & \\textcolor{ForestGreen}{{t_x}} \\\\ \\sin{\\theta} & \\cos{\\theta} & \\textcolor{ForestGreen}{{t_y}} \\end{bmatrix}}\n\\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1 \\end{bmatrix}\n\\]\n\\[\n\\begin{bmatrix} \\textcolor{Blue}{p_{{x}_\\boldsymbol{A}}}  \\\\  \\textcolor{Blue}{p_{{y}_\\boldsymbol{A}}} \\\\ 1  \\end{bmatrix} =\n{\\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} & \\textcolor{ForestGreen}{{t_x}} \\\\ \\sin{\\theta} & \\cos{\\theta} & \\textcolor{ForestGreen}{{t_y}} \\\\ 0 & 0 & 1 \\end{bmatrix}}\n\\begin{bmatrix} \\textcolor{Orange}{p_{{x}_\\boldsymbol{B}}}  \\\\  \\textcolor{Orange}{p_{{y}_\\boldsymbol{B}}} \\\\ 1 \\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#transformación-homogénea",
    "href": "clases/07/index.html#transformación-homogénea",
    "title": "Robótica",
    "section": "Transformación homogénea",
    "text": "Transformación homogénea\n\n\n\\[\n{}^A{\\boldsymbol{\\tilde{p}}} = \\begin{pmatrix} {}^A\\boldsymbol{R}_B & {}^A\\boldsymbol{t}_B \\\\ \\boldsymbol{0} & 1 \\end{pmatrix} {}^B{\\boldsymbol{\\tilde{p}}}\n\\]\n\\[\n{}^A\\boldsymbol{\\tilde{p}} = {}^A\\boldsymbol{T}_B {}^B \\boldsymbol{\\tilde{p}}\n\\]\ndonde \\[\n{}^A\\boldsymbol{T}_B = \\begin{pmatrix} {}^A\\boldsymbol{R}_B & {}^A\\boldsymbol{t}_B \\\\ \\boldsymbol{0} & 1 \\end{pmatrix}\n\\]\ndescribe una pose relativa como una matriz \\(3\\times3\\)"
  },
  {
    "objectID": "clases/07/index.html#generalizando",
    "href": "clases/07/index.html#generalizando",
    "title": "Robótica",
    "section": "Generalizando",
    "text": "Generalizando\nLa estructura de \\(\\boldsymbol{T}\\) se puede generalizar para \\(n\\)-dimensiones:\n\\[\n\\boldsymbol{T} \\boldsymbol{\\hat{p}} = \\begin{pmatrix} \\boldsymbol{R}_{n \\times n} & \\boldsymbol{t}_{n \\times 1} \\\\ \\boldsymbol{0}_{1 \\times n} & 1 \\end{pmatrix}_{(n+1) \\times (n+1)} \\boldsymbol{\\hat{p}}_{(n+1)}\n\\]\nEn resumen: a partir de la función no lineal de traslación-rotación, se desarrolló una función lineal en el sistema de coordenadas homogéneo \\(\\boldsymbol{\\tilde{p}}\\) \\[\n\\begin{align*}\nf(\\boldsymbol{p}) &= \\boldsymbol{R} \\boldsymbol{p} + \\boldsymbol{t} \\\\\n&\\downarrow \\\\\ng(\\boldsymbol{\\tilde{p}}) &= \\boldsymbol{T} \\tilde{p} =  \\begin{pmatrix} {}^A\\boldsymbol{R}_B & {}^A\\boldsymbol{t}_B \\\\ \\boldsymbol{0} & 1 \\end{pmatrix} \\tilde{p}\n\\end{align*}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#volviendo-al-mundo-real",
    "href": "clases/07/index.html#volviendo-al-mundo-real",
    "title": "Robótica",
    "section": "Volviendo al mundo real",
    "text": "Volviendo al mundo real"
  },
  {
    "objectID": "clases/07/index.html#volviendo-al-mundo-real-1",
    "href": "clases/07/index.html#volviendo-al-mundo-real-1",
    "title": "Robótica",
    "section": "Volviendo al mundo real",
    "text": "Volviendo al mundo real\n\n\n\n\n\n\nDenominación “de referencia” (padre) y “objetivo o target” (hijo)"
  },
  {
    "objectID": "clases/07/index.html#pose-2d",
    "href": "clases/07/index.html#pose-2d",
    "title": "Robótica",
    "section": "Pose 2D",
    "text": "Pose 2D\n\n\n\nTres componentes: \\((x, y, \\theta)\\)\n\n\\[\n{}^W \\boldsymbol{\\xi}_R \\sim {}^W\\boldsymbol{T}_R = \\begin{pmatrix} \\cos{\\theta} & -\\sin{\\theta} & {}^W t_x \\\\ \\sin{\\theta} & \\cos{\\theta} & {}^W  t_y \\\\ 0 & 0 & 1 \\end{pmatrix}\n\\]\n\\[\n{}^W\\boldsymbol{\\tilde{p}}_d = {}^W\\boldsymbol{\\xi}_R {}^R\\boldsymbol{\\tilde{p}}_d\n\\]\n\n\n\n\nSe puede considerar como un movimiento de traslación y rotación del marco de coordenadas\nLa pose de un marco de coordenada es siempre respecto a otro."
  },
  {
    "objectID": "clases/07/index.html#pose-2d-1",
    "href": "clases/07/index.html#pose-2d-1",
    "title": "Robótica",
    "section": "Pose 2D",
    "text": "Pose 2D\n\nY si queremos ir del marco \\(\\{A\\}\\) al \\(\\{B\\}\\)?\n\n\n\n\n\n\n\n\nLa operación inversa\n\n\n\n\\[\n{{}^A \\boldsymbol{\\xi}_B }^{-1} = {}^B \\boldsymbol{\\xi}_A \\to {}^B \\boldsymbol{T}_A = {{}^A \\boldsymbol{T}_B }^{-1}\n\\]\n\\[\n\\boldsymbol{\\xi}^{-1} = \\begin{pmatrix} \\boldsymbol{R} & \\boldsymbol{t} \\\\ \\boldsymbol{0} & 1 \\end{pmatrix}^{-1} = \\begin{pmatrix} \\boldsymbol{R}^T & -\\boldsymbol{R}^T \\boldsymbol{t} \\\\ \\boldsymbol{0} & 1 \\end{pmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#composición-de-poses",
    "href": "clases/07/index.html#composición-de-poses",
    "title": "Robótica",
    "section": "Composición de poses",
    "text": "Composición de poses\n\n\n\\[\n{}^A\\boldsymbol{\\xi}_C = {}^A \\boldsymbol{\\xi}_B \\otimes {}^B \\boldsymbol{\\xi}_C\n\\]\nSe puede cacular como: \\[\n{}^A \\boldsymbol{\\xi}_B \\otimes {}^B \\boldsymbol{\\xi}_C = {}^A\\boldsymbol{T}_B {}^B\\boldsymbol{T}_C\n\\]\n\\[\n\\boldsymbol{\\xi}_1 \\boldsymbol{\\xi}_2 = \\begin{pmatrix} \\boldsymbol{R}_1 & \\boldsymbol{t}_1 \\\\ \\boldsymbol{0} & 1 \\end{pmatrix} \\begin{pmatrix} \\boldsymbol{R}_2 & \\boldsymbol{t}_2 \\\\ \\boldsymbol{0} & 1 \\end{pmatrix}\n\\]\n\\[\n\\boldsymbol{\\xi}_1 \\boldsymbol{\\xi}_2 = \\begin{pmatrix} \\boldsymbol{R}_1 \\boldsymbol{R}_2 & \\boldsymbol{t}_1 + \\boldsymbol{R}_1 \\boldsymbol{t}_2 \\\\ \\boldsymbol{0} & 1 \\end{pmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#convenciones-ros-enhancement-proposals",
    "href": "clases/07/index.html#convenciones-ros-enhancement-proposals",
    "title": "Robótica",
    "section": "Convenciones (ROS Enhancement Proposals)",
    "text": "Convenciones (ROS Enhancement Proposals)\n\nREP 103: “Standard Units of Measure and Coordinate Conventions”\n\n\nUnidades en S.I. (metro, segundo, kg, radian)\nRegla de la mano derecha\nMarcos ENU y NED\nRoll (X), Pitch (Y) y Yaw (Z)\n\n\nREP = “Documentos que gobiernan ROS”\nREP 103:\n\nUnidades: Sistema internacional -&gt; Metros, kilogramo, segundo\nRadianes para ángulos\nMarcos de coordenadas: Todos son de mano derecha -&gt; Cumplen la regla de la mano derecha\nLa orientación de los ejes para cuerpos: x-adelante, y-izquierda, z-arriba\nCoordenadas geográficas de “corto alcance” -&gt; ENU: X-este, Y-norte, Z-arriba\nPara sistemas de ambiente exteriores: -&gt; NED:X-norte, Y-este, Z-abajo\nRotaciones: Roll-Pitch-Yaw alrededor de X Y Z respectivamente"
  },
  {
    "objectID": "clases/07/index.html#convenciones-ros-enhancement-proposals-1",
    "href": "clases/07/index.html#convenciones-ros-enhancement-proposals-1",
    "title": "Robótica",
    "section": "Convenciones (ROS Enhancement Proposals)",
    "text": "Convenciones (ROS Enhancement Proposals)\n\nREP 105: “Coordinate Frames for Mobile Platforms”\n\n\nConvención de nombres\nMarco de coordenadas para plataformas robóticas\n\nbase_link: Fijo al robot (según REP103)\nodom: Fijo al mundo (continuo, sin saltos, con drift)\nmap: Fijo al mundo (con saltos pero sin drift)\n\n\n\nNombramiento marcos de coordenadas: minúscula y con guión bajo para separación de palabras. Deben ser únicos\n\n‘base_link’: Es el marco fijado rigidamente a la base del robot móvil -&gt; Se recomienda utilizar lo del REP103\n‘odom’: marco de referencia fijo respecto del mundo. Si bien sufre los problemas de drift sin límite, es continuo y no posee saltos.\n‘map’: marco de referencia fijo respecto del mundo, con el eje Z apuntando hacia arriba. La pose del robot respecto del ‘map’ no debe tener un drift significativo a lo largo del tiempo. El marco puede no ser continuo, sufriendo saltos en cualquier momento."
  },
  {
    "objectID": "clases/07/index.html#representación-de-rotaciones",
    "href": "clases/07/index.html#representación-de-rotaciones",
    "title": "Robótica",
    "section": "Representación de rotaciones",
    "text": "Representación de rotaciones\nProblemas con las matrices:\n\n\n\n9 elementos (3D)\nDifícil de interpolar\nAcumulan errores (pueden perder ortogonalidad)\nGimbal lock\n\n\n\n\n\n\n\n\n\n\nFigure 1: Cuando el pitch (verde) y el yaw (magenta) se alinean, cambios en el roll (azul) y yaw aplican la misma rotación (Fuente: Wikipedia)\n\n\n\n\n\n\nROS 2 no usa matrices directamente para las rotaciones porque son grandes (9 números para una rotación), difíciles de interpolar, y pueden perder ortogonalidad al acumular errores."
  },
  {
    "objectID": "clases/07/index.html#representación-de-rotaciones-1",
    "href": "clases/07/index.html#representación-de-rotaciones-1",
    "title": "Robótica",
    "section": "Representación de rotaciones",
    "text": "Representación de rotaciones\n\nCuaterniones: Representación más compacta y robusta\n\n\\[\n\\boldsymbol{q} = \\begin{pmatrix} x  \\\\ y \\\\ z \\\\ w  \\end{pmatrix}\n\\]\n\n\n\nLas poses ahora se componen de una traslación \\(\\boldsymbol t = \\begin{pmatrix} x & y & z  \\end{pmatrix}\\) y una orientación \\(\\boldsymbol{q}\\)\n\n\nEn vez de eso, usamos cuaterniones, que representan la rotación de forma más compacta (4 números) y más robusta para cálculos computacionales. Así como en 2D usamos un solo ángulo (theta) para representar la orientación, en 3D usamos un cuaternión."
  },
  {
    "objectID": "clases/07/index.html#representación-de-rotaciones-2",
    "href": "clases/07/index.html#representación-de-rotaciones-2",
    "title": "Robótica",
    "section": "Representación de rotaciones",
    "text": "Representación de rotaciones\n\nEjemplo: \\(\\boldsymbol{p} = \\begin{pmatrix} 1 & 0  \\end{pmatrix}^T\\) rotado \\(90^{\\circ}\\)\n\nÁngulo: \\(\\theta = 90^{\\circ} = \\tfrac{\\pi}{2}\\)\n\nMatriz de rotación: \\(\\boldsymbol{R} = \\begin{bmatrix} \\cos{\\theta} & -\\sin{\\theta} \\\\ \\sin{\\theta} & \\cos{\\theta} \\end{bmatrix} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix}\\)\n\n\nAplicamos: \\[\n\\boldsymbol{p}' = \\boldsymbol{R} \\cdot \\boldsymbol{p} = \\begin{bmatrix} 0 & -1 \\\\ 1 & 0 \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\end{bmatrix} \\Rightarrow \\boldsymbol{p}' =  \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n\\]"
  },
  {
    "objectID": "clases/07/index.html#representación-de-rotaciones-3",
    "href": "clases/07/index.html#representación-de-rotaciones-3",
    "title": "Robótica",
    "section": "Representación de rotaciones",
    "text": "Representación de rotaciones\n\nEjemplo: \\(\\boldsymbol{p} = \\begin{pmatrix} 1 & 0  \\end{pmatrix}^T\\) rotado \\(90^{\\circ}\\)\n\nCuaternion para rotación 2D: \\(\\boldsymbol{q} = \\begin{pmatrix} x=0 & y=0 & z=\\sin{ \\tfrac{\\theta}{2} } & w=\\cos{ \\tfrac{\\theta}{2} } \\end{pmatrix}\\)\n\n\\[\n\\text{con} \\, \\theta = \\tfrac{\\pi}{2} \\to  z=\\sin{ \\tfrac{\\pi}{4}} = \\frac{\\sqrt{2}}{2},\\quad  w=\\cos{ \\tfrac{\\pi}{4} } = \\frac{\\sqrt{2}}{2}\n\\]\n\n\nSe escribe \\(\\boldsymbol{p}\\) como cuaternion: \\(\\boldsymbol{p} = \\begin{pmatrix} 1 & 0 & 0 & 0 \\end{pmatrix}\\)\n\n\nAplicamos:\n\n\\[\n\\boldsymbol{q} \\circ \\boldsymbol{p} \\circ \\boldsymbol{q}^{-1} = \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix} \\begin{bmatrix} 1 \\\\ 0 \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{-\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix} = \\begin{bmatrix} \\frac{\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\\\ 0 \\\\ 0 \\end{bmatrix} \\begin{bmatrix} 0 \\\\ 0 \\\\ \\frac{-\\sqrt{2}}{2} \\\\ \\frac{\\sqrt{2}}{2} \\end{bmatrix} = \\begin{bmatrix} 0 \\\\ 1 \\\\ 0 \\\\ 0 \\end{bmatrix} \\Rightarrow \\boldsymbol{p}' =  \\begin{pmatrix} 0 \\\\ 1 \\end{pmatrix}\n\\]\n\n\n\n¿Por qué \\(\\theta / 2\\)?\nPorque los cuaterniones codifican media rotación internamente (por razones geométricas: la rotación se aplica como una conjugación, y termina duplicando el ángulo)."
  },
  {
    "objectID": "clases/07/index.html#librería-de-transformaciones",
    "href": "clases/07/index.html#librería-de-transformaciones",
    "title": "Robótica",
    "section": "Librería de transformaciones",
    "text": "Librería de transformaciones\n\n\nPor qué necesitamos una?\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nEjemplo: un robot con dos marcos, uno el centro del robot ‘base_link’ y otro en el centro del laser ‘base_laser’. Dada la información respecto del laser ‘base_laser’, es necesario transformar esa información respecto al ‘base_link’ (definir una relación entre los dos marcos de coordenadas). Según la figura, será necesario aplicar una traslación (x: 0.1[m], y: 0.0[m], z: 0.2[m]), para ir del ‘base_link’ al ‘base_laser’. Como se requiere la transformación opuesta, sería (x: -0.1[m], y: 0.0[m], z: -0.2[m])\nTF2 soluciona el problema de gestionar estas relaciones para que no lo tengamos que hacer por nuestra cuenta. Es útil sobre todo para escenarios no estáticos (99%).\n\n\nEjemplo extraido de docs.nav2.org"
  },
  {
    "objectID": "clases/07/index.html#tf2-librería-de-transformaciones",
    "href": "clases/07/index.html#tf2-librería-de-transformaciones",
    "title": "Robótica",
    "section": "tf2: Librería de transformaciones",
    "text": "tf2: Librería de transformaciones\n\n\n\n\nMarco de coordenadas y sus transformaciones en el tiempo\n\n\n\n\nEstructura de árbol (no existen bucles)\n\n\n\n\n\n\n\n\n\n\n\n\nHerramienta para seguir los marcos de coordenada a través del tiempo (4ta dimensión)\nMantiene las relaciones entre los marcos de coordenadas en una estructura de árbol buffereado en el tiempo\nCada nodo en el árbol es un marco de coordenadas, y cada conexión o arista corresponde a la transformación que debe ser aplicada para ir o venir\nArbol = no hay bucles = cada nodo 1 solo padre\nCada marco puede estar definido solo por una transformación desde otro marco\nPermite transformar puntos, vectores, etc entre marcos de coordenadas para un determinado tiempo"
  },
  {
    "objectID": "clases/07/index.html#tf2-librería-de-transformaciones-1",
    "href": "clases/07/index.html#tf2-librería-de-transformaciones-1",
    "title": "Robótica",
    "section": "tf2: Librería de transformaciones",
    "text": "tf2: Librería de transformaciones\n\nBasado en topics y mensajes tf2_msgs/msg/TFMessage\n\ngeometry_msgs/TransformStamped\n├── std_msgs/Header header\n├── string child_frame_id\n└── geometry_msgs/Transform transform\n    ├── geometry_msgs/Vector3 translation     ⬅️\n    └── geometry_msgs/Quaternion rotation     ⬅️\n\n\nNo se utilizan publishers/subscribers \\(\\to\\) la librería tf2_ros\n\n\n\n\n\n\n\n\n\nROS representa orientaciones como cuaterniones en todos los mensajes de pose y transformaciones\n\n\n\n\n\nSi bien se utilizan topics para manejar la comunicación, no se realiza una publicación/suscripción directa, sino a través de la librería por eso se dice broadcast/listen"
  },
  {
    "objectID": "clases/07/index.html#tf2-librería-de-transformaciones-2",
    "href": "clases/07/index.html#tf2-librería-de-transformaciones-2",
    "title": "Robótica",
    "section": "tf2: Librería de transformaciones",
    "text": "tf2: Librería de transformaciones\n\n2 Tipos de transformaciones: estáticas y dinámicas\n\n\n\n\nLas transformaciones pueden ser estáticas o dinámicas (si cambian o no en el tiempo). En el caso de las transformaciones estáticas pueden publicarse una sola vez y se asumen “actualizadas” hasta que se transmita una nueva.\n\n\nFuente: articulatedrobotics.xyz"
  },
  {
    "objectID": "clases/07/index.html#transformaciones-estáticas",
    "href": "clases/07/index.html#transformaciones-estáticas",
    "title": "Robótica",
    "section": "Transformaciones estáticas",
    "text": "Transformaciones estáticas\n\nNodo static_transform_publisher\n\n$ ros2 run tf2_ros static_transform_publisher\n   x=[x] y=[y] z=[z]\n   roll=[roll] pitch=[pitch] yaw=[yaw]\n   [parent_frame] [child_frame]"
  },
  {
    "objectID": "clases/07/index.html#herramientas-de-visualización-y-análisis",
    "href": "clases/07/index.html#herramientas-de-visualización-y-análisis",
    "title": "Robótica",
    "section": "Herramientas de visualización y análisis",
    "text": "Herramientas de visualización y análisis\n\nVer el árbol: ros2 run rqt_tf_tree rqt_tf_tree\nEcho: ros2 run tf2_ros tf2_echo &lt;marco_de_referencia&gt; &lt;marco_objetivo&gt;\nMonitor: ros2 run tf2_ros tf2_monitor\nVisualización mediante RViz: ros2 run rviz2 rviz2\n\n\n\nProblemas comunes: que falte un transformación o que esté mal"
  },
  {
    "objectID": "clases/07/index.html#publicar-transformaciones",
    "href": "clases/07/index.html#publicar-transformaciones",
    "title": "Robótica",
    "section": "Publicar transformaciones",
    "text": "Publicar transformaciones\n\nLibrerías\n\nfrom tf2_ros import TransformBroadcaster\nfrom geometry_msgs.msg import TransformStamped\n\n# Conversión ángulos de euler a cuaternion (librería transforms3d)\nfrom transforms3d.euler import euler2quat \n\n\n\n\n\n\nCompletar las dependencias del paquete\n&lt;depend&gt;tf2_ros_py&lt;/depend&gt;\n&lt;depend&gt;python3-transforms3d&lt;/depend&gt;\n\n\n\n\nMediante el objeto TransformBroadcaster se podrán enviar las transformaciones\n\n...\nclass FramePublisher(Node):\n    def __init__(self):\n        super().__init__('frame_publisher')\n\n        # Inicializar el broadcaster\n        self.tf_broadcaster = TransformBroadcaster(self)\n..."
  },
  {
    "objectID": "clases/07/index.html#publicar-transformaciones-1",
    "href": "clases/07/index.html#publicar-transformaciones-1",
    "title": "Robótica",
    "section": "Publicar transformaciones",
    "text": "Publicar transformaciones\n\nPublicar transformaciones\n\n...\n    def send_tf(self):\n        # Cálculo de los elementos de transformación\n        # Transformación = Traslación + Rotación\n        ...\n        tf = TransformStamped()\n\n        tf.header.stamp = self.get_clock().now().to_msg()\n        # Marco de referencia (padre)\n        tf.header.frame_id = 'world'  \n        # Marco objetivo (hijo)                      \n        tf.child_frame_id = 'robot'                 \n\n        # Traslación\n        tf.transform.translation.x = t_x\n        tf.transform.translation.y = t_y\n        tf.transform.translation.z = t_z\n\n        # Rotación\n        q = euler2quat(roll, pitch, yaw)  # Devuelve w x y z\n        tf.transform.rotation.x = q[1]\n        tf.transform.rotation.y = q[2]\n        tf.transform.rotation.z = q[3]\n        tf.transform.rotation.w = q[0]\n\n        # Enviar la transformación\n        self.tf_broadcaster.sendTransform(tf)"
  },
  {
    "objectID": "clases/07/index.html#laboratorio-1",
    "href": "clases/07/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nTransformaciones 2D y tf2"
  },
  {
    "objectID": "clases/13/index.html#simulación-de-sensores",
    "href": "clases/13/index.html#simulación-de-sensores",
    "title": "Robótica",
    "section": "Simulación de sensores",
    "text": "Simulación de sensores\n\nGazebo tiene la capacidad de simular sensores y publicar su salida en topics\n\n\nSe utiliza el tag &lt;sensor&gt;&lt;/sensor&gt; en el URDF\n\n&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre}\" type=\"{tipo}\"&gt;\n        &lt;!-- Atributos --&gt;\n    &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\nCada sensor tiene que estar referenciado a un link\nCada tipo de sensor tiene su implementación específica"
  },
  {
    "objectID": "clases/13/index.html#sensor-tipo-imu",
    "href": "clases/13/index.html#sensor-tipo-imu",
    "title": "Robótica",
    "section": "Sensor tipo IMU",
    "text": "Sensor tipo IMU\n\n\n\nParámetros\n\n\nTipo: imu\nPlugin: gz::sim::systems::Imu\nIniciar encendido (always_on)\nFrecuencia de datos en [Hz]\nTopic (de tipo gz.msgs.IMU)\n\n\n\n&lt;gazebo reference=\"imu_link\"&gt;\n  &lt;sensor name=\"imu\" type=\"imu\"&gt;\n    &lt;plugin\n      filename=\"gz-sim-imu-system\" \n      name=\"gz::sim::systems::Imu\"&gt;\n    &lt;/plugin&gt;\n\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n    &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n\n\n\n\n\n\nCon esa definición la IMU se comporta como un sensor ideal con mediciones casi perfectas"
  },
  {
    "objectID": "clases/13/index.html#simulando-ruido",
    "href": "clases/13/index.html#simulando-ruido",
    "title": "Robótica",
    "section": "Simulando ruido",
    "text": "Simulando ruido\n\nGazebo provee un motor de ruido para simular sensores reales\n\n\nEjemplo de ruido gaussiano\n\n&lt;noise type=\"gaussian\"&gt;\n  &lt;mean&gt;{media}&lt;/mean&gt;                        &lt;!-- Media --&gt;\n  &lt;stddev&gt;{desviacion_estandar}&lt;/stddev&gt;      &lt;!-- Desviación estándar --&gt;\n  &lt;bias_mean&gt;{corr_media}&lt;/bias_mean&gt;         &lt;!-- Corrimiento de la media --&gt;\n  &lt;bias_stddev&gt;{corr_dev_std}&lt;/bias_stddev&gt;   &lt;!-- Corrimiento de la dev. std. --&gt;\n  \n  &lt;!-- Corrimiento dinámico de la desviación estándar y bias --&gt;\n  &lt;dynamic_bias_stddev&gt;{dyn_bias_stddev}&lt;/dynamic_bias_stddev&gt;\n  &lt;!-- Corrimiento del bias a lo largo del tiempo --&gt;\n  &lt;dynamic_bias_correlation_time&gt;{dyn_bias_time}&lt;/dynamic_bias_correlation_time&gt;\n&lt;/noise&gt;"
  },
  {
    "objectID": "clases/13/index.html#ejemplo-bmi088",
    "href": "clases/13/index.html#ejemplo-bmi088",
    "title": "Robótica",
    "section": "Ejemplo: BMI088",
    "text": "Ejemplo: BMI088\n\n\n\nTable 4: Accelerometer specifications\n\nZero-g Offset (\\(\\mathrm{Off}\\)): \\(20 \\mathrm{[mg]}\\)\nOutput Data Rate (\\(\\mathrm{ODR}\\)): \\(12.5 - 1600 \\mathrm{[Hz]}\\)\nOutput Noise Density (\\(\\mathrm{n_{rms}}\\)): \\(190\\) (Z-axis) \\(160\\) (X- & Y-axis) \\(\\mathrm{[\\mu g / \\surd Hz]}\\)\n\nTable 5: Gyroscope specifications\n\nZero-rate Offset (\\(\\mathrm{Off \\, \\Omega_x \\Omega_y \\Omega_z}\\)): \\(\\pm 1 \\mathrm{[°/s]}\\)\nData rate: \\(2000, 1000, 400, 200, 100 \\mathrm{[Hz]}\\)\nOutput Noise (\\(\\mathrm{n_{rms}}\\)): \\(0.1 \\mathrm{[°/s]}\\)\n\n\n\n\n\n\n\n\n\n\nFuente: Bosch (www.bosch-sensortec.com)\n\n\n\n\n\nDatasheet BMI088 (www.bosch-sensortec.com)"
  },
  {
    "objectID": "clases/13/index.html#definición-de-los-parámetros",
    "href": "clases/13/index.html#definición-de-los-parámetros",
    "title": "Robótica",
    "section": "Definición de los parámetros",
    "text": "Definición de los parámetros\n\nEjemplo BMI088\n\n&lt;sensor name=\"imu\" type=\"imu\"&gt;\n  &lt;plugin\n    filename=\"gz-sim-imu-system\" \n    name=\"gz::sim::systems::Imu\"&gt;\n  &lt;/plugin&gt;\n\n  &lt;always_on&gt;1&lt;/always_on&gt;\n  &lt;update_rate&gt;100&lt;/update_rate&gt;\n  &lt;topic&gt;/imu/data&lt;/topic&gt;\n  &lt;visualize&gt;true&lt;/visualize&gt;\n\n  &lt;imu&gt;\n    &lt;linear_acceleration&gt;\n      &lt;x&gt;\n      &lt;noise type=\"gaussian\"&gt;\n        &lt;mean&gt;0.020&lt;/mean&gt;\n        &lt;stddev&gt;0.0016&lt;/stddev&gt;\n      &lt;/noise&gt;\n      &lt;/x&gt;\n      &lt;y&gt;\n        &lt;!-- Repite los parámetros de X --&gt;\n      &lt;/y&gt;\n      &lt;z&gt;\n      &lt;noise type=\"gaussian\"&gt;\n        &lt;mean&gt;0.020&lt;/mean&gt;\n        &lt;stddev&gt;0.0019&lt;/stddev&gt;\n      &lt;/noise&gt;\n      &lt;/z&gt;\n    &lt;/linear_acceleration&gt;\n    &lt;angular_velocity&gt;\n      &lt;x&gt;\n      &lt;noise type=\"gaussian\"&gt;\n        &lt;mean&gt;0.0174533&lt;/mean&gt;          &lt;!-- 1° en rad --&gt;\n        &lt;stddev&gt;0.00174533&lt;/stddev&gt;     &lt;!-- 0.1° en rad --&gt;\n      &lt;/noise&gt;\n      &lt;/x&gt;\n      &lt;y&gt;\n        &lt;!-- Repite los parámetros de X  --&gt;\n      &lt;/y&gt;\n      &lt;z&gt;\n        &lt;!-- Repite los parámetros de X --&gt;\n      &lt;/z&gt;\n    &lt;/angular_velocity&gt;\n  &lt;/imu&gt;\n&lt;/sensor&gt;"
  },
  {
    "objectID": "clases/13/index.html#sensor-tipo-lidar",
    "href": "clases/13/index.html#sensor-tipo-lidar",
    "title": "Robótica",
    "section": "Sensor tipo LiDAR",
    "text": "Sensor tipo LiDAR\n\n\n\nParámetros\n\n\nTipo: gpu_lidar\nPlugin: gz::sim::systems::Sensors\nTopic (de tipo gz.msgs.LaserScan)\n\n\n\n&lt;gazebo reference=\"lidar_link\"&gt;\n  &lt;sensor name=\"lidar\" type=\"gpu_lidar\"&gt;\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n    &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;lidar&gt;\n      &lt;scan&gt;\n        &lt;horizontal&gt;\n          &lt;samples&gt;{cantidad_rayos}&lt;/samples&gt;\n          &lt;resolution&gt;{res}&lt;/resolution&gt;\n          &lt;min_angle&gt;{min}&lt;/min_angle&gt;\n          &lt;max_angle&gt;{max}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;vertical&gt;\n          &lt;!-- Mismos parámetros --&gt;\n        &lt;/vertical&gt;\n      &lt;/scan&gt;\n      &lt;range&gt;\n        &lt;min&gt;{rango_min}&lt;/min&gt;\n        &lt;max&gt;{rango_max}&lt;/max&gt;\n        &lt;resolution&gt;{res_lineal}&lt;/resolution&gt;\n      &lt;/range&gt;\n      &lt;noise&gt;\n        &lt;type&gt;gaussian&lt;/type&gt;\n        &lt;mean&gt;{media}&lt;/mean&gt;\n        &lt;stddev&gt;{dev_std}&lt;/stddev&gt;\n      &lt;/noise&gt;\n    &lt;/lidar&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;"
  },
  {
    "objectID": "clases/13/index.html#sensor-tipo-lidar-1",
    "href": "clases/13/index.html#sensor-tipo-lidar-1",
    "title": "Robótica",
    "section": "Sensor tipo LiDAR",
    "text": "Sensor tipo LiDAR\n\n\n\nParámetros\n\n\nParámetros angulares (scan):\n\nCantidad de rayos\nResolución (angular)\nApertura (ángulo min. y max en °)\nPara un LiDAR 3D el valor de samples en vertical debe ser \\(\\mathrm{&gt; 1}\\)\n\nParámetros lineales (range):\n\nDistancia máxima y mínima a detectar\nResolución lineal\n\nParámetros de ruido gaussiano\n\n\n\n&lt;gazebo reference=\"lidar_link\"&gt;\n  &lt;sensor name=\"lidar\" type=\"gpu_lidar\"&gt;\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;{freq_hz}&lt;/update_rate&gt;\n    &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;lidar&gt;\n      &lt;scan&gt;\n        &lt;horizontal&gt;\n          &lt;samples&gt;{cantidad_rayos}&lt;/samples&gt;\n          &lt;resolution&gt;{res}&lt;/resolution&gt;\n          &lt;min_angle&gt;{min}&lt;/min_angle&gt;\n          &lt;max_angle&gt;{max}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;vertical&gt;\n          &lt;!-- Mismos parámetros --&gt;\n        &lt;/vertical&gt;\n      &lt;/scan&gt;\n      &lt;range&gt;\n        &lt;min&gt;{rango_min}&lt;/min&gt;\n        &lt;max&gt;{rango_max}&lt;/max&gt;\n        &lt;resolution&gt;{res_lineal}&lt;/resolution&gt;\n      &lt;/range&gt;\n      &lt;noise&gt;\n        &lt;type&gt;gaussian&lt;/type&gt;\n        &lt;mean&gt;{media}&lt;/mean&gt;\n        &lt;stddev&gt;{dev_std}&lt;/stddev&gt;\n      &lt;/noise&gt;\n    &lt;/lidar&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;"
  },
  {
    "objectID": "clases/13/index.html#ejemplo-2d-slamtec-s3m1-r2",
    "href": "clases/13/index.html#ejemplo-2d-slamtec-s3m1-r2",
    "title": "Robótica",
    "section": "Ejemplo 2D: Slamtec S3M1-R2",
    "text": "Ejemplo 2D: Slamtec S3M1-R2\n\n\n\nMeasurement Performance\n\nDistance Range: \\(0.05 - 15.0 \\mathrm{[m]}\\)\nScanning Frequency: Typ. \\(10 \\mathrm{[Hz]}\\)\nAngular Resolution: Typ. \\(0.1125 ^{\\circ}\\)\nAccuracy: \\(\\pm 30 \\mathrm{[mm]}\\)\nResolution: \\(10 \\mathrm{[mm]}\\)\n\n\n\n\n\n\n\n\n\n\nFuente: RobotShop (robotshop.com)\n\n\n\n\n\nDatasheet S3 (slamtec.com)"
  },
  {
    "objectID": "clases/13/index.html#definición-de-los-parámetros-1",
    "href": "clases/13/index.html#definición-de-los-parámetros-1",
    "title": "Robótica",
    "section": "Definición de los parámetros",
    "text": "Definición de los parámetros\n\nEjemplo S3M1-R2\n\n&lt;sensor name=\"lidar\" type=\"gpu_lidar\"&gt;\n    &lt;always_on&gt;true&lt;/always_on&gt;\n    &lt;update_rate&gt;10&lt;/update_rate&gt;\n    &lt;topic&gt;/scan&lt;/topic&gt;\n    &lt;visualize&gt;true&lt;/visualize&gt;\n\n    &lt;lidar&gt;\n      &lt;scan&gt;\n        &lt;horizontal&gt;\n          &lt;samples&gt;3200&lt;/samples&gt;     &lt;!-- 360/0.1125 --&gt;\n          &lt;resolution&gt;1&lt;/resolution&gt;\n          &lt;min_angle&gt;${-pi}&lt;/min_angle&gt;\n          &lt;max_angle&gt;${pi}&lt;/max_angle&gt;\n        &lt;/horizontal&gt;\n        &lt;!-- Al ser 2D no tiene parámetros verticales --&gt;\n      &lt;/scan&gt;\n      &lt;range&gt;\n        &lt;min&gt;0.05&lt;/min&gt;                 &lt;!-- 5 cm --&gt;\n        &lt;max&gt;15&lt;/max&gt;                   &lt;!-- 15 m --&gt;\n        &lt;resolution&gt;0.010&lt;/resolution&gt;  &lt;!-- 10 mm --&gt;\n      &lt;/range&gt;\n      &lt;noise&gt;\n        &lt;type&gt;gaussian&lt;/type&gt;\n        &lt;mean&gt;0.0&lt;/mean&gt;\n        &lt;stddev&gt;0.030&lt;/stddev&gt;          &lt;!-- 30 mm --&gt;\n      &lt;/noise&gt;\n    &lt;/lidar&gt;\n  &lt;/sensor&gt;"
  },
  {
    "objectID": "clases/13/index.html#objetos-para-detectar",
    "href": "clases/13/index.html#objetos-para-detectar",
    "title": "Robótica",
    "section": "Objetos para detectar",
    "text": "Objetos para detectar\n\nCambiar el entorno de Gazebo para agregar objetos: primitivas o modelos de Fuel\n\n\nOpción 1: Editar el mundo por defecto empty.sdf con Gazebo y exportarlo\nOpción 2: Generar un archivo .world en formato SDF"
  },
  {
    "objectID": "clases/13/index.html#cargar-un-archivo-world-en-gazebo",
    "href": "clases/13/index.html#cargar-un-archivo-world-en-gazebo",
    "title": "Robótica",
    "section": "Cargar un archivo world en Gazebo",
    "text": "Cargar un archivo world en Gazebo\n\nEn el archivo .launch.py\n\nfrom launch.substitutions import PathJoinSubstitution, TextSubstitution\n# ...\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution(\n                [FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py']\n            ),\n        ),\n        launch_arguments={\n            'gz_args': [\n                TextSubstitution(text=\"-r -v 4\"),\n                PathJoinSubstitution([\n                    FindPackageShare(\"&lt;nombre_paquete&gt;\"),\n                    'worlds',\n                    '&lt;nombre_archivo&gt;.world',\n                ]),\n            ]\n        }.items()\n    )"
  },
  {
    "objectID": "clases/13/index.html#topics-de-gazebo",
    "href": "clases/13/index.html#topics-de-gazebo",
    "title": "Robótica",
    "section": "Topics de Gazebo",
    "text": "Topics de Gazebo\n\nLos sensores publicarán topics de Gazebo\n\n\n\n\n\n\n\nSerá necesario “puentearlos” hacia ROS2 mediante el paquete ros_gz_bridge\n\n\n\n\n\n\nlaunch.py\n\n    Node(\n        package=\"ros_gz_bridge\",\n        executable=\"parameter_bridge\",\n        parameters=[{\n            \"config_file\": PathJoinSubstitution(\n                [FindPackageShare(\"&lt;nombre_paquete&gt;\"), \"config\", \"gz_bridge.yaml\"]\n            ),\n        }],\n    )\n\n\n\ngz_bridge.yaml\n\n- topic_name: \"&lt;nombre_topic&gt;\"\n  ros_type_name: \"&lt;tipo_topic_ROS&gt;\"\n  gz_type_name: \"&lt;tipo_topic_Gazebo&gt;\"\n  direction: &lt;direccion&gt; # GZ_TO_ROS | ROS_TO_GZ | BIDIRECTIONAL\n  lazy: true"
  },
  {
    "objectID": "clases/13/index.html#mensajes-de-imu",
    "href": "clases/13/index.html#mensajes-de-imu",
    "title": "Robótica",
    "section": "Mensajes de IMU",
    "text": "Mensajes de IMU\n\nGazebo: gz.msgs.IMU\nROS2: sensor_msgs/msg/Imu\n\nsensor_msgs/Imu\n├── std_msgs/Header header\n├── geometry_msgs/Quaternion\n|   ├── float64 x\n|   ├── float64 y\n|   ├── float64 z\n|   └── float64 w\n├── float64[9] orientation_covariance\n|\n├── geometry_msgs/Vector3 angular_velocity      # Velocidad rotacional en rad/s\n|   ├── float64 x\n|   ├── float64 y\n|   └── float64 z\n├── float64[9] orientation_covariance\n|\n├── geometry_msgs/Vector3 linear_acceleration   # Aceleraciones en m/s^2\n|   ├── float64 x\n|   ├── float64 y\n|   └── float64 z\n└── float64[9] orientation_covariance\n\n\nDefinición del mensaje (docs.ros.org)"
  },
  {
    "objectID": "clases/13/index.html#mensajes-de-lidar",
    "href": "clases/13/index.html#mensajes-de-lidar",
    "title": "Robótica",
    "section": "Mensajes de LIDAR",
    "text": "Mensajes de LIDAR\n\nGazebo: gz.msgs.LaserScan\nROS2: sensor_msgs/msg/LaserScan\n\nsensor_msgs/LaserScan\n├── std_msgs/Header header\n├── float32 angle_min           # Angulo incial [rad]\n├── float32 angle_max           # Angulo final [rad]\n├── float32 angle_increment     # Distancia angular entre mediciones [rad]\n|\n├── float32 time_increment      # Tiempo entre mediciones [seconds]\n├── float32 scan_time           # Tiempo entre scans [seconds]\n|\n├── float32 range_min           # Rango mínimo [m]\n├── float32 range_max           # Rango máximo [m]\n|\n├── float32[] ranges            # Valores de rango medidos [m]\n└── float32[] intensities       # Intensidades de luminosidad medidas\n\n\nDefinición del mensaje (docs.ros.org)"
  },
  {
    "objectID": "clases/13/index.html#laboratorio-1",
    "href": "clases/13/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nSimulación de sensores y aplicación"
  },
  {
    "objectID": "clases/09/index.html#gazebo-1",
    "href": "clases/09/index.html#gazebo-1",
    "title": "Robótica",
    "section": "Gazebo",
    "text": "Gazebo\n\n\n\nImportancia de los entornos de simulación\nGratuito y open-source\nMantenido por Open Robotics (ROS)\n\n\n\n\n\n\n\n\ngazebosim.org\n\n\n\n\nProbar en hardware real muchas veces es caro y además consume mucho esfuerzo y tiempo\nLas acciones de ciertos robots pueden contener peligro y “deployar” código no probado puede suponer un alto riesgo\nA veces el hardware real puede introducir una serie de problemas que no permiten el correcto desarrollo de software (relacionado con aislar variables)\n\nPor estas razones es apropiado desarrollar entornos de simulación precisos. Gazebo es uno, gratuito y open-source.\nEl proyecto es mantenido por el grupo “Open Robotics” que se encuentra detrás de ROS también, sin embargo son dos proyectos separados.\n\n\nDocumentación: gazebosim.org/docs/harmonic"
  },
  {
    "objectID": "clases/09/index.html#gazebo-ros",
    "href": "clases/09/index.html#gazebo-ros",
    "title": "Robótica",
    "section": "Gazebo + ROS",
    "text": "Gazebo + ROS\n\nEntorno virtual que reemplaza al real\n\n\nRobot simulado que reemplaza al real\n\n\nLectura de sensores simulados\nComandar actuadores virtuales\nObtener feedback de los comandos\n\n\nCon Gazebo se crea un entorno o mundo virtual, y se carga la versión simulada del robot.\nLos sensores simulados pueden detectar el entorno virtual y publicar la información a los mismos topics de ROS como un sensor real lo haría, permitiendo probar algoritmos de forma fácil.\nLuego se pueden aplicar comandos a los actuadores simulados en el robot para así probar la respuesta del sistema."
  },
  {
    "objectID": "clases/09/index.html#sistema-con-joint_state_publisher_gui",
    "href": "clases/09/index.html#sistema-con-joint_state_publisher_gui",
    "title": "Robótica",
    "section": "Sistema con joint_state_publisher_gui",
    "text": "Sistema con joint_state_publisher_gui\n\n\nSe utilizaba joint_state_publisher_gui para crear datos fakes en el topic /joint_states para que el robot_state_publisher publique las transformaciones"
  },
  {
    "objectID": "clases/09/index.html#sistema-con-gazebo",
    "href": "clases/09/index.html#sistema-con-gazebo",
    "title": "Robótica",
    "section": "Sistema con Gazebo",
    "text": "Sistema con Gazebo\n\n\nCon Gazebo se busca representar el mundo real, un robot físico con el que interactuar de varias maneras. Por ejemplo, que se mueva basado en una entrada de control, leer la información de los sensores, y obtener un feedback de los actuadores."
  },
  {
    "objectID": "clases/09/index.html#ejcutar-gazebo-con-ros2",
    "href": "clases/09/index.html#ejcutar-gazebo-con-ros2",
    "title": "Robótica",
    "section": "Ejcutar Gazebo con ROS2",
    "text": "Ejcutar Gazebo con ROS2\n\nDesde la linea de comando\n\n$ ros2 launch ros_gz_sim gz_sim.launch.py gz_args:=empty.sdf\n\nDesde archivo launch\n\n    IncludeLaunchDescription(\n        PythonLaunchDescriptionSource(\n            PathJoinSubstitution([\n                FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py'\n            ]),\n        ),\n        launch_arguments={\n            'gz_args': '-r empty.sdf',\n            'on_exit_shutdown': 'True'\n        }.items(),\n    ),"
  },
  {
    "objectID": "clases/09/index.html#sdf-simulation-description-format",
    "href": "clases/09/index.html#sdf-simulation-description-format",
    "title": "Robótica",
    "section": "SDF: Simulation Description Format",
    "text": "SDF: Simulation Description Format\n\nGazebo utiliza archivos SDF (\\(\\neq\\) URDF)\nPermite describir un mundo (además de modelos)\n\n\n\n\n\n\n\n\nSe puede convertir URDF a SDF, pero se necesitan ajustes\n\n\n\n\nNo es necesario escribir un URDF y un SDF para el robot, Gazebo convierte el primero en el segundo, siempre y cuando se realicen ciertas modificaciones o agregados para que pueda trabajar correctamente con Gazebo.\nEsto permite combinar nuestro robot con variedad de modelos y entornos creados por la comunidad (online)"
  },
  {
    "objectID": "clases/09/index.html#gazebo-y-urdf",
    "href": "clases/09/index.html#gazebo-y-urdf",
    "title": "Robótica",
    "section": "Gazebo y URDF",
    "text": "Gazebo y URDF\n\nPara agregar elementos de Gazebo:\n\n&lt;gazebo&gt; .. &lt;/gazebo&gt;\n\nPara hacer referencia a elementos del URDF:\n\n&lt;gazebo name=\"[nombre_link|joint|etc]\"&gt;\n\nPara agregar elementos específicos de Gazebo se utilizan tags &lt;gazebo&gt;&lt;/gazebo&gt;. Esto permite capturar el contenido para generar los archivos SDF e ignorar el resto de contenido."
  },
  {
    "objectID": "clases/09/index.html#gazebo-y-urdf-1",
    "href": "clases/09/index.html#gazebo-y-urdf-1",
    "title": "Robótica",
    "section": "Gazebo y URDF",
    "text": "Gazebo y URDF\n\nRequisitos:\n\n\nNombramiento\nPropiedades inerciales\nMateriales y colores\n\n\n\nNombres o nombramiento: Para evitar conflictos se recomienda nombrar cada junta y cada link con un nombre único (ej utilizando _joint y _link respectivamente)\nCombinación de links: Gazebo toma los links unidos por juntas fijas y los combina en un solo SDF link, no sería un problema pero puede quedar confuso a veces\nPropiedades inerciales: Gazebo requiere que cada link posea su tag intertial asociado\nWorld links: En el caso de que el robot esté fijo al suelo, el primer link debe ser nombrado world, y Gazebo mantendrá fijo ese link más allá del de la física. Para un robot móvil el primer link NO debe llamarse world\nMateriales y colores: Gazebo no utiliza los materiales definidos en el URDF. Es necesario utilizar el tag gazebo para cada link y especificar el material apropiado allí"
  },
  {
    "objectID": "clases/09/index.html#gazebo-y-urdf-collision",
    "href": "clases/09/index.html#gazebo-y-urdf-collision",
    "title": "Robótica",
    "section": "Gazebo y URDF: <collision>",
    "text": "Gazebo y URDF: &lt;collision&gt;\n\nDeben definirse los elementos de colisión para cada link\n\n&lt;link name=\"[nombre_link]\"&gt;\n    ..\n    &lt;collision&gt;\n        &lt;origin xyz=\"[origen]\" rpy=\"[orientacion]\"/&gt;\n        &lt;geometry&gt;\n            &lt;!-- Prisma --&gt;\n            &lt;box size=\"[largo] [ancho] [alto]\"/&gt;\n            &lt;!-- Cilindro --&gt;\n             &lt;cylinder radius=\"[radio]\" length=\"[ancho]\" /&gt;\n            &lt;!-- Esfera --&gt;\n            &lt;sphere radius=\"[radio]\" /&gt;\n        &lt;/geometry&gt;\n    &lt;/collision&gt;\n    ..\n&lt;/link&gt;\n\n\nEl tag de colisión es al mismo nivel que el tag &lt;visual&gt;\nEl elemento de colisión define la geometría igual que el visual\nSe puede especificar un origen específico"
  },
  {
    "objectID": "clases/09/index.html#gazebo-y-urdf-inertial",
    "href": "clases/09/index.html#gazebo-y-urdf-inertial",
    "title": "Robótica",
    "section": "Gazebo y URDF: <inertial>",
    "text": "Gazebo y URDF: &lt;inertial&gt;\n\nDeben definirse las propiedades físicas para cada link\n\n&lt;link name=\"[nombre_link]\"&gt;\n    ..\n    &lt;inertial&gt;\n        &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n        &lt;mass value=\"[masa_kg]\"/&gt;\n        &lt;inertia ixx=\"[I_xx]\" ixy=\"[I_xy]\" ixz=\"[I_xz]\"\n                              iyy=\"[I_yy]\" iyz=\"[I_yz]\"\n                                           izz=\"[I_zz]\"/&gt;\n    &lt;/inertial&gt;\n    ..\n&lt;/link&gt;\n\n\nLa masa se define en kilogramo\nLa matriz 3x3 rotacional de inercia se especifica con el tag inertia\nAl ser simétrica se especifican los 6 elementos por separado\nLa inercia depende de la distribución de la masa del objeto\nMediante el tag origin se especifica el centro de gravedad"
  },
  {
    "objectID": "clases/09/index.html#inertial_macros.xacro",
    "href": "clases/09/index.html#inertial_macros.xacro",
    "title": "Robótica",
    "section": "inertial_macros.xacro",
    "text": "inertial_macros.xacro\n\nSe facilita un archivo XACRO para el cálculo de las inercias según la geometría\n\n\nPrisma\n\n    &lt;xacro:inertial_box mass=\"[masa_kg]\" x=\"[largo]\" y=\"[ancho]\" z=\"[alto]\"&gt;\n        &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n    &lt;/xacro:inertial_box&gt;\n\nCilindro\n\n    &lt;xacro:inertial_cylinder mass=\"[masa_kg]\" radius=\"[radio]\" length=\"[ancho]\"&gt;\n        &lt;origin xyz=\"[traslacion]\" rpy=\"[rotacion]\"/&gt;\n    &lt;/xacro:inertial_cylinder&gt;\n\nPara cuando sea necesario una inercia despreciable\n\n    &lt;dummy_inertial /&gt;\n\n\nTensores de inercia"
  },
  {
    "objectID": "clases/09/index.html#importar-urdf-en-gazebo",
    "href": "clases/09/index.html#importar-urdf-en-gazebo",
    "title": "Robótica",
    "section": "Importar URDF en Gazebo",
    "text": "Importar URDF en Gazebo\n\nDada la descripción del robot disponible en el topic /robot_description (y Gazebo ejecutandose)\n\n\nDesde la linea de comando:\n\n$ ros2 run ros_gz_sim create -topic robot_description -entity &lt;nombre_robot&gt;\n\nDesde archivo launch\n\n    Node(\n        package=\"ros_gz_sim\",\n        executable=\"create\",\n        arguments=[\n            \"-entity\", \"&lt;nombre_robot&gt;\",\n            \"-topic\", \"robot_description\",\n        ],\n        output=\"screen\",\n    )"
  },
  {
    "objectID": "clases/09/index.html#ros2_control",
    "href": "clases/09/index.html#ros2_control",
    "title": "Robótica",
    "section": "ros2_control",
    "text": "ros2_control\n\nConjunto de paquetes para desarrollar controladores genéricos para todo tipo de robots"
  },
  {
    "objectID": "clases/09/index.html#ros2_control-gazebo-gz_ros2_control",
    "href": "clases/09/index.html#ros2_control-gazebo-gz_ros2_control",
    "title": "Robótica",
    "section": "ros2_control + Gazebo = gz_ros2_control",
    "text": "ros2_control + Gazebo = gz_ros2_control"
  },
  {
    "objectID": "clases/09/index.html#actualizar-el-urdf",
    "href": "clases/09/index.html#actualizar-el-urdf",
    "title": "Robótica",
    "section": "Actualizar el URDF",
    "text": "Actualizar el URDF\n\nDefinir un hardware simulado con &lt;ros2_control&gt;\n\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    &lt;hardware&gt;\n        &lt;plugin&gt;gz_ros2_control/GazeboSimSystem&lt;/plugin&gt;\n    &lt;/hardware&gt;\n    ...\n&lt;/ros2_control&gt;\n\nAñadir el plugin de gz_ros2_control:\n\n&lt;gazebo&gt;\n    &lt;plugin filename=\"gz_ros2_control-system\"\n            name=\"gz_ros2_control::GazeboSimROS2ControlPlugin\" /&gt;\n&lt;/gazebo&gt;"
  },
  {
    "objectID": "clases/09/index.html#actualizar-el-urdf-1",
    "href": "clases/09/index.html#actualizar-el-urdf-1",
    "title": "Robótica",
    "section": "Actualizar el URDF",
    "text": "Actualizar el URDF\n\nDefinir interfaces para las juntas:\n\nInterfaces de estado: &lt;state_interface ../&gt;\nInterfaces de comando &lt;command_interface .. /&gt;\n\n\n\nEn ambos casos pueden ser:\n\nde posición\nde velocidad\nde esfuerzo"
  },
  {
    "objectID": "clases/09/index.html#actualizar-el-urdf-2",
    "href": "clases/09/index.html#actualizar-el-urdf-2",
    "title": "Robótica",
    "section": "Actualizar el URDF",
    "text": "Actualizar el URDF\n\nEjemplo control de velocidad y sensado de posición y velocidad\n\n&lt;ros2_control name=\"GazeboSystem\" type=\"system\"&gt;\n    ...\n    &lt;joint name=\"[nombre_junta]\"&gt;\n        &lt;command_interface name=\"velocity\"&gt;\n            &lt;!-- Límite de 10 rpm --&gt;\n            &lt;param name=\"min\"&gt;-1.047198&lt;/param&gt;\n            &lt;param name=\"max\"&gt;1.047198&lt;/param&gt;\n        &lt;/command_interface&gt;\n        &lt;state_interface name=\"position\" /&gt;\n        &lt;state_interface name=\"velocity\" /&gt;\n    &lt;/joint&gt;\n    ...\n&lt;/ros2_control&gt;"
  },
  {
    "objectID": "clases/09/index.html#definir-controladores",
    "href": "clases/09/index.html#definir-controladores",
    "title": "Robótica",
    "section": "Definir controladores",
    "text": "Definir controladores\n\nMediante un archivo de configuración YAML\n\ncontroller_manager:\n  ros__parameters:\n    update_rate: 30\n    use_sim_time: true\n\n    # NOMBRE_CONTROLADOR\n    #  type: TIPO_CONTROLADOR\n\n    joint_broadcaster:\n        type: joint_state_broadcaster/JointStateBroadcaster\n\n    velocity_controller:\n        type: velocity_controllers/JointGroupVelocityController"
  },
  {
    "objectID": "clases/09/index.html#definir-parámetros",
    "href": "clases/09/index.html#definir-parámetros",
    "title": "Robótica",
    "section": "Definir parámetros",
    "text": "Definir parámetros\n\nMediante un archivo de configuración YAML\n\nvelocity_controller:\n  ros__parameters:\n    joints:\n        - {nombre_junta}\n\n    command_interfaces:\n        - velocity\n\n    state_interfaces:\n        - position\n        - velocity"
  },
  {
    "objectID": "clases/09/index.html#cargar-controladores",
    "href": "clases/09/index.html#cargar-controladores",
    "title": "Robótica",
    "section": "Cargar controladores",
    "text": "Cargar controladores\n\nDesde la linea de comando\n\n    $ ros2 control load_controller --set-state active\n                &lt;nombre_controlador&gt;\n\nDesde archivo launch\n\n    ExecuteProcess(\n        cmd=['ros2', 'control', 'load_controller',\n             '--set-state', 'active',\n             '&lt;nombre_controlador&gt;'],\n        output='screen'\n    )"
  },
  {
    "objectID": "clases/09/index.html#comandos-de-ros2_control",
    "href": "clases/09/index.html#comandos-de-ros2_control",
    "title": "Robótica",
    "section": "Comandos de ros2_control",
    "text": "Comandos de ros2_control\n\nListar componentes de hardware disponibles\n\n    $ ros2 control list_hardware_components\n\nListar interfaces de hardware disponibles\n\n    $ ros2 control list_hardware_interfaces\n\nListar controladores disponibles (para cargar)\n\n    $ ros2 control list_controller_types\n\nListar controladores cargados\n\n    $ ros2 control list_controllers\n\n\nMás comandos"
  },
  {
    "objectID": "clases/09/index.html#taller-de-resolución-1",
    "href": "clases/09/index.html#taller-de-resolución-1",
    "title": "Robótica",
    "section": "Taller de resolución",
    "text": "Taller de resolución\nEjercicios 3 y 4"
  },
  {
    "objectID": "clases/06/lab.html",
    "href": "clases/06/lab.html",
    "title": "Clase 06 - Laboratorio",
    "section": "",
    "text": "En el constructor del nodo a través del atributo self:\n\n  self.declare_parameter('&lt;nombre_parametro&gt;', &lt;valor&gt;)\n\n\n\n\n\n\n\nEl tipo es inferido a través del valor\n\n\n\n\n\n\n\nTipo texto (string):\n\n  self.get_parameter('&lt;nombre_parametro&gt;')\n          .get_parameter_value().string_value\n\nTipo entero (int), decimal (double), booleano (bool), es igual:\n\n  self.get_parameter('&lt;nombre_parametro&gt;').get_parameter_value().string_value.&lt;int|double|bool&gt;_value"
  },
  {
    "objectID": "clases/06/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/06/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 06 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/06/lab.html#programación-de-nodos-con-parámetros",
    "href": "clases/06/lab.html#programación-de-nodos-con-parámetros",
    "title": "Clase 06 - Laboratorio",
    "section": "",
    "text": "En el constructor del nodo a través del atributo self:\n\n  self.declare_parameter('&lt;nombre_parametro&gt;', &lt;valor&gt;)\n\n\n\n\n\n\n\nEl tipo es inferido a través del valor\n\n\n\n\n\n\n\nTipo texto (string):\n\n  self.get_parameter('&lt;nombre_parametro&gt;')\n          .get_parameter_value().string_value\n\nTipo entero (int), decimal (double), booleano (bool), es igual:\n\n  self.get_parameter('&lt;nombre_parametro&gt;').get_parameter_value().string_value.&lt;int|double|bool&gt;_value"
  },
  {
    "objectID": "clases/06/lab.html#programación-de-archivos-launch",
    "href": "clases/06/lab.html#programación-de-archivos-launch",
    "title": "Clase 06 - Laboratorio",
    "section": "Programación de archivos launch",
    "text": "Programación de archivos launch\n\nAdecuación del paquete para albergar los archivos\n\nCrear una carpeta launch\n\nCrear la carpeta launch que contendrá los archivos\n\n📂 src\n  📂 clase_06\n      📂 launch                           ⬅️\n          📄 nombre_archivo.launch.py     ⬅️\n          ...\n      📁 resource\n      📁 test\n      📄 package.xml\n      ...\n\n\nModificar el archivo setup.py\n\nModificar la configuración de data_files para instalar correctamente los archivos launch\n\n\nsetup.py\n\nfrom setuptools import setup\n\nimport os\nfrom glob import glob\n\npackage_name = 'nombre_paquete'\n\nsetup(\n  name=package_name,\n  # Otros parámetros ...\n  data_files=[\n    # ... Otros archivos\n    # Incluir todos los archivos de la carpeta launch\n    (os.path.join('share', package_name, 'launch'), glob('launch/*'))\n  ],\n  # El resto de la configuración ...\n)\n\n\n\n\n\n\n\nSe recomienda agregar ros2launch como dependencia de ejecución:\n    &lt;exec_depend&gt;ros2launch&lt;/exec_depend&gt;\n\n\n\n\n\n\nProgramación del launch\n\nImportar las librerías launch y launch_ros\n\nfrom launch import LaunchDescription\nfrom launch_ros import actions\n\nDefinir la función generate_launch_description que devolverá el LaunchDescription\n\ndef generate_launch_description():\n    ...\n    return LaunchDescription([\n        # Contenido del launch\n        ...\n    ])\n\nActions: Ejecutar un nodo\n\nImportar la librería\nfrom launch_ros.actions import Node\nCrear la acción\ndef generate_launch_description():\n    node = Node(\n        package = '&lt;nombre_paquete&gt;',\n        executable = '&lt;nombre_ejecutable&gt;',\n        # Adicionales (según corresponda) ⬇️\n        name = '&lt;nombre_nodo&gt;',\n        namespace = '&lt;nombre_namespace&gt;',\n        parameters = [ # Pueden ser archivos\n            {'&lt;nombre_parametro&gt;': &lt;valor&gt;, .. }\n        ],\n        remappings = [\n            ('&lt;nombre_topic&gt;', '&lt;nuevo_nombre&gt;'),\n        ],\n        output = '&lt;screen|log|both&gt;',\n        ros_arguments = [...],\n        arguments = [...],\n    )\n\n    return LaunchDescription([\n        node,\n        ...\n    ])\n\n\n\n\n\n\nNote\n\n\n\nNo es necesario completar todos los campos, los requeridos son los mínimos para el comando ros2 run: package y executable\n\n\n\nDeclaración de argumentos\n\nImportar la librería\nfrom launch.substitutions import LaunchConfiguration\nfrom launch.actions import DeclareLaunchArgument\nPrimero declarar los argumentos con DeclareLaunchArgument y luego utilizarlos mediante las sustituciones LaunchConfiguration\n...\ndef generate_launch_description():\n  return LaunchDescription([\n    DeclareLaunchArgument(\n      '&lt;nombre_parametro&gt;', default_value=&lt;valor&gt;\n    ),\n    Node(\n        package = '&lt;nombre_paquete&gt;',\n        executable = '&lt;nombre_ejecutable&gt;',\n        ...\n        parameters=[{\n            '&lt;parametro_del_nodo&gt;': LaunchConfiguration('&lt;nombre_parametro&gt;'),\n        }]\n    ),\n  ])"
  },
  {
    "objectID": "clases/06/lab.html#uso-de-loggers",
    "href": "clases/06/lab.html#uso-de-loggers",
    "title": "Clase 06 - Laboratorio",
    "section": "Uso de loggers",
    "text": "Uso de loggers\n\nGenerar un mensaje de log\n\n\n  &lt;nodo&gt;.get_logger().{debug,info,warning,error,fatal}\n            ('&lt;mensaje_de_log&gt;')\n\n\nself.get_logger().info('Mensaje de prueba con severidad INFO')\n\nGenerar un mensaje de log por única vez\n\n\n  &lt;nodo&gt;.get_logger().{debug,info,warning,error,fatal}\n            ('&lt;mensaje_de_log&gt;', once=True)\n\n\nself.get_logger().warn('Advertencia una sola vez', once=True)\n\nEnviar el mensaje como máximo N veces por segundo\n\n\n  &lt;nodo&gt;.get_logger().{debug,info,warning,error,fatal}\n            ('&lt;mensaje_de_log&gt;', throttle_duration_sec=&lt;N&gt;)\n\n\nself.get_logger().debug(f'Valor de la medicion {valor}', throttle_duration_sec=1)"
  },
  {
    "objectID": "clases/06/lab.html#crear-el-nodo-temperature_sensor",
    "href": "clases/06/lab.html#crear-el-nodo-temperature_sensor",
    "title": "Clase 06 - Laboratorio",
    "section": "Crear el nodo: temperature_sensor",
    "text": "Crear el nodo: temperature_sensor\n\nEl valor de temperatura es generado a partir de un valor base (base_temperature) con una variación aleatoria máxima (max_variation) configurable ambas mediante parámetros\nPublica en el topic \\temperature utilizando el tipo de mensaje sensor_msgs/msg/Temperature\n\n\n\nEnviar un mensaje de log que muestre la temperatura generada (info o debug)\nAdemás agregar un parámetro de configuración de la frecuencia de publicación en Hz (publish_rate)\n\n\n\n\n\n\n\n\n\n\nNombre\nTipo\nDescripción\nValor por defecto\n\n\n\n\nbase_temperature\nfloat\nTemperatura inicial/base en grados Celsius\n25.0\n\n\nmax_variation\nfloat\nMáxima variación aleatoria\n5.0\n\n\npublish_rate\nint\nFrecuencia de publicación en Hz\n1\n\n\n\n\nPara generar la temperatura puedes utilizar la función uniform de la librería random\ntemperature = base_temperature + random.uniform(-max_variation, max_variation)\n\nbase_temperature: valor base\nmax_variation: cuánto puede subir o bajar como máximo en cada medición\nrandom.uniform(a, b): genera un número flotante aleatorio entre a y b.\n\n\n\n\n\n\n\n\nNoteOpcional\n\n\n\nUno de los campos del mensaje de tipo Temperature es el header, que contiene un stamp de tipo Time y un frame_id, puedes completar dichos campos opcionalmente\nPara obtener un stamp actual puedes utilizar el método get_clock de la clase Node de ROS:\nmsg.header.stamp = self.get_clock().now().to_msg()\nmsg.header.frame_id = 'sensor1'"
  },
  {
    "objectID": "clases/06/lab.html#crear-el-nodo-temperature_monitor",
    "href": "clases/06/lab.html#crear-el-nodo-temperature_monitor",
    "title": "Clase 06 - Laboratorio",
    "section": "Crear el nodo temperature_monitor",
    "text": "Crear el nodo temperature_monitor\n\nSuscribe al topic \\temperature y por cada mensaje verifica si la temperatura supera un umbral crítico configurable mediante un parámetro alarm_threshold\nAgregar un parámetro de configuración temperature_unit que definirá la unidad utilizada para el umbral y las alertas de temperatura\n\n\n\n\n\n\n\nTipConversión °C a °F\n\n\n\n\\[\nT \\, [°F]  = T \\, [°C] \\times 9/5 + 32\n\\]\n\n\n\nSi supera el umbral imprime un mensaje de alarma con severidad warn y si no publicar la temperatura recibida con severidad info o debug"
  },
  {
    "objectID": "clases/06/lab.html#probar-el-sistema-mediante-ros2-run",
    "href": "clases/06/lab.html#probar-el-sistema-mediante-ros2-run",
    "title": "Clase 06 - Laboratorio",
    "section": "Probar el sistema mediante ros2 run",
    "text": "Probar el sistema mediante ros2 run\n\nEjecutar ambos nodos desde consola comprobando el funcionamiento de los valores por defecto de los parámetros y el funcionamiento del sistema en su conjunto\nProbar distintas ejecuciones variando los parámetros definidos y probar cambios de parámetros durante la ejecución, comprobando cuales tienen efecto inmediato y cuales requieren reinciar el nodo\nComprobar el funcionamiento de los mensajes de log según distintos niveles de severidad seteados para cada nodo"
  },
  {
    "objectID": "clases/06/lab.html#crear-el-archivo-launch-para-ambos-nodos",
    "href": "clases/06/lab.html#crear-el-archivo-launch-para-ambos-nodos",
    "title": "Clase 06 - Laboratorio",
    "section": "Crear el archivo launch para ambos nodos",
    "text": "Crear el archivo launch para ambos nodos\n\nIniciar ambos nodos\n\ntemperature_sensor con una temperatura base de 27°C y una variación máxima de 5°C, con una frecuencia de publicación de 2Hz.\ntemperature_monitor con un umbral en 30°C\n\nDeclarar los argumentos necesarios para poder configurar los parámetros establecidos en ambos nodos\nAmbos nodos deben enviar la salida por la consola con nivel de severidad info"
  },
  {
    "objectID": "clases/06/lab.html#probar-el-sistema-mediante-ros2-launch",
    "href": "clases/06/lab.html#probar-el-sistema-mediante-ros2-launch",
    "title": "Clase 06 - Laboratorio",
    "section": "Probar el sistema mediante ros2 launch",
    "text": "Probar el sistema mediante ros2 launch\n\nEjecutar el archivo launchcreado para verificar el funcionamiento de los parámetros por defecto\nProbar distintas ejecuciones variando los parámetros definidos"
  },
  {
    "objectID": "clases/05/lab.html",
    "href": "clases/05/lab.html",
    "title": "Clase 05 - Laboratorio",
    "section": "",
    "text": "Se recomienda crear un paquete nuevo, distinto del utilizado en el lab anterior\n\n\n\n\n\n\nimport rclpy\nfrom rclpy.node import Node\n\n\n\n\nclass &lt;nombre_clase&gt;(Node):\n    __init__(self):\n        super().__init__(&lt;nombre_nodo&gt;)\n        ...\n\n\n\n\nSe crean de la mismas manera solo que en vez de utilizar la instancia &lt;nodo&gt; se accederá a través del objeto mediante el atributo self.\n\n  self.create_publisher(\n          &lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;tamaño_cola&gt;)\n\n\n\n  self.create_timer(&lt;periodo_en_seg&gt;, &lt;funcion_callback&gt;)\n\n\n\n  self.create_subscription(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;',\n                               &lt;funcion_callback&gt;, &lt;tamaño_cola&gt;)\n\n\n\n\n\nLas funciones de callback serán métodos de la clase\nclass &lt;nombre_clase&gt;(Node):\n    ...\n    def timer_callback(self):\n        ...\n        # Publicar el mensaje\n        self.pub.publish(self.msg)\n\n\n\nSolo será utilizada para la inicialización o init, la creación del nodo (instanciando la clase), el spin y la finalización o shutdown\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n\n\n\nPuedes reutilizar el código del lab anterior\n\n\n\n\n\n\n\n\n\nNoteRecordatorio\n\n\n\nSi se crea un paquete nuevo recuerda:\n\nCompletar las dependencias en package.xml e instalar mediante rosdep\nCrear el o los ejecutables en setup.py\nCompilar el paquete con colcon\nconfigurar el entorno: source install/setup.bash\n\n\n\n\n\n\n\n\n\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\n\nPuedes utilizar los comandos de ros2 node list y ros2 node info\n\n\n\nPuedes utilizar los comandos de ros2 topic list, ros2 topic info y ros2 topic echo"
  },
  {
    "objectID": "clases/05/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/05/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 05 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/05/lab.html#programación-orientada-a-objetos-en-ros-2",
    "href": "clases/05/lab.html#programación-orientada-a-objetos-en-ros-2",
    "title": "Clase 05 - Laboratorio",
    "section": "",
    "text": "Se recomienda crear un paquete nuevo, distinto del utilizado en el lab anterior\n\n\n\n\n\n\nimport rclpy\nfrom rclpy.node import Node\n\n\n\n\nclass &lt;nombre_clase&gt;(Node):\n    __init__(self):\n        super().__init__(&lt;nombre_nodo&gt;)\n        ...\n\n\n\n\nSe crean de la mismas manera solo que en vez de utilizar la instancia &lt;nodo&gt; se accederá a través del objeto mediante el atributo self.\n\n  self.create_publisher(\n          &lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;', &lt;tamaño_cola&gt;)\n\n\n\n  self.create_timer(&lt;periodo_en_seg&gt;, &lt;funcion_callback&gt;)\n\n\n\n  self.create_subscription(&lt;tipo_mensaje&gt;, '&lt;nombre_topic&gt;',\n                               &lt;funcion_callback&gt;, &lt;tamaño_cola&gt;)\n\n\n\n\n\nLas funciones de callback serán métodos de la clase\nclass &lt;nombre_clase&gt;(Node):\n    ...\n    def timer_callback(self):\n        ...\n        # Publicar el mensaje\n        self.pub.publish(self.msg)\n\n\n\nSolo será utilizada para la inicialización o init, la creación del nodo (instanciando la clase), el spin y la finalización o shutdown\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n\n    # 2. Creación de nodo\n    # nodo = ...\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()\n\n\n\n\n\n\n\n\nPuedes reutilizar el código del lab anterior\n\n\n\n\n\n\n\n\n\nNoteRecordatorio\n\n\n\nSi se crea un paquete nuevo recuerda:\n\nCompletar las dependencias en package.xml e instalar mediante rosdep\nCrear el o los ejecutables en setup.py\nCompilar el paquete con colcon\nconfigurar el entorno: source install/setup.bash\n\n\n\n\n\n\n\n\n\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\n\nPuedes utilizar los comandos de ros2 node list y ros2 node info\n\n\n\nPuedes utilizar los comandos de ros2 topic list, ros2 topic info y ros2 topic echo"
  },
  {
    "objectID": "clases/15/lab.html",
    "href": "clases/15/lab.html",
    "title": "Clase 15 - Laboratorio",
    "section": "",
    "text": "&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"camera\"&gt;\n\n        &lt;!-- Atributos --&gt;\n        &lt;update_rate&gt;{fps}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;/sensor&gt;\n\n    &lt;camera_camera_info_topic&gt;camera_info&lt;/camera_camera_info_topic&gt;\n    &lt;optical_frame_id&gt;{nombre_optical_link}&lt;/optical_frame_id&gt;\n\n    &lt;camera name=\"{nombre_camara}\"&gt;\n        &lt;horizontal_fov&gt;{horizontal_fov}&lt;/horizontal_fov&gt;\n        &lt;lens&gt;\n            &lt;intrinsics&gt;\n                &lt;fx&gt;{f_x}&lt;/fx&gt;\n                &lt;fy&gt;{f_y}&lt;/fy&gt;\n                &lt;cx&gt;{c_x}&lt;/cx&gt;\n                &lt;cy&gt;{c_y}&lt;/cy&gt;\n                &lt;s&gt;0&lt;/s&gt;\n            &lt;/intrinsics&gt;\n        &lt;/lens&gt;\n        &lt;image&gt;\n            &lt;width&gt;{ancho_pixeles}&lt;/width&gt;\n            &lt;height&gt;{alto_pixeles}&lt;/height&gt;\n            &lt;format&gt;R8G8B8&lt;/format&gt;\n        &lt;/image&gt;\n        &lt;clip&gt;\n            &lt;near&gt;{plano_cercano}&lt;/near&gt;\n            &lt;far&gt;{plano_lejano}&lt;/far&gt;\n        &lt;/clip&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;{ruido_mean}&lt;/mean&gt;\n            &lt;stddev&gt;{ruido_std}&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/camera&gt;\n&lt;/gazebo&gt;\n\n\\[\\texttt{f\\_x} = \\frac{W}{2 \\cdot \\tan(\\frac{H_{FoV} \\mathrm{[rad]}}{2})} \\qquad \\texttt{f\\_y} = \\frac{H}{2 \\cdot \\tan(\\frac{V_{FoV} \\mathrm{[rad]}}{2})}\\] \\[\\texttt{c\\_x} = \\frac{W - 1}{2} \\qquad \\texttt{c\\_y} = \\frac{H - 1}{2}\\]\n\n\n\n\n\n\nRecuerda modificar el URDF para añadir los link y las joint correspondiente\n\n   &lt;link name=\"{nombre_link}\"&gt;\n       &lt;xacro:dummy_inertial /&gt;\n   &lt;/link&gt;\n\n   &lt;joint name=\"{nombre_joint}\" type=\"fixed\"&gt;\n       &lt;parent link=\"base_link\" /&gt;\n       &lt;child link=\"{nombre_link}\" /&gt;\n       &lt;origin xyz=\"{x} {y} {z}\" rpy=\"{r} {p} {y}\" /&gt;\n   &lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\nPuedes utilizar la rotación del link para inclinar el sensor hacia abajo y capturar mejor las lineas\n\n\n\n\n\n\n\nRaspberry Pi Camera Module v2:\n\nProfundidad de campo: 10 [cm] a \\(\\infty\\)\nDistancia focal: 3.04 [mm]\nCampo de visión (FoV) horizontal: 62.2°\nCampo de visión (FoV) vertical: 48.8°\nTamaño: 25 x 24 x 9 [mm]\n\n\n&lt;gazebo reference=\"cam_link\"&gt;\n  &lt;sensor name=\"RPiCamV2\" type=\"camera\"&gt;\n    &lt;always_on&gt;1&lt;/always_on&gt;\n    \n    &lt;update_rate&gt;25&lt;/update_rate&gt;\n  \n    &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;topic&gt;camera&lt;/topic&gt;\n    &lt;camera_camera_info_topic&gt;camera_info&lt;/camera_camera_info_topic&gt;\n\n    &lt;optical_frame_id&gt;cam_optical_link&lt;/optical_frame_id&gt;\n\n    &lt;camera name=\"IMX219\"&gt;\n        &lt;horizontal_fov&gt;1.085595&lt;/horizontal_fov&gt;\n        &lt;lens&gt;\n            &lt;intrinsics&gt;\n                &lt;fx&gt;530.47&lt;/fx&gt;\n                &lt;fy&gt;529.08&lt;/fy&gt;\n                &lt;cx&gt;319.5&lt;/cx&gt;\n                &lt;cy&gt;239.5&lt;/cy&gt;\n                &lt;s&gt;0&lt;/s&gt;\n            &lt;/intrinsics&gt;\n        &lt;/lens&gt;\n        &lt;image&gt;\n            &lt;width&gt;640&lt;/width&gt;\n            &lt;height&gt;480&lt;/height&gt;\n            &lt;format&gt;R8G8B8&lt;/format&gt;\n        &lt;/image&gt;\n        &lt;clip&gt;\n            &lt;near&gt;0.01&lt;/near&gt;\n            &lt;far&gt;25&lt;/far&gt;\n        &lt;/clip&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;0&lt;/mean&gt;\n            &lt;stddev&gt;0.007&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/camera&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;\n\n\n\n\n\n\n\n\n\nRecuerda actualizar la configuración del punte entre ROS2 y Gazebo\n\n\n\n\n\ngz_bridge.yaml\n\n# ..\n- topic_name: \"camera\"\n  ros_type_name: \"sensor_msgs/msg/Image\"\n  gz_type_name: \"gz.msgs.Image\"\n  direction: GZ_TO_ROS"
  },
  {
    "objectID": "clases/15/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/15/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 15 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/15/lab.html#sensor-de-tipo-cámara",
    "href": "clases/15/lab.html#sensor-de-tipo-cámara",
    "title": "Clase 15 - Laboratorio",
    "section": "",
    "text": "&lt;gazebo reference=\"{nombre_link}\"&gt;\n    &lt;sensor name=\"{nombre_sensor}\" type=\"camera\"&gt;\n\n        &lt;!-- Atributos --&gt;\n        &lt;update_rate&gt;{fps}&lt;/update_rate&gt;\n        &lt;topic&gt;{nombre_topic}&lt;/topic&gt;\n        &lt;always_on&gt;true&lt;/always_on&gt;\n        &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;/sensor&gt;\n\n    &lt;camera_camera_info_topic&gt;camera_info&lt;/camera_camera_info_topic&gt;\n    &lt;optical_frame_id&gt;{nombre_optical_link}&lt;/optical_frame_id&gt;\n\n    &lt;camera name=\"{nombre_camara}\"&gt;\n        &lt;horizontal_fov&gt;{horizontal_fov}&lt;/horizontal_fov&gt;\n        &lt;lens&gt;\n            &lt;intrinsics&gt;\n                &lt;fx&gt;{f_x}&lt;/fx&gt;\n                &lt;fy&gt;{f_y}&lt;/fy&gt;\n                &lt;cx&gt;{c_x}&lt;/cx&gt;\n                &lt;cy&gt;{c_y}&lt;/cy&gt;\n                &lt;s&gt;0&lt;/s&gt;\n            &lt;/intrinsics&gt;\n        &lt;/lens&gt;\n        &lt;image&gt;\n            &lt;width&gt;{ancho_pixeles}&lt;/width&gt;\n            &lt;height&gt;{alto_pixeles}&lt;/height&gt;\n            &lt;format&gt;R8G8B8&lt;/format&gt;\n        &lt;/image&gt;\n        &lt;clip&gt;\n            &lt;near&gt;{plano_cercano}&lt;/near&gt;\n            &lt;far&gt;{plano_lejano}&lt;/far&gt;\n        &lt;/clip&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;{ruido_mean}&lt;/mean&gt;\n            &lt;stddev&gt;{ruido_std}&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/camera&gt;\n&lt;/gazebo&gt;\n\n\\[\\texttt{f\\_x} = \\frac{W}{2 \\cdot \\tan(\\frac{H_{FoV} \\mathrm{[rad]}}{2})} \\qquad \\texttt{f\\_y} = \\frac{H}{2 \\cdot \\tan(\\frac{V_{FoV} \\mathrm{[rad]}}{2})}\\] \\[\\texttt{c\\_x} = \\frac{W - 1}{2} \\qquad \\texttt{c\\_y} = \\frac{H - 1}{2}\\]\n\n\n\n\n\n\nRecuerda modificar el URDF para añadir los link y las joint correspondiente\n\n   &lt;link name=\"{nombre_link}\"&gt;\n       &lt;xacro:dummy_inertial /&gt;\n   &lt;/link&gt;\n\n   &lt;joint name=\"{nombre_joint}\" type=\"fixed\"&gt;\n       &lt;parent link=\"base_link\" /&gt;\n       &lt;child link=\"{nombre_link}\" /&gt;\n       &lt;origin xyz=\"{x} {y} {z}\" rpy=\"{r} {p} {y}\" /&gt;\n   &lt;/joint&gt;\n\n\n\n\n\n\n\n\n\n\nPuedes utilizar la rotación del link para inclinar el sensor hacia abajo y capturar mejor las lineas\n\n\n\n\n\n\n\nRaspberry Pi Camera Module v2:\n\nProfundidad de campo: 10 [cm] a \\(\\infty\\)\nDistancia focal: 3.04 [mm]\nCampo de visión (FoV) horizontal: 62.2°\nCampo de visión (FoV) vertical: 48.8°\nTamaño: 25 x 24 x 9 [mm]\n\n\n&lt;gazebo reference=\"cam_link\"&gt;\n  &lt;sensor name=\"RPiCamV2\" type=\"camera\"&gt;\n    &lt;always_on&gt;1&lt;/always_on&gt;\n    \n    &lt;update_rate&gt;25&lt;/update_rate&gt;\n  \n    &lt;visualize&gt;true&lt;/visualize&gt;\n    &lt;topic&gt;camera&lt;/topic&gt;\n    &lt;camera_camera_info_topic&gt;camera_info&lt;/camera_camera_info_topic&gt;\n\n    &lt;optical_frame_id&gt;cam_optical_link&lt;/optical_frame_id&gt;\n\n    &lt;camera name=\"IMX219\"&gt;\n        &lt;horizontal_fov&gt;1.085595&lt;/horizontal_fov&gt;\n        &lt;lens&gt;\n            &lt;intrinsics&gt;\n                &lt;fx&gt;530.47&lt;/fx&gt;\n                &lt;fy&gt;529.08&lt;/fy&gt;\n                &lt;cx&gt;319.5&lt;/cx&gt;\n                &lt;cy&gt;239.5&lt;/cy&gt;\n                &lt;s&gt;0&lt;/s&gt;\n            &lt;/intrinsics&gt;\n        &lt;/lens&gt;\n        &lt;image&gt;\n            &lt;width&gt;640&lt;/width&gt;\n            &lt;height&gt;480&lt;/height&gt;\n            &lt;format&gt;R8G8B8&lt;/format&gt;\n        &lt;/image&gt;\n        &lt;clip&gt;\n            &lt;near&gt;0.01&lt;/near&gt;\n            &lt;far&gt;25&lt;/far&gt;\n        &lt;/clip&gt;\n        &lt;noise&gt;\n            &lt;type&gt;gaussian&lt;/type&gt;\n            &lt;mean&gt;0&lt;/mean&gt;\n            &lt;stddev&gt;0.007&lt;/stddev&gt;\n        &lt;/noise&gt;\n    &lt;/camera&gt;\n  &lt;/sensor&gt;\n&lt;/gazebo&gt;"
  },
  {
    "objectID": "clases/15/lab.html#configuración-del-ros_gz_bridge",
    "href": "clases/15/lab.html#configuración-del-ros_gz_bridge",
    "title": "Clase 15 - Laboratorio",
    "section": "",
    "text": "Recuerda actualizar la configuración del punte entre ROS2 y Gazebo\n\n\n\n\n\ngz_bridge.yaml\n\n# ..\n- topic_name: \"camera\"\n  ros_type_name: \"sensor_msgs/msg/Image\"\n  gz_type_name: \"gz.msgs.Image\"\n  direction: GZ_TO_ROS"
  },
  {
    "objectID": "clases/15/lab.html#configuración-del-escenario",
    "href": "clases/15/lab.html#configuración-del-escenario",
    "title": "Clase 15 - Laboratorio",
    "section": "Configuración del escenario",
    "text": "Configuración del escenario\n\nDescomprimir el archivo LineTrack.zip en una carpeta models dentro del paquete donde se encuentre el launch de Gazebo\n\n\n\n\n\n\n\nNote\n\n\n\nRecuerda configurar adecuadamente el archivo setup.py para instalar los archivos correctamente\n\n\n\nModificar el launch de Gazebo\n\nConfigurar la nueva ubicación de los modelos:\n\ngz_resource_path = AppendEnvironmentVariable(\n    'GZ_SIM_RESOURCE_PATH',\n    PathJoinSubstitution([FindPackageShare(\"diffbot_gazebo\"), \"models\"]),\n)\n# ..\nreturn LaunchDescription([\n    gz_resource_path,\n])\n\nAgregar la directiva --render-engine a la ejecución de Gazebo:\n\n# Launch Gazebo\ngz_sim = IncludeLaunchDescription(\n    PythonLaunchDescriptionSource(\n        PathJoinSubstitution(\n            [FindPackageShare('ros_gz_sim'), 'launch', 'gz_sim.launch.py']\n        ),\n    ),\n    launch_arguments={\n        'gz_args': '-r --render-engine ogre empty.sdf',\n    }.items()\n)\n\nEliminar el suelo por defecto:\n\nremove_ground_plane = Node(\n    package=\"ros_gz_sim\",\n    executable=\"remove\",\n    parameters=[\n        { 'entity_name': 'ground_plane'},\n    ],\n    output=\"screen\",\n)\n\nCargar el modelo LineTrack:\n\nload_track = Node(\n    package=\"ros_gz_sim\",\n    executable=\"create\",\n    arguments=[\n        \"-entity\", \"track\",\n        \"-file\", \"model://LineTrack\",\n    ],\n    output=\"screen\",\n)"
  },
  {
    "objectID": "clases/15/lab.html#crear-el-nodo-linedetector",
    "href": "clases/15/lab.html#crear-el-nodo-linedetector",
    "title": "Clase 15 - Laboratorio",
    "section": "Crear el nodo: LineDetector",
    "text": "Crear el nodo: LineDetector\n\nCrear el nodo y suscribir el topic /camera para obtener los mensajes de tipo Image\nImportar las librería y mensajes de tipo Image\n\nfrom sensor_msgs.msg import Image\nimport cv_bridge\nimport cv2"
  },
  {
    "objectID": "clases/15/lab.html#procesamiento-mediante-cv2",
    "href": "clases/15/lab.html#procesamiento-mediante-cv2",
    "title": "Clase 15 - Laboratorio",
    "section": "Procesamiento mediante cv2",
    "text": "Procesamiento mediante cv2\n\nCaptura de la imagen desde ROS2\n\nCrear un CvBridge para convertir las imágenes\n\nclass LineDetector(Node):\n    def __init__(self):\n        # ..        \n        self.bridge = cv_bridge.CvBridge()\n\nConvertir mensajes de tipo Image\n\ndef sub_callback(self, msg: Image):\n    image = self.bridge.imgmsg_to_cv2(msg, desired_encoding='bgr8')\n\n\nPreprocesamiento\n\nUtilizar la función resize para disminuir la resolución\n\nRESIZE_RATIO = 0.25\nimage = cv2.resize(image, None, 1, \n            RESIZE_RATIO, RESIZE_RATIO, cv2.INTER_CUBIC)\n\nConvertir a representación HSV\n\nimage_HSV = cv2.cvtColor(image, cv2.COLOR_BGR2HSV)\n\n\nDetección del camino\n\nAplicar una máscara entre 2 límites con la función mask\n\nLOWER = np.array([ 0,  0,  0])\nUPPER = np.array([180, 255, 30])\nmask = cv2.inRange(image_HSV, LOWER, UPPER)\n\nCalcular el centroide utilizando la función moments\n\nM = cv2.moments(mask)\nif M['m00'] &gt; 0:\n    cx = int(M['m10']/M['m00'])\n    cy = int(M['m01']/M['m00'])"
  },
  {
    "objectID": "clases/15/lab.html#enviar-comandos-de-velocidad",
    "href": "clases/15/lab.html#enviar-comandos-de-velocidad",
    "title": "Clase 15 - Laboratorio",
    "section": "Enviar comandos de velocidad",
    "text": "Enviar comandos de velocidad\n\nCalcular la desviación del centroide y transformarlo en comandos de Twist\n\nSea \\(W\\) el ancho en pixeles de la imágen y \\(c_x\\) la coordenada \\(x\\) del centroide:\n\\[\n\\require{color}\n\\dot\\theta = \\textcolor{Maroon}{\\alpha} * \\dot\\theta_{max}\n\\]\n\\[\n\\textcolor{Maroon}{\\alpha} = 1 - \\frac{2 * c_x}{W}\n\\]"
  },
  {
    "objectID": "clases/16/lab.html",
    "href": "clases/16/lab.html",
    "title": "Clase 16 - Laboratorio",
    "section": "",
    "text": "Obtener los parámetros de calibración de odometría\nEditar los nodos de control y de cálculo de odometría para recibir los parámetros de calibración\nProbar la mejora de la estimación de posición\n\n\n\n\n\nCon la finadad de obtener la posición precisa del robot para comparar con la odometría calculada se utilizará el plugin provisto por Gazebo OdometryPublisher. Para esto será necesario añadirlo en el archivo XACRO como si fuera un sensor más.\n\n&lt;gazebo&gt;\n  &lt;plugin filename=\"gz-sim-odometry-publisher-system\"\n          name=\"gz::sim::systems::OdometryPublisher\"&gt;\n    &lt;odom_frame&gt;odom&lt;/odom_frame&gt;\n    &lt;robot_base_frame&gt;base_link&lt;/robot_base_frame&gt;\n    &lt;dimensions&gt;2&lt;/dimensions&gt;\n  &lt;/plugin&gt;\n&lt;/gazebo&gt;\n\nEl plugin publica el topic de gazebo /model/{nombre_del_robot}/odometry con el tipo gz.msgs.Odometry, por lo que será necesario configurar el ros_gz_bridge de forma que se publiquen los mensajes en ROS2 a través del tipo nav_msgs/msg/Odometry.\n\n\n\n\n\n\n\nSi es necesario listar los topics en Gazebo puede utilizar el comando gz topic -l\n\n\n\n\n\n\n\n\n\nProgramar un nodo para ejecutar una trayectoria cuadrada de 4x4 [m] con rotaciones puras en las esquinas\nPara simplificar el proceso, envíe comandos de velocidad lineal o velocidad angular preprogramados en un cierto intervalo de tiempo, sin utilizar retroalimetación o feedback de la posición. Es decir, programar para un segmento recto de 1[m] una velocidad lineal de 0.2 [m/s] durante 5[s].\nRecuerde enviar un comando con velocidad lineal y angular 0 para detener el robot\nA través de un parámetro, seleccionar si la trayectoria es en sentido horario (CW) o anti-horario (CCW)\n\n\n\n\n\n\nCargar el robot en un mundo vacío (empty.sdf)\n\n\nEjecutar la trayectoria en sentido anti-horario\n\n\nObtener la posición en \\(x\\) e \\(y\\) calculada por el nodo de odometría\n\n\nObtener la posición en \\(x\\) e \\(y\\) real del robot mediante el topic de odometría publicado por Gazebo\n\n\nCalcular y almacenar los valores de error \\(\\epsilon_x\\) y \\(\\epsilon_y\\)\n\n\nRepetir los pasos A-D al menos 4 veces más\n\n\nRepetir los pasos A-E para la trayectoria en sentido horario\n\n\n\n\n\n\n\n\nPara obtener las posiciones existen múltiples opciones:\n\nPuede utilizar el comando de consola ros2 topic echo con la opción --once\nProgramar un nodo extra que obtenga e imprima los valores\nProgramar en el mismo nodo de la trayectoria que se impriman ambos valores al finalizar\n\n\n\n\n\n\n\n\n\\[\n\\def\\ccw#1{{\\underset{\\scriptsize \\textrm{CCW}}{#1}}}\n\\def\\cw#1{{\\underset{\\scriptsize \\textrm{CW}}{#1}}}\n\\def\\ccwcw#1{{\\underset{\\scriptsize \\textrm{CCW|CW}}{#1}}}\n\\]\n\n\nCalcular los centroides de cada grupo \\(\\ccwcw{\\bar{x}}\\) y \\(\\ccwcw{\\bar{y}}\\)\n\n\\[\n\\ccwcw{\\bar{x}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{x_i}} \\qquad \\ccwcw{\\bar{y}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{y_i}}\n\\] con \\(N = 3,5,7 \\cdots\\) la cantidad de repeticiones para cada lado\n\nCalcular \\(\\alpha\\) y obtener el valor de \\(E_b\\):\n\n\\[\n\\alpha = \\frac{\\cw{\\bar{x}} + \\ccw{\\bar{x}}}{-4L} \\quad ó \\quad  \\alpha = \\frac{\\cw{\\bar{y}} - \\ccw{\\bar{y}}}{-4L}\n\\]\n\\[\nE_b = \\frac{\\pi / 2}{\\pi / 2 - \\alpha}\n\\]\n\nCalcular \\(\\beta\\), \\(R\\) y obtener el valor de \\(E_d\\):\n\n\\[\n\\beta = \\frac{\\cw{\\bar{x}} - \\ccw{\\bar{x}}}{-4L} \\quad ó \\quad  \\beta = \\frac{\\cw{\\bar{y}} + \\ccw{\\bar{y}}}{-4L}\n\\]\n\\[\nR = \\frac{L/2}{\\sin(\\beta/2)}\n\\]\n\\[\nE_d = \\frac{R + b/2}{R - b/2}\n\\label{eq:wheel_correction}\n\\]\n\nObtener los coeficientes de corrección \\(c_L\\) y \\(c_R\\):\n\n\\[\nc_L = \\frac{2}{E_d + 1} \\qquad\nc_R = \\frac{2}{\\frac{1}{E_d} + 1}\n\\]\n\n\n\n\nImplemente dentro de aquellos nodos que utilicen el modélo cinemático del robot diferencial los parámetros de corrección vistos en la clase\nLos nodos deben recibir los 3 parámetros (\\(c_L\\) \\(c_R\\) y \\(b\\)) y aplicar las correcciones:\n\n\\[\nb_{\\textrm{actual}} = E_b \\cdot b_{\\textrm{nominal}}\n\\] \\[\n\\Delta s_{L|R,i} = \\left( \\phi_{L|R,i} - \\phi_{L|R,i-1} \\right) \\cdot r_{L|R} \\cdot c_{L|R}\n\\]\n\n\n\n\nIncorpore a el/los archivo/s launch correspondientes los valores de los parámetros calculados anteriormente"
  },
  {
    "objectID": "clases/16/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/16/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 16 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/16/lab.html#cargar-el-plugin-odometrypublisher",
    "href": "clases/16/lab.html#cargar-el-plugin-odometrypublisher",
    "title": "Clase 16 - Laboratorio",
    "section": "",
    "text": "Con la finadad de obtener la posición precisa del robot para comparar con la odometría calculada se utilizará el plugin provisto por Gazebo OdometryPublisher. Para esto será necesario añadirlo en el archivo XACRO como si fuera un sensor más.\n\n&lt;gazebo&gt;\n  &lt;plugin filename=\"gz-sim-odometry-publisher-system\"\n          name=\"gz::sim::systems::OdometryPublisher\"&gt;\n    &lt;odom_frame&gt;odom&lt;/odom_frame&gt;\n    &lt;robot_base_frame&gt;base_link&lt;/robot_base_frame&gt;\n    &lt;dimensions&gt;2&lt;/dimensions&gt;\n  &lt;/plugin&gt;\n&lt;/gazebo&gt;\n\nEl plugin publica el topic de gazebo /model/{nombre_del_robot}/odometry con el tipo gz.msgs.Odometry, por lo que será necesario configurar el ros_gz_bridge de forma que se publiquen los mensajes en ROS2 a través del tipo nav_msgs/msg/Odometry.\n\n\n\n\n\n\n\nSi es necesario listar los topics en Gazebo puede utilizar el comando gz topic -l"
  },
  {
    "objectID": "clases/16/lab.html#ejecutar-el-procedimiento-de-calibración",
    "href": "clases/16/lab.html#ejecutar-el-procedimiento-de-calibración",
    "title": "Clase 16 - Laboratorio",
    "section": "",
    "text": "Programar un nodo para ejecutar una trayectoria cuadrada de 4x4 [m] con rotaciones puras en las esquinas\nPara simplificar el proceso, envíe comandos de velocidad lineal o velocidad angular preprogramados en un cierto intervalo de tiempo, sin utilizar retroalimetación o feedback de la posición. Es decir, programar para un segmento recto de 1[m] una velocidad lineal de 0.2 [m/s] durante 5[s].\nRecuerde enviar un comando con velocidad lineal y angular 0 para detener el robot\nA través de un parámetro, seleccionar si la trayectoria es en sentido horario (CW) o anti-horario (CCW)\n\n\n\n\n\n\nCargar el robot en un mundo vacío (empty.sdf)\n\n\nEjecutar la trayectoria en sentido anti-horario\n\n\nObtener la posición en \\(x\\) e \\(y\\) calculada por el nodo de odometría\n\n\nObtener la posición en \\(x\\) e \\(y\\) real del robot mediante el topic de odometría publicado por Gazebo\n\n\nCalcular y almacenar los valores de error \\(\\epsilon_x\\) y \\(\\epsilon_y\\)\n\n\nRepetir los pasos A-D al menos 4 veces más\n\n\nRepetir los pasos A-E para la trayectoria en sentido horario\n\n\n\n\n\n\n\n\nPara obtener las posiciones existen múltiples opciones:\n\nPuede utilizar el comando de consola ros2 topic echo con la opción --once\nProgramar un nodo extra que obtenga e imprima los valores\nProgramar en el mismo nodo de la trayectoria que se impriman ambos valores al finalizar\n\n\n\n\n\n\n\n\n\\[\n\\def\\ccw#1{{\\underset{\\scriptsize \\textrm{CCW}}{#1}}}\n\\def\\cw#1{{\\underset{\\scriptsize \\textrm{CW}}{#1}}}\n\\def\\ccwcw#1{{\\underset{\\scriptsize \\textrm{CCW|CW}}{#1}}}\n\\]\n\n\nCalcular los centroides de cada grupo \\(\\ccwcw{\\bar{x}}\\) y \\(\\ccwcw{\\bar{y}}\\)\n\n\\[\n\\ccwcw{\\bar{x}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{x_i}} \\qquad \\ccwcw{\\bar{y}} = \\frac{1}{N} \\sum_{i = 1}^N \\ccwcw{\\epsilon_{y_i}}\n\\] con \\(N = 3,5,7 \\cdots\\) la cantidad de repeticiones para cada lado\n\nCalcular \\(\\alpha\\) y obtener el valor de \\(E_b\\):\n\n\\[\n\\alpha = \\frac{\\cw{\\bar{x}} + \\ccw{\\bar{x}}}{-4L} \\quad ó \\quad  \\alpha = \\frac{\\cw{\\bar{y}} - \\ccw{\\bar{y}}}{-4L}\n\\]\n\\[\nE_b = \\frac{\\pi / 2}{\\pi / 2 - \\alpha}\n\\]\n\nCalcular \\(\\beta\\), \\(R\\) y obtener el valor de \\(E_d\\):\n\n\\[\n\\beta = \\frac{\\cw{\\bar{x}} - \\ccw{\\bar{x}}}{-4L} \\quad ó \\quad  \\beta = \\frac{\\cw{\\bar{y}} + \\ccw{\\bar{y}}}{-4L}\n\\]\n\\[\nR = \\frac{L/2}{\\sin(\\beta/2)}\n\\]\n\\[\nE_d = \\frac{R + b/2}{R - b/2}\n\\label{eq:wheel_correction}\n\\]\n\nObtener los coeficientes de corrección \\(c_L\\) y \\(c_R\\):\n\n\\[\nc_L = \\frac{2}{E_d + 1} \\qquad\nc_R = \\frac{2}{\\frac{1}{E_d} + 1}\n\\]\n\n\n\n\nImplemente dentro de aquellos nodos que utilicen el modélo cinemático del robot diferencial los parámetros de corrección vistos en la clase\nLos nodos deben recibir los 3 parámetros (\\(c_L\\) \\(c_R\\) y \\(b\\)) y aplicar las correcciones:\n\n\\[\nb_{\\textrm{actual}} = E_b \\cdot b_{\\textrm{nominal}}\n\\] \\[\n\\Delta s_{L|R,i} = \\left( \\phi_{L|R,i} - \\phi_{L|R,i-1} \\right) \\cdot r_{L|R} \\cdot c_{L|R}\n\\]\n\n\n\n\nIncorpore a el/los archivo/s launch correspondientes los valores de los parámetros calculados anteriormente"
  },
  {
    "objectID": "clases/03/lab.html",
    "href": "clases/03/lab.html",
    "title": "Clase 03 - Laboratorio",
    "section": "",
    "text": "NoteNota\n\n\n\nRecuerda configurar el entorno:\n    $ source /opt/ros/jazzy/setup.bash\n\n\n\n\n\n\n\n\n\n\n\n\nTipPara ejecutar\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\n\n\n    $ ros2 service list\nPara también ver el tipo:\n    $ ros2 service list -t\n\n\n\n\n  $ ros2 service type &lt;nombre_servicio&gt;\n\n\n    $ ros2 service type /add_two_ints\n\n  $ ros2 interface show &lt;nombre_tipo_servicio&gt;\n\n\n    $ ros2 interface show example_interfaces/srv/AddTwoInts\n\n\n\n\n  $ ros2 node info &lt;nombre_nodo&gt;\n\n\n\n\n\n  $ ros2 service call &lt;nombre_servicio&gt; &lt;nombre_tipo_servicio&gt; &lt;argumentos&gt;\n\n\n    $ ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts \"{a: 7, b: 12}\"\n\n\n\n\n\n\n\n\n\n\n\n    $ ros2 param list\n\n\n\n\n  $ ros2 param describe &lt;nombre_nodo&gt; &lt;nombre_parametro&gt;\n\n    $ ros2 param describe /set_parameters_callback param1\n\n\n\n\n  $ ros2 param get &lt;nombre_nodo&gt; &lt;nombre_parametro&gt;\n\n    $ ros2 param get /set_parameters_callback param1\n\n\n\n\n  $ ros2 param set &lt;nombre_nodo&gt; &lt;nombre_parametro&gt; &lt;valor&gt;\n\n    $ ros2 param set /set_parameters_callback param1 1.0\n\n\n\n\n  $ ros2 param dump &lt;nombre_nodo&gt;\n\n    $ ros2 param dump /set_parameters_callback\n\n\n\n\n  $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt; --ros-args \n      --params-file &lt;archivo&gt;"
  },
  {
    "objectID": "clases/03/lab.html#universidad-nacional-del-litoral-unl",
    "href": "clases/03/lab.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 03 - Laboratorio",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/03/lab.html#parte-1-servicios-y-parámetros",
    "href": "clases/03/lab.html#parte-1-servicios-y-parámetros",
    "title": "Clase 03 - Laboratorio",
    "section": "",
    "text": "NoteNota\n\n\n\nRecuerda configurar el entorno:\n    $ source /opt/ros/jazzy/setup.bash\n\n\n\n\n\n\n\n\n\n\n\n\nTipPara ejecutar\n\n\n\n    $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt;\n\n\n\n\n\n\n\n    $ ros2 service list\nPara también ver el tipo:\n    $ ros2 service list -t\n\n\n\n\n  $ ros2 service type &lt;nombre_servicio&gt;\n\n\n    $ ros2 service type /add_two_ints\n\n  $ ros2 interface show &lt;nombre_tipo_servicio&gt;\n\n\n    $ ros2 interface show example_interfaces/srv/AddTwoInts\n\n\n\n\n  $ ros2 node info &lt;nombre_nodo&gt;\n\n\n\n\n\n  $ ros2 service call &lt;nombre_servicio&gt; &lt;nombre_tipo_servicio&gt; &lt;argumentos&gt;\n\n\n    $ ros2 service call /add_two_ints example_interfaces/srv/AddTwoInts \"{a: 7, b: 12}\"\n\n\n\n\n\n\n\n\n\n\n\n    $ ros2 param list\n\n\n\n\n  $ ros2 param describe &lt;nombre_nodo&gt; &lt;nombre_parametro&gt;\n\n    $ ros2 param describe /set_parameters_callback param1\n\n\n\n\n  $ ros2 param get &lt;nombre_nodo&gt; &lt;nombre_parametro&gt;\n\n    $ ros2 param get /set_parameters_callback param1\n\n\n\n\n  $ ros2 param set &lt;nombre_nodo&gt; &lt;nombre_parametro&gt; &lt;valor&gt;\n\n    $ ros2 param set /set_parameters_callback param1 1.0\n\n\n\n\n  $ ros2 param dump &lt;nombre_nodo&gt;\n\n    $ ros2 param dump /set_parameters_callback\n\n\n\n\n  $ ros2 run &lt;nombre_paquete&gt; &lt;nombre_ejecutable&gt; --ros-args \n      --params-file &lt;archivo&gt;"
  },
  {
    "objectID": "clases/12/index.html#percepción-1",
    "href": "clases/12/index.html#percepción-1",
    "title": "Robótica",
    "section": "Percepción",
    "text": "Percepción\n\n\nUna de las tareas más importantes en sistemas autónomos es la de adquirir información acerca del entorno a través de Sensores\n\n\n\n\n\n\n\n\n\n\n\nFuente: Clearpath (clearpathrobotics.com)"
  },
  {
    "objectID": "clases/12/index.html#sensores-algunas-clasificaciones",
    "href": "clases/12/index.html#sensores-algunas-clasificaciones",
    "title": "Robótica",
    "section": "Sensores: algunas clasificaciones",
    "text": "Sensores: algunas clasificaciones\n\nPropioceptivos: Miden variables internas del robot\n\n\nVelocidad de una rueda/motor\nÁngulo de articulación de un brazo\nVoltaje de la batería\n\n\nExtraceptivos: Adquieren información del entorno del robot \n\n\nMedida de distancia\nIntensidad de la luz\nAmplitud de sonido"
  },
  {
    "objectID": "clases/12/index.html#sensores-algunas-clasificaciones-1",
    "href": "clases/12/index.html#sensores-algunas-clasificaciones-1",
    "title": "Robótica",
    "section": "Sensores: algunas clasificaciones",
    "text": "Sensores: algunas clasificaciones\n\nPasivos: Miden la energía que ingresa del medio que los rodea\n\n\nSondas de temperatura\nMicrófonos\nCámaras\n\n\nActivos: Emiten energía y luego miden la reacción del medio ambiente\n\n\nEncoders ópticos o magnéticos\nSonares o ultrasónicos\nCámaras de luz estructurada"
  },
  {
    "objectID": "clases/12/index.html#caracterización-1",
    "href": "clases/12/index.html#caracterización-1",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nSensibilidad: Cambio en la salida según la variación de la magnitud física de entrada"
  },
  {
    "objectID": "clases/12/index.html#caracterización-2",
    "href": "clases/12/index.html#caracterización-2",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nRango: Valor máximo y mínimo"
  },
  {
    "objectID": "clases/12/index.html#caracterización-3",
    "href": "clases/12/index.html#caracterización-3",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nExactitud: Diferencia entre la salida del sensor y el valor real\n\nError de sensibilidad: desviación a la pendiente de la curva ideal\nError de corrimiento: desviación de la medida 0"
  },
  {
    "objectID": "clases/12/index.html#caracterización-4",
    "href": "clases/12/index.html#caracterización-4",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nResolución: Mínima diferencia que puede detectarse entre dos valores"
  },
  {
    "objectID": "clases/12/index.html#caracterización-5",
    "href": "clases/12/index.html#caracterización-5",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nPresición: Grado de reproducibilidad de la medida"
  },
  {
    "objectID": "clases/12/index.html#caracterización-6",
    "href": "clases/12/index.html#caracterización-6",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nLinealidad: Comportamiento lineal del sensor"
  },
  {
    "objectID": "clases/12/index.html#caracterización-7",
    "href": "clases/12/index.html#caracterización-7",
    "title": "Robótica",
    "section": "Caracterización",
    "text": "Caracterización\n\n\n\nTiempo de respuesta: Tiempo que tarda la salida de un sensor en cambiar a un valor final\nAncho de banda: Rango de frecuencia que puede detectar adecuadamente"
  },
  {
    "objectID": "clases/12/index.html#encoders",
    "href": "clases/12/index.html#encoders",
    "title": "Robótica",
    "section": "Encoders",
    "text": "Encoders\n\n\n\nDispositivos que pueden detectar o medir desplazamiento angular (o lineal)\n\n\nPropioceptivos\nClasificación primaria: Incrementales y Absolutos\nPrincipios de funcionamiento:\n\nMecánico (Pasivo)\nÓptico (Activo)\nMagnético (Activo)\n\n\n\n\n\n\n\n\n\n\n\nFuente: AsahiKASEI (www.akm.com)"
  },
  {
    "objectID": "clases/12/index.html#encoders-de-cuadratura",
    "href": "clases/12/index.html#encoders-de-cuadratura",
    "title": "Robótica",
    "section": "Encoders de cuadratura",
    "text": "Encoders de cuadratura\n\nEncoder magnético montado en motor DC con escobilla\n\n\n\n\n\n\nFuente: Pololu (www.pololu.com)"
  },
  {
    "objectID": "clases/12/index.html#características-de-los-encoders",
    "href": "clases/12/index.html#características-de-los-encoders",
    "title": "Robótica",
    "section": "Características de los encoders",
    "text": "Características de los encoders\n\nRango: Ángulo o cantidad de vueltas (absolutos)\nResolución: Angular (absolutos) - CPR (incrementales)\nLinealidad: (no aplica)\nAncho de banda: Tiempo de conmutación, max RPM (generalemente sobredimensionada)\nError: angular para los absolutos. En el caso de los incrementales depende del sistema de decodificación\nOtros parámetros: Tipo de salida (NPN, PushPull, protocolo, etc). Velocidad máxima. Voltaje/Corriente de trabajo."
  },
  {
    "objectID": "clases/12/index.html#acelerómetro",
    "href": "clases/12/index.html#acelerómetro",
    "title": "Robótica",
    "section": "Acelerómetro",
    "text": "Acelerómetro\n\nDispositivos electromecánicos que miden la aceleración a la que se encuentran afectados (propioceptivos y pasivos)\n\n\n\nADXL362: Accelerómetro de 3 ejes (3DoF)\n\n\n\nFuente: Sparkfun (www.sparkfun.com)\n\n\n\nMedición de la aceleración asociada a una masa en movimiento\n\n\n\nFuente: Analog Devices (www.analog.com)"
  },
  {
    "objectID": "clases/12/index.html#características-de-los-acelerómetros",
    "href": "clases/12/index.html#características-de-los-acelerómetros",
    "title": "Robótica",
    "section": "Características de los acelerómetros",
    "text": "Características de los acelerómetros\n\nRango: Aceleración máxima (en múltiplos de gravedad, ej: \\(\\pm2 g\\), \\(\\pm4 g\\))\nResolución: en mV/g (analógicos) o en LSB/g (digitales) \nAncho de banda: Rango de vibraciones al que puede responder\nError: Densidad de ruido y salida para 0-g\nOtros parámetros: Tipo de salida (analógico o digital y el protocolo)\nProblemas asociados: Ruido de alta frecuencia. Vector gravedad."
  },
  {
    "objectID": "clases/12/index.html#giróscopos",
    "href": "clases/12/index.html#giróscopos",
    "title": "Robótica",
    "section": "Giróscopos",
    "text": "Giróscopos\n\nDispositivos electromecánicos que miden la velocidad angular a la que se encuentran afectados (propioceptivos y pasivos)\n\n\n\nLPY503AL: Giróscopo de 2 ejes (2DoF)\n\n\n\nFuente: Sparkfun (www.sparkfun.com)\n\n\n\nMedición de la velocidad angular\n\n\n\nFuente: Analog Devices (www.analog.com)"
  },
  {
    "objectID": "clases/12/index.html#características-de-los-acelerómetros-1",
    "href": "clases/12/index.html#características-de-los-acelerómetros-1",
    "title": "Robótica",
    "section": "Características de los acelerómetros",
    "text": "Características de los acelerómetros\n\nRango: Velocidad máxima (en °/s o rad/s)\nResolución: Resolución: en mV/°/s (analógicos) o en LSB/°/s (digitales) \nAncho de banda: Rango de variación al que puede responder\nError: Densidad de ruido\nOtros parámetros: Tipo de salida (analógico o digital y el protocolo)\nProblemas asociados: Bias (valor a velocidad angular 0)"
  },
  {
    "objectID": "clases/12/index.html#imu-inertial-measurement-unit",
    "href": "clases/12/index.html#imu-inertial-measurement-unit",
    "title": "Robótica",
    "section": "IMU (Inertial Measurement Unit)",
    "text": "IMU (Inertial Measurement Unit)\n\n3 giróscopos ortogonales y 3 acelerómetros ortogonales\nPermite estimar:\n\nDirectamente: aceleración (A), velocidad angular (G)\nPrimera integral: velocidad lineal (A), orientación (G)\nSegunda integral: posición (A)\n\nErrores cuadráticos y de acumulación\nMediciones absolutas (GPS o cámara) permiten cancelar esta deriva de error"
  },
  {
    "objectID": "clases/12/index.html#sensores-de-rango-activo",
    "href": "clases/12/index.html#sensores-de-rango-activo",
    "title": "Robótica",
    "section": "Sensores de rango activo",
    "text": "Sensores de rango activo\n\nSensores capaces de medir directamente la distancia a un objeto en la vecindad del robot (extraceptivos)\n\n\nActivos: emiten algún tipo de energía en forma de señal y miden la señal de respuesta del entorno\nCostos proporcionales a la precisión, resolución, al rango y aplicación\nMúltiples principios de funcionamientos (con sus respectivas características)\n2 principios más usados: ToF y Triangulación"
  },
  {
    "objectID": "clases/12/index.html#time-of-flight-tof",
    "href": "clases/12/index.html#time-of-flight-tof",
    "title": "Robótica",
    "section": "Time of Flight (ToF)",
    "text": "Time of Flight (ToF)\n\nPrincipio de funcionamiento basado en la velocidad del sonido o una onda electromagnética (luz) \\[\nd = c \\cdot t\n\\]\n\ndonde \\(c\\) es la velocidad de la onda, \\(t\\) es el tiempo de vuelo (ToF) y \\(d\\) la distancia (generalmente de ida y vuelta)\n\nEjemplo con una distancia de 3 metros:\n\nVelocidad de la luz: \\(c \\approx 0.3 [\\mathrm{m/ns}]\\) \\(\\to\\) \\(t = 10 [\\mathrm{ns}] = 0.00000001 [\\mathrm{s}]\\)\nvelocidad del sonido: \\(c \\approx 0.3 [\\mathrm{m/ms}]\\) \\(\\to\\) \\(t = 10 [\\mathrm{ms}] = 0.01 [\\mathrm{s}]\\)"
  },
  {
    "objectID": "clases/12/index.html#time-of-flight-tof-1",
    "href": "clases/12/index.html#time-of-flight-tof-1",
    "title": "Robótica",
    "section": "Time of Flight (ToF)",
    "text": "Time of Flight (ToF)\nLa calidad de estos sensores depende principalmente de:\n\nErrores de medición del \\(t\\) y el tiempo exacto de arribo de la señal reflejada\nDispersión del haz\nInteracción con el medio (absorción, reflejos, “contaminación”)\nVariaciones o valor exacto de la velocidad de propagación\nLa velocidad relativa en objetivos dinámicos"
  },
  {
    "objectID": "clases/12/index.html#sensor-de-ultrasonido-tof",
    "href": "clases/12/index.html#sensor-de-ultrasonido-tof",
    "title": "Robótica",
    "section": "Sensor de ultrasonido ToF",
    "text": "Sensor de ultrasonido ToF\n\n\n\nTransmite un ”paquete” de ondas de presión ultrasónicas y mide el tiempo que tardan en reflejarse y volver.\n\n\nGeneralmente en robótica móvil se utilizan en rangos de 5 a 200 [cm]\nCuanto más cerrado es el ángulo de apertura del haz mejor resolución direccional\nPrincipal limitación: se obtiene la profundidad de una región constante (1D)\n\n\n\n\n\nURM09: Sensor de distancia ultrasónico\n\n\n\n\n\nFuente: DFRobot (www.dfrobot.com)"
  },
  {
    "objectID": "clases/12/index.html#sensor-láser-tof",
    "href": "clases/12/index.html#sensor-láser-tof",
    "title": "Robótica",
    "section": "Sensor láser ToF",
    "text": "Sensor láser ToF\n\nEmisor que ilumina el objetivo con un láser y un receptor capaz de detectar la componente de luz reflejada alineada al haz emitido\n\n\nMejora respecto del sensor de ultrasonido al utilizar un haz de luz (pero genera problema con objetos translúcidos)\nFormas de medir el ToF:\n\nEmisión de un pulso y medir el tiempo que transcurre directamente (picosegundos)\nEmitir una onda modulada y medir el cambio de fase (desfase)"
  },
  {
    "objectID": "clases/12/index.html#sensor-láser-tof-1",
    "href": "clases/12/index.html#sensor-láser-tof-1",
    "title": "Robótica",
    "section": "Sensor láser ToF",
    "text": "Sensor láser ToF\n\n\nTFmini sensor de distancia 1D\n\n\n\nFuente: Adafruit (www.adafruit.com)\n\n\n\nVL53L7CX sensor de distancia 2D (8x8)\n\n\n\nFuente: Pololu (www.pololu.com)"
  },
  {
    "objectID": "clases/12/index.html#triangulación",
    "href": "clases/12/index.html#triangulación",
    "title": "Robótica",
    "section": "Triangulación",
    "text": "Triangulación\n\nPrincipio de funcionamiento basado en geometría y el ángulo de reflexión\n\n\nFuente: Siegwart, R. (2011). Introduction to Autonomous Mobile Robots (2nd ed.)"
  },
  {
    "objectID": "clases/12/index.html#triangulación-óptica-1d",
    "href": "clases/12/index.html#triangulación-óptica-1d",
    "title": "Robótica",
    "section": "Triangulación óptica 1D",
    "text": "Triangulación óptica 1D\n\nBuena exactitud con alta precisión a un bajo costo\nGran ancho de banda y no sufre interferencia como el ultrasonido\nRango limitado por la geometría del sensor\n\nGP2Y0A02YK0F (20-150cm) y GP2Y0A60SZLF (10-150cm)\n\nFuente: Pololu (www.pololu.com)"
  },
  {
    "objectID": "clases/12/index.html#light-detection-and-ranging---lidar",
    "href": "clases/12/index.html#light-detection-and-ranging---lidar",
    "title": "Robótica",
    "section": "Light Detection and Ranging - LiDAR",
    "text": "Light Detection and Ranging - LiDAR\n\n\n\nMedir la distancia al objeto más próximo en un radio de 360° sobre un plano con gran precisión angular y lineal\n\n\nUtilizan triangulación (mayoría) o ToF\nExtensión a 3D mediante mecanismos mecánicos y/u ópticos\n\n\nSlamtec RPLiDAR A3M1 (2D)\n\n\n\nFuente: Seeedstudio (www.seeedstudio.com)"
  },
  {
    "objectID": "clases/12/index.html#características-de-los-lidar",
    "href": "clases/12/index.html#características-de-los-lidar",
    "title": "Robótica",
    "section": "Características de los LiDAR",
    "text": "Características de los LiDAR\n\nRango: Distancia mínima y máxima (entre \\(\\times 10^{-2}\\) y \\(\\times 10^{2}\\) metros)\nVelocidad de rotación: 5, 10, 15 [Hz] (r.p.s)\nResolución: angular y lineal   \nOtros parámetros: Protocolo de comunicación (UART, Ethernet, etc)\nProblemas asociados: Apto o no para ambientes exteriores. Corriente de consumo."
  },
  {
    "objectID": "clases/12/index.html#sistema-global-de-navegación-por-satélite-gnss",
    "href": "clases/12/index.html#sistema-global-de-navegación-por-satélite-gnss",
    "title": "Robótica",
    "section": "Sistema global de navegación por satélite (GNSS)",
    "text": "Sistema global de navegación por satélite (GNSS)\n\n\n\nInformación relativa a la ubicación, velocidad y sincronización horaria\nPosición absoluta con precisión de 1.5 a 2 metros\nBaja frecuencia de actualización\nSistemas RTK con mejor precisión y frecuencia (a mayor costo)\nProblemas de recepción de señal\n\n\n\n\n\nFuente: S. Miao, Mathematical Approaches to Global Positioning Systems, TomRocksMaths, 2023, fig. 6, p. 6."
  },
  {
    "objectID": "clases/04/index.html#resumen-clase-03",
    "href": "clases/04/index.html#resumen-clase-03",
    "title": "Robótica",
    "section": "Resumen Clase 03",
    "text": "Resumen Clase 03\n\nWorkspace y paquetes de ROS\n\n\n\nArchivos mínimos\n\n\n📂 src\n  📁 nombre_paquete\n      📁 nombre_paquete\n          📄 __init__.py\n          📄 nodo_A.py      ⬅️ Código\n          ...                 \n      📁 resource\n          📄 nombre_paquete\n      📄 package.xml\n      📄 setup.cfg\n      📄 setup.py\n\n\n\n\nEntorno de ROS (dos “niveles”)\nWorkspace\nPaquete\nArchivos mínimos para paquetes Python"
  },
  {
    "objectID": "clases/04/index.html#resumen-clase-03-1",
    "href": "clases/04/index.html#resumen-clase-03-1",
    "title": "Robótica",
    "section": "Resumen Clase 03",
    "text": "Resumen Clase 03\n\nrclpy: Partes básicas del programa\n\n\nInicialización\n rclpy.init(..)\nCreación de 1 o más nodos\n rclpy.create_node(..)\nProcesamiento de callbacks (spinning)\n rclpy.spin(..)\nApagado / finalización (shutdown)\n rclpy.shutdown()"
  },
  {
    "objectID": "clases/04/index.html#resumen-clase-03-2",
    "href": "clases/04/index.html#resumen-clase-03-2",
    "title": "Robótica",
    "section": "Resumen Clase 03",
    "text": "Resumen Clase 03\n\nGestión de nodos\n\n\nCrear un publisher: node.create_publisher(..)\nCrear un suscriber: node.create_subscription(..)\nTimer: node.create_timer(..)\nLog: node.get_logger(..)"
  },
  {
    "objectID": "clases/04/index.html#función-de-callback",
    "href": "clases/04/index.html#función-de-callback",
    "title": "Robótica",
    "section": "Función de callback",
    "text": "Función de callback\nFunción que se le da a un sistema para que ejecute al ocurrir un evento\n\n\nPermite al programa:\n\nNo detenerse esperando al evento\nEjecute la acción solo cuando es necesario\nPueda ejecutar otras tareas"
  },
  {
    "objectID": "clases/04/index.html#section",
    "href": "clases/04/index.html#section",
    "title": "Robótica",
    "section": "",
    "text": "Analogía “compra online”\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant Cliente\n    participant Tienda Online\n    participant Repartidor\n\n    Cliente-&gt;&gt;Tienda Online: Hace un pedido 📦\n    %% Cliente--&gt;&gt;Cliente: Sigue con su día\n    Note left of Cliente: Sigue con su día\n    Tienda Online-&gt;&gt;Repartidor: Despacha el paquete\n    Repartidor--&gt;&gt;Cliente: Notificación de entrega"
  },
  {
    "objectID": "clases/04/index.html#section-1",
    "href": "clases/04/index.html#section-1",
    "title": "Robótica",
    "section": "",
    "text": "Analogía “compra online”\n\n\n\n\n\n\n\n\n\nsequenceDiagram\n    participant Cliente\n    participant Tienda Online\n    participant Repartidor\n\n    Cliente-&gt;&gt;Tienda Online: Hace un pedido 📦\n    %% Cliente--&gt;&gt;Cliente: Sigue con su día\n    Note left of Cliente: Sigue con su día\n    Tienda Online-&gt;&gt;Repartidor: Despacha el paquete\n    Repartidor--&gt;&gt;Cliente: Notificación de entrega\n\n\n\n\n\n\n\n\n\n\n\n\n\nCliente\n\n\n➡️\n\n\nNodo que espera datos\n\n\n\n\nPedido en la tienda\n\n\n➡️\n\n\nSuscripción a un topic\n\n\n\n\nEl nodo sigue ejecutando tareas\n\n\n\n\nTienda despacha el paquete\n\n\n➡️\n\n\nPublicador envía un mensaje\n\n\n\n\nNotificación y entrega\n\n\n➡️\n\n\nSe activa la función callback"
  },
  {
    "objectID": "clases/04/index.html#código-de-publisher",
    "href": "clases/04/index.html#código-de-publisher",
    "title": "Robótica",
    "section": "Código de publisher",
    "text": "Código de publisher\nimport rclpy\nfrom std_msgs.msg import String\n\ndef main(args=None):\n    # 1. Inicialización\n    rclpy.init(args=args)\n\n    # 2. Creación de nodo\n    nodo = rclpy.create_node('publicador')\n\n    # 2.1 Creación de publisher\n    pub = nodo.create_publisher(String, 'chat', 10)\n\n    # 2.2 Programación de función de callback\n    def timer_callback():\n        # Creación de mensaje\n        msg = String()\n        # Completar el campo 'data' del mensaje \n        msg.data = 'Mensaje de prueba'\n\n        # Publicar el mensaje\n        pub.publish(msg)\n\n    # 2.3 Creación del timer\n    timer = nodo.create_timer(1, timer_callback)\n\n    # 3. Procesamiento de mensajes y callback\n    rclpy.spin(nodo)\n\n    # 4. Finalización \n    rclpy.shutdown()\n\n\nif __name__ == '__main__':\n    main()"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-1",
    "href": "clases/04/index.html#uso-de-nombres-1",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\nNombres para:\n\nPaquete\nArchivo\nEjecutable\nNodo\n\n\nUso de nombres - de paquete: estructura de archivos, , , , linea de comando - de archivo: estructura de archivos y - de ejecutable: y linea de comando - de nodo: código y linea de comando"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-2",
    "href": "clases/04/index.html#uso-de-nombres-2",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nPaquete\n\n📂 src\n  📁 nombre_paquete\n      📁 nombre_paquete\n          📄 __init__.py\n          📄 codigo.py\n          ...                   \n    📁 resource\n        📄 nombre_paquete\n    📄 package.xml\n    📄 setup.cfg\n    📄 setup.py"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-3",
    "href": "clases/04/index.html#uso-de-nombres-3",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nArchivo\n\n📂 src\n  📁 nombre_paquete\n      📁 nombre_paquete\n          📄 __init__.py\n          📄 codigo.py\n          ...                   \n    📁 resource\n        📄 nombre_paquete\n    📄 package.xml\n    📄 setup.cfg\n    📄 setup.py"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-4",
    "href": "clases/04/index.html#uso-de-nombres-4",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nPaquete\n\n\n\npackage.xml\n\n&lt;package format=\"3\"&gt;\n    &lt;name&gt;{nombre_paquete}&lt;/name&gt;\n    &lt;version&gt;{version}&lt;/version&gt;\n    &lt;description&gt;\n        {descripcion}\n        ...\n    &lt;/description&gt;\n    ...\n&lt;/package&gt;"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-5",
    "href": "clases/04/index.html#uso-de-nombres-5",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nPaquete\n\n\n\nsetup.cfg\n\n[develop]\nscript_dir=$base/lib/{nombre_paquete}\n[install]\ninstall_scripts=$base/lib/{nombre_paquete}"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-6",
    "href": "clases/04/index.html#uso-de-nombres-6",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nPaquete\n\n\n\nsetup.py\n\nfrom setuptools import setup\n\nsetup(\n    name={nombre_paquete},\n    version={version},\n    description={descripción},\n    ...\n    packages=[{nombre_paquete}],\n    data_files=[\n        ('share/ament_index/resource_index/packages', ['resource/{nombre_paquete}’]),\n        ('share/{nombre_paquete}’, ['package.xml']),\n    ],\n    ...\n    entry_points={\n        'console_scripts': [\n            '{nombre_ejecutable} = {nombre_paquete}.{nombre_archivo}:main'\n        ],\n    },\n)"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-7",
    "href": "clases/04/index.html#uso-de-nombres-7",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nEjecutable, paquete, archivo\n\n\n\nsetup.py\n\nfrom setuptools import setup\n\nsetup(\n    name={nombre_paquete},\n    version={version},\n    description={descripción},\n    ...\n    packages=[{nombre_paquete}],\n    data_files=[\n        ('share/ament_index/resource_index/packages', ['resource/{nombre_paquete}’]),\n        ('share/{nombre_paquete}’, ['package.xml']),\n    ],\n    ...\n    entry_points={\n        'console_scripts': [\n            '{nombre_ejecutable} = {nombre_paquete}.{nombre_archivo}:main'\n        ],\n    },\n)"
  },
  {
    "objectID": "clases/04/index.html#uso-de-nombres-8",
    "href": "clases/04/index.html#uso-de-nombres-8",
    "title": "Robótica",
    "section": "Uso de nombres",
    "text": "Uso de nombres\n\nNodo\n\n\n\ncodigo.py\n\ndef main(args=None):\n  # 1. Inicialización\n  rclpy.init(args=args)\n\n  # 2. Creación de nodo\n  node = rclpy.create_node({nombre_nodo})\n\n  # 3. Procesamiento de callback\n  rclpy.spin(node)\n\n  # 4. Finalización\n  rclpy.shutdown()\n\nif __name__ == '__main__':\n  main()"
  },
  {
    "objectID": "clases/04/index.html#dependencias",
    "href": "clases/04/index.html#dependencias",
    "title": "Robótica",
    "section": "Dependencias",
    "text": "Dependencias\n\nCódigo fuente de un nodo\n\nimport rclpy\nfrom std_msgs.msg import String\n\n\nSe refleja en las dependencias en package.xml\n\n...\n    &lt;exec_depend&gt;rclpy&lt;/exec_depend&gt;\n    &lt;exec_depend&gt;std_msgs&lt;/exec_depend&gt;\n..."
  },
  {
    "objectID": "clases/04/index.html#dependencias-1",
    "href": "clases/04/index.html#dependencias-1",
    "title": "Robótica",
    "section": "Dependencias",
    "text": "Dependencias\n\nTipos de dependencias:\n\n\n&lt;build_depend&gt;: compilación\n&lt;exec_depend&gt;: ejecución\n&lt;depend&gt;: compilación y ejecución\n&lt;test_depend&gt;: solo para pruebas\n\n\nAdministración via rosdep\n\n    rosdep install -i --from-path src --rosdistro jazzy -y"
  },
  {
    "objectID": "clases/04/index.html#ejecutables-y-compilación",
    "href": "clases/04/index.html#ejecutables-y-compilación",
    "title": "Robótica",
    "section": "Ejecutables y compilación",
    "text": "Ejecutables y compilación\n\nAñadir un ejecutable en setup.py\n\n...\nentry_points={\n    'console_scripts': [\n        '{nombre_ejecutable} = {nombre_paquete}.{nombre_archivo}:main',\n    ],\n},\n...\n\n\nCompilar\n\n    colcon build [--symlink-install] [--packages-select &lt;nombre_paquete&gt;]"
  },
  {
    "objectID": "clases/04/index.html#laboratorio-parte-2",
    "href": "clases/04/index.html#laboratorio-parte-2",
    "title": "Robótica",
    "section": "Laboratorio (parte 2)",
    "text": "Laboratorio (parte 2)\n\nCreación de paquetes\nProgramación y compilación de nodos"
  },
  {
    "objectID": "clases/02/index.html#robot-operating-system-2",
    "href": "clases/02/index.html#robot-operating-system-2",
    "title": "Robótica",
    "section": "Robot Operating System (2)",
    "text": "Robot Operating System (2)\n\n\n\nEs un conjunto de librerías de software y herramientas que ayudan a la creación de aplicaciones robóticas (SDK).\n\n\n\nMotivación principal: No reinventar la rueda\n\n\n\n\n\n\n\n\nwww.ros.org\n\n\nROS2. Definición y propósito. Ventajas y problemas que resuelve. (https://www.ros.org/blog/ecosystem/)\n\n\n\nDocumentación: docs.ros.org/en/jazzy"
  },
  {
    "objectID": "clases/02/index.html#robot-operating-system-2-1",
    "href": "clases/02/index.html#robot-operating-system-2-1",
    "title": "Robótica",
    "section": "Robot Operating System (2)",
    "text": "Robot Operating System (2)\n\n\nOtras características:\n\nPlataforma estándar y comunidad global\nUtilizado en educación, investigación e industria\nMulti-dominio (en varios sentidos) y multi-plataforma\nGratuito y open-source\n\n\n\n\n\n\n\n\nwww.ros.org\n\n\n\n\nPlataforma estándar: Quiere decir que el software desarrollado por alguien en algún punto del mundo puede re-utilizarlo alguien en otro (siempre y cuando se respeten ciertas condiciones)\n\nPermitió la formación de una comunidad global (que prueba los paquetes) y a su vez que sea utilizado en educación, investigación e industria\n\nProgramas individuales (Nodos) que se comunican a través (Topics) de estructuras definidas (Mensajes)\nDistribuido: los programas pueden ejecutarse en distintas computadoras y comunicarse a través de la red\nMulti-lenguaje: C++ y Python (existen librerías para Java o MATLAB)\nFree y open-source (la mayoría de los paquetes de ROS)\nFacilita el desarrollo proveyendo de herramientas para la ejecución, inspección, debugging, visualización, graficación, revisiones (playback)\n\n\n\nDocumentación: docs.ros.org/en/jazzy"
  },
  {
    "objectID": "clases/02/index.html#ros2-componentes-principales",
    "href": "clases/02/index.html#ros2-componentes-principales",
    "title": "Robótica",
    "section": "ROS2: Componentes principales",
    "text": "ROS2: Componentes principales\n\n\nNodos\n\nEjecutable con [una única] tarea\n\n\n\nSe compila, ejecuta y gestiona de forma individual\n\n\n\n\nSe organiza en paquetes\n\n\n\n\n\n\n\n\n\n\n\nProgramas ejecutables de propósito único (no es 100% estricto)\nSe compilan, ejecutan y gestionan de forma individual\nOrganizados en paquetes"
  },
  {
    "objectID": "clases/02/index.html#ros2-componentes-principales-1",
    "href": "clases/02/index.html#ros2-componentes-principales-1",
    "title": "Robótica",
    "section": "ROS2: Componentes principales",
    "text": "ROS2: Componentes principales\n\n\nTopics\n\nMétodo de comunicación para los nodos\n\n\n\nPublisher / Suscriber\n\n\n\n\n\n\n\n\n\n\n\nMedio de comunicación entre nodos\nLos nodos pueden publicar o subscribirse: Generalmente en un esquema 1-pub y n-subs"
  },
  {
    "objectID": "clases/02/index.html#ros2-componentes-principales-2",
    "href": "clases/02/index.html#ros2-componentes-principales-2",
    "title": "Robótica",
    "section": "ROS2: Componentes principales",
    "text": "ROS2: Componentes principales\n\n\nMensajes\n\nEstructura de datos que define un topic\n\n\n\n\n\n\n\n\n\n\nEstructura de datos que define el “tipo” de topic\nSe compone de tipos “estándares” o puede ser compuesto por otros “msg”\nSe define en archivos con extensión “.msg”"
  },
  {
    "objectID": "clases/02/index.html#laboratorio",
    "href": "clases/02/index.html#laboratorio",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\n\nInstalación de ROS2\nEmisor / Receptor\nComandos para análisis de nodos, topics y mensajes"
  },
  {
    "objectID": "clases/10/tres.html",
    "href": "clases/10/tres.html",
    "title": "Clase 10 - Taller de resolución",
    "section": "",
    "text": "Dada las velocidades angulares de las ruedas (derecha \\(\\textcolor{Blue}{\\upsilon_R}\\) e izquierda \\(\\textcolor{Blue}{\\upsilon_L}\\)) y las propiedades geométricos del robot (separación entre las ruedas \\(\\textcolor{Gray}{b}\\) y radio de las ruedas \\(r\\)), calcular su velocidad angular \\(\\textcolor{Orange}{\\dot\\theta}\\) y radio de giro \\(\\textcolor{ForestGreen}{{R}}\\) al rededor del \\(\\textcolor{Plum}{ICR}\\):\n\n\\[\n{\\Large\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}\n\\end{split}\n}\n\\]\n\n\n\n\nDada la velocidad lineal \\(\\textcolor{ForestGreen}{\\dot{x}}\\) y la velocidad angular \\(\\textcolor{Orange}{\\dot\\theta}\\) del robot junto con las propiedades geométricas (separación entre las ruedas \\(\\textcolor{Gray}{b}\\) y radio de las ruedas \\(r\\)), calcular las velocidades angulares de la rueda derecha \\(\\textcolor{Blue}{\\upsilon_R}\\) e izquierda \\(\\textcolor{Blue}{\\upsilon_L}\\):\n\n\\[\n{\\Large\n\\begin{cases}\n    \\textcolor{Plum}{\\dot\\phi_R} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} + \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta}) \\\\[0.5em]\n    \\textcolor{Plum}{\\dot\\phi_L} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} - \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta})\n\\end{cases}\n}\n\\]\n\n\n\n\n\n\n\n\n\nPose en el marco de referencia local del robot \\(\\textcolor{Maroon}{\\mathcal{P}: \\{ \\mathcal{X}_R, \\mathcal{Y}_R \\}}\\)\n\n\\[\n{\\Large\n{}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot \\xi} =\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}} = \\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n}\n\\]\n\nPose en el marco de referencia inercial (global) \\(\\textcolor{Blue}{\\mathcal{O}: \\{ \\mathcal{X}_O, \\mathcal{Y}_O \\}}\\)\n\n\\[\n{\\Large\n{}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} = \\boldsymbol{R}(\\textcolor{Orange}{\\theta}) {}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{P} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n}\n\\]"
  },
  {
    "objectID": "clases/10/tres.html#universidad-nacional-del-litoral-unl",
    "href": "clases/10/tres.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 10 - Taller de resolución",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/10/tres.html#modelo-cinemático-directo",
    "href": "clases/10/tres.html#modelo-cinemático-directo",
    "title": "Clase 10 - Taller de resolución",
    "section": "",
    "text": "Dada las velocidades angulares de las ruedas (derecha \\(\\textcolor{Blue}{\\upsilon_R}\\) e izquierda \\(\\textcolor{Blue}{\\upsilon_L}\\)) y las propiedades geométricos del robot (separación entre las ruedas \\(\\textcolor{Gray}{b}\\) y radio de las ruedas \\(r\\)), calcular su velocidad angular \\(\\textcolor{Orange}{\\dot\\theta}\\) y radio de giro \\(\\textcolor{ForestGreen}{{R}}\\) al rededor del \\(\\textcolor{Plum}{ICR}\\):\n\n\\[\n{\\Large\n\\begin{split}\n\\textcolor{Orange}{\\dot\\theta} = \\frac{r}{\\textcolor{Gray}{b}}(\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L})\n\\end{split}\n\\quad\\quad\\quad\n\\begin{split}\n\\textcolor{ForestGreen}{{R}} = \\frac{\\textcolor{Gray}{b}}{2} \\frac{\\textcolor{Plum}{\\dot\\phi_R} + \\textcolor{Plum}{\\dot\\phi_L}}{\\textcolor{Plum}{\\dot\\phi_R} - \\textcolor{Plum}{\\dot\\phi_L}}\n\\end{split}\n}\n\\]"
  },
  {
    "objectID": "clases/10/tres.html#modelo-cinemático-inverso",
    "href": "clases/10/tres.html#modelo-cinemático-inverso",
    "title": "Clase 10 - Taller de resolución",
    "section": "",
    "text": "Dada la velocidad lineal \\(\\textcolor{ForestGreen}{\\dot{x}}\\) y la velocidad angular \\(\\textcolor{Orange}{\\dot\\theta}\\) del robot junto con las propiedades geométricas (separación entre las ruedas \\(\\textcolor{Gray}{b}\\) y radio de las ruedas \\(r\\)), calcular las velocidades angulares de la rueda derecha \\(\\textcolor{Blue}{\\upsilon_R}\\) e izquierda \\(\\textcolor{Blue}{\\upsilon_L}\\):\n\n\\[\n{\\Large\n\\begin{cases}\n    \\textcolor{Plum}{\\dot\\phi_R} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} + \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta}) \\\\[0.5em]\n    \\textcolor{Plum}{\\dot\\phi_L} = \\frac{1}{r} (\\textcolor{ForestGreen}{\\dot{x}} - \\frac{\\textcolor{Gray}{b}}{2} \\textcolor{Orange}{\\dot\\theta})\n\\end{cases}\n}\n\\]"
  },
  {
    "objectID": "clases/10/tres.html#marco-inercial",
    "href": "clases/10/tres.html#marco-inercial",
    "title": "Clase 10 - Taller de resolución",
    "section": "",
    "text": "Pose en el marco de referencia local del robot \\(\\textcolor{Maroon}{\\mathcal{P}: \\{ \\mathcal{X}_R, \\mathcal{Y}_R \\}}\\)\n\n\\[\n{\\Large\n{}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot \\xi} =\n\\sideset{^\\textcolor{Maroon}{R}}{}{\\begin{bmatrix}\n    \\textcolor{ForestGreen}{\\dot{x}} \\\\\n    \\textcolor{ForestGreen}{\\dot{y}} \\\\\n    \\textcolor{Orange}{\\dot\\theta}\n\\end{bmatrix}} = \\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n}\n\\]\n\nPose en el marco de referencia inercial (global) \\(\\textcolor{Blue}{\\mathcal{O}: \\{ \\mathcal{X}_O, \\mathcal{Y}_O \\}}\\)\n\n\\[\n{\\Large\n{}^\\textcolor{Blue}{O} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{R} = \\boldsymbol{R}(\\textcolor{Orange}{\\theta}) {}^\\textcolor{Maroon}{R} \\boldsymbol{\\dot\\xi}_\\textcolor{Maroon}{P} =\n\\begin{bmatrix}\n\\cos{\\textcolor{Orange}{\\theta}} & -\\sin{\\textcolor{Orange}{\\theta}} & 0 \\\\\n\\sin{\\textcolor{Orange}{\\theta}} & \\cos{\\textcolor{Orange}{\\theta}} & 0 \\\\\n0 & 0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\frac{r}{2} & \\frac{r}{2}\\\\\n    0 & 0\\\\\n    \\frac{r}{\\textcolor{Gray}{b}} & - \\frac{r}{\\textcolor{Gray}{b}}\n\\end{bmatrix} \\begin{bmatrix} \\textcolor{Plum}{\\dot\\phi_R} \\\\ \\textcolor{Plum}{\\dot\\phi_L} \\end{bmatrix}\n}\n\\]"
  },
  {
    "objectID": "clases/11/tres.html",
    "href": "clases/11/tres.html",
    "title": "Clase 11 - Taller de resolución",
    "section": "",
    "text": "Distancia recorrida por la rueda derecha: \\[\nd_{R_k} = (\\textcolor{Plum}{\\phi_{R_k}} - \\textcolor{Plum}{\\phi_{R_{k-1}}}) r\n\\]\nDistancia recorrida por la rueda izquierda: \\[\nd_{L_k} = (\\textcolor{Plum}{\\phi_{L_k}} - \\textcolor{Plum}{\\phi_{L_{k-1}}}) r\n\\]\nDistancia recorrida por el robot: \\[\n\\textcolor{Blue}{\\Delta d_{k}} = \\frac{d_{R_k} + d_{L_k}}{2}\n\\]\nDesplazamiento angular del robot: \\[\n\\textcolor{Blue}{\\Delta \\theta_k} = \\frac{d_{R_k} - d_{L_k}}{b}\n\\]\nCálculo de odometría: \\[\n\\boldsymbol{\\xi}(t_{k+1}) \\approx \\boldsymbol{\\xi}(t_k) + \\dot{\\boldsymbol{\\xi}}(t_k)(t_{k+1}-t_{k})\n\\]\n\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1}) =\n\\begin{bmatrix}\n\\textcolor{ForestGreen}{{x}_{k+1}}\\\\\n\\textcolor{ForestGreen}{{y}_{k+1}}\\\\\n\\textcolor{Orange}{\\theta_{k+1}}  \n\\end{bmatrix} \\approx\n\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}}\\\\\n    \\textcolor{ForestGreen}{{y}_{k}}\\\\\n    \\textcolor{Orange}{\\theta_{k}}  \n\\end{bmatrix}\n+\n\\begin{bmatrix}\n    \\cos{\\textcolor{Orange}{\\theta_k}} & 0\\\\\n    \\sin{\\textcolor{Orange}{\\theta_k}} & 0\\\\\n    0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\textcolor{Blue}{\\Delta d_{k}}\\\\\n    \\textcolor{Blue}{\\Delta \\theta_k}\n\\end{bmatrix}\n\\]\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1})\n\\begin{cases}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\approx \\textcolor{ForestGreen}{{x}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\cos{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\approx \\textcolor{ForestGreen}{{y}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\sin{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{Orange}{\\theta_{k+1}}   \\approx \\textcolor{Orange}{\\theta_{k}}   + \\textcolor{Blue}{\\Delta \\theta_k}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/11/tres.html#universidad-nacional-del-litoral-unl",
    "href": "clases/11/tres.html#universidad-nacional-del-litoral-unl",
    "title": "Clase 11 - Taller de resolución",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "clases/11/tres.html#cálculo-de-odometría-para-un-robot-diferencial",
    "href": "clases/11/tres.html#cálculo-de-odometría-para-un-robot-diferencial",
    "title": "Clase 11 - Taller de resolución",
    "section": "",
    "text": "Distancia recorrida por la rueda derecha: \\[\nd_{R_k} = (\\textcolor{Plum}{\\phi_{R_k}} - \\textcolor{Plum}{\\phi_{R_{k-1}}}) r\n\\]\nDistancia recorrida por la rueda izquierda: \\[\nd_{L_k} = (\\textcolor{Plum}{\\phi_{L_k}} - \\textcolor{Plum}{\\phi_{L_{k-1}}}) r\n\\]\nDistancia recorrida por el robot: \\[\n\\textcolor{Blue}{\\Delta d_{k}} = \\frac{d_{R_k} + d_{L_k}}{2}\n\\]\nDesplazamiento angular del robot: \\[\n\\textcolor{Blue}{\\Delta \\theta_k} = \\frac{d_{R_k} - d_{L_k}}{b}\n\\]\nCálculo de odometría: \\[\n\\boldsymbol{\\xi}(t_{k+1}) \\approx \\boldsymbol{\\xi}(t_k) + \\dot{\\boldsymbol{\\xi}}(t_k)(t_{k+1}-t_{k})\n\\]\n\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1}) =\n\\begin{bmatrix}\n\\textcolor{ForestGreen}{{x}_{k+1}}\\\\\n\\textcolor{ForestGreen}{{y}_{k+1}}\\\\\n\\textcolor{Orange}{\\theta_{k+1}}  \n\\end{bmatrix} \\approx\n\\begin{bmatrix}\n    \\textcolor{ForestGreen}{{x}_{k}}\\\\\n    \\textcolor{ForestGreen}{{y}_{k}}\\\\\n    \\textcolor{Orange}{\\theta_{k}}  \n\\end{bmatrix}\n+\n\\begin{bmatrix}\n    \\cos{\\textcolor{Orange}{\\theta_k}} & 0\\\\\n    \\sin{\\textcolor{Orange}{\\theta_k}} & 0\\\\\n    0 & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n    \\textcolor{Blue}{\\Delta d_{k}}\\\\\n    \\textcolor{Blue}{\\Delta \\theta_k}\n\\end{bmatrix}\n\\]\n\\[\n{}^{O} \\boldsymbol{\\xi}_{R} (t_{k+1})\n\\begin{cases}\n    \\textcolor{ForestGreen}{{x}_{k+1}} \\approx \\textcolor{ForestGreen}{{x}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\cos{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{ForestGreen}{{y}_{k+1}} \\approx \\textcolor{ForestGreen}{{y}_{k}} + \\textcolor{Blue}{\\Delta d_{k}}     \\sin{\\textcolor{Orange}{\\theta_k}} \\\\[.5em]\n    \\textcolor{Orange}{\\theta_{k+1}}   \\approx \\textcolor{Orange}{\\theta_{k}}   + \\textcolor{Blue}{\\Delta \\theta_k}\n\\end{cases}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#navegación",
    "href": "clases/17/index.html#navegación",
    "title": "Robótica",
    "section": "Navegación",
    "text": "Navegación\n\nÁrea más desafiante en robótica móvil\n\n4 pilares\n\nPercepción\nLocalización\nControl\nCognición"
  },
  {
    "objectID": "clases/17/index.html#control-cinemático-1",
    "href": "clases/17/index.html#control-cinemático-1",
    "title": "Robótica",
    "section": "Control cinemático",
    "text": "Control cinemático\n\n\n\nDos problemas principales\n\n\nPoint tracking\nPose tracking"
  },
  {
    "objectID": "clases/17/index.html#control-a-lazo-abierto",
    "href": "clases/17/index.html#control-a-lazo-abierto",
    "title": "Robótica",
    "section": "Control a lazo abierto",
    "text": "Control a lazo abierto\n\n\n\nEncontrar una secuencia finita de controles para desplazar el robot desde cualquier posición inicial a cualquier otra posición deseada\nEste tipo de sistemas son localmente controlables y factibles\nSin verificación del error final\nProblemas:\n\nEntornos dinámicos\nAdaptabilidad\netc.."
  },
  {
    "objectID": "clases/17/index.html#control-a-lazo-cerrado",
    "href": "clases/17/index.html#control-a-lazo-cerrado",
    "title": "Robótica",
    "section": "Control a lazo cerrado",
    "text": "Control a lazo cerrado\n\nDiseñar lazos de retroalimentación que estabilicen el sistema en torno a un punto del espacio de estados\nSea \\(q\\) la posición del robot y \\(q_G = \\begin{bmatrix} x_G & y_G & \\theta_G \\end{bmatrix}^\\top\\) el punto de referencia\nSe entiende por estabilizar el sistema a diseñar una ley de control \\(u(q, q_G)\\) tal que el sistema de lazo cerrado\n\n\\[\n\\dot{q} = \\boldsymbol{A}(q) u(q, q_G) = f(q, q_G)\n\\]\nconverja para cualquier estado inicial \\(q(0)\\) a un punto de equilibrio en \\(\\mathcal{Q}\\)\n\\[\n\\mathcal{Q} = \\left\\{ (x, y, \\theta) = (x_G,  y_G, \\theta_G + 2 \\pi n); n = 0, \\pm 1, \\pm 2, \\dots \\right\\}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#seguimiento-de-punto-1",
    "href": "clases/17/index.html#seguimiento-de-punto-1",
    "title": "Robótica",
    "section": "Seguimiento de punto",
    "text": "Seguimiento de punto\n\nDefinición del problema\n\n\n\n\nSea una posición y orientación arbitraria del robot\nSea una posición objetivo\nVector de error de pose: \\[\n\\require{mathtools}\ne = {}^\\textrm{R}{\\begin{bmatrix} x & y & \\theta \\end{bmatrix}^{\\intercal}}\n\\]\n\ndonde \\(x\\), \\(y\\) y \\(\\theta\\) son las coordenadas objetivo en el marco de referencia del robot \\(\\left\\{ X_\\textrm{R}, Y_\\textrm{R}, \\theta \\right\\}\\)"
  },
  {
    "objectID": "clases/17/index.html#seguimiento-de-punto-2",
    "href": "clases/17/index.html#seguimiento-de-punto-2",
    "title": "Robótica",
    "section": "Seguimiento de punto",
    "text": "Seguimiento de punto\n\nDefinición del problema\n\n\n\n\nSe debe encontrar una matriz de control \\(\\boldsymbol{K}\\) (si existe), tal que los controles \\(\\nu(t)\\) y \\(\\omega(t)\\)\n\n\\[\n\\begin{bmatrix}\n\\nu(t) \\\\\n\\omega(t)\n\\end{bmatrix} = \\boldsymbol{K} \\cdot e =\n\\boldsymbol{K} \\cdot {\\begin{bmatrix} x \\\\ y \\\\ \\theta \\end{bmatrix}}\n\\]\nreduzcan el vector de error \\(e\\) hacia cero:\n\\[\n\\lim_{t \\to \\infty} e(t) = 0\n\\]"
  },
  {
    "objectID": "clases/17/index.html#seguimiento-de-punto-3",
    "href": "clases/17/index.html#seguimiento-de-punto-3",
    "title": "Robótica",
    "section": "Seguimiento de punto",
    "text": "Seguimiento de punto\n\nDefinición del problema\n\n\n\n\nMatriz de control \\(\\boldsymbol{K}\\):\n\n\\[\n\\boldsymbol{K}(t,e) = \\begin{bmatrix}\nk_{11} & k_{12} & k_{13} \\\\\nk_{21} & k_{22} & k_{23}\n\\end{bmatrix}\n\\]\ncon \\(k_{ij} = k(t,e)\\)\n\n\\[\n\\begin{bmatrix}\n\\nu(t) \\\\\n\\omega(t)\n\\end{bmatrix} =\n\\begin{bmatrix}\nk_{11} & k_{12} & k_{13} \\\\\nk_{21} & k_{22} & k_{23}\n\\end{bmatrix}\n\\cdot {\\begin{bmatrix} x \\\\ y \\\\ \\theta \\end{bmatrix}}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#transformación-modelo-cinemático",
    "href": "clases/17/index.html#transformación-modelo-cinemático",
    "title": "Robótica",
    "section": "Transformación modelo cinemático",
    "text": "Transformación modelo cinemático\n\n\n\n\nModelo cinemático de un robot diferencial para el marco inercial \\(\\left\\{ X_\\textrm{I}, Y_\\textrm{I}, \\theta \\right\\}\\):\n\n\n\n\\[\n\\sideset{^I}{}{\n\\begin{bmatrix}\n\\dot{x} \\\\\n\\dot{y} \\\\\n\\dot{\\theta}\n\\end{bmatrix}} =\n\\begin{bmatrix}\n\\cos{\\theta} & 0\\\\\n\\sin{\\theta} & 0\\\\\n0            & 1\n\\end{bmatrix}\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}\n\\]\n\n\n\nTransformación en coordenadas polares\n\n\n\n\\[\n\\begin{cases}\n\\rho = \\sqrt{{\\Delta x}^2 + {\\Delta y}^2} \\\\\n\\alpha = \\arctan \\left( {\\frac{\\Delta y}{\\Delta x}} \\right) - \\theta\\\\\n\\beta = -\\theta - \\alpha\n\\end{cases}\n\\]\n\n\npara \\(\\alpha \\in \\boldsymbol{I_1} = \\left( -\\tfrac{\\pi}{2} , \\tfrac{\\pi}{2} \\right]\\)"
  },
  {
    "objectID": "clases/17/index.html#transformación-modelo-cinemático-1",
    "href": "clases/17/index.html#transformación-modelo-cinemático-1",
    "title": "Robótica",
    "section": "Transformación modelo cinemático",
    "text": "Transformación modelo cinemático\n\nEncontrar el nuevo sistema de ecuaciones:\n\n\\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\boldsymbol{A} \\cdot\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}\n\\]\n\n\nAl derivar las expresiones de la transformación a coordenadas polares, se obtiene: \\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-\\cos{\\alpha}                   & 0\\\\\n\\tfrac{\\sin{\\alpha}}{\\rho}      & -1\\\\\n-\\tfrac{\\sin{\\alpha}}{\\rho}     & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#transformación-modelo-cinemático-2",
    "href": "clases/17/index.html#transformación-modelo-cinemático-2",
    "title": "Robótica",
    "section": "Transformación modelo cinemático",
    "text": "Transformación modelo cinemático\n\n\nEn resumen:\n\n\n\n\\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-\\cos{\\alpha}                   & 0\\\\\n\\tfrac{\\sin{\\alpha}}{\\rho}      & -1\\\\\n-\\tfrac{\\sin{\\alpha}}{\\rho}     & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}\n\\]\n\n\n\nSi \\(\\alpha \\in \\boldsymbol{I_2} = \\left( -\\pi , -\\tfrac{\\pi}{2} \\right] \\cup \\left( \\tfrac{\\pi}{2} , \\pi \\right]\\), se puede redefinir la dirección hacia adelante tal que \\(\\nu = -\\nu\\), y obtener un sistema similar:\n\n\n\n\\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\begin{bmatrix}\n\\cos{\\alpha}                   & 0\\\\\n-\\tfrac{\\sin{\\alpha}}{\\rho}      & 1\\\\\n\\tfrac{\\sin{\\alpha}}{\\rho}     & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\n\\nu\\\\\n\\omega\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#transformación-modelo-cinemático-3",
    "href": "clases/17/index.html#transformación-modelo-cinemático-3",
    "title": "Robótica",
    "section": "Transformación modelo cinemático",
    "text": "Transformación modelo cinemático\n\nConsideraciones\n\n\nLa transformación de coordenadas no está definida en el punto \\(x = y = 0\\) \nPara \\(\\alpha \\in \\boldsymbol{I_1}\\), la dirección de avance del robot apunta hacia el objetivo, mientras que para \\(\\alpha \\in \\boldsymbol{I_2}\\), apunta en dirección opuesta\nAl definir correctamente la dirección de avance del robot en su configuración inicial, siempre es posible que \\(\\alpha \\in \\boldsymbol{I_1}\\) en \\(t = 0\\). Sin embargo, esto no garantiza que \\(\\alpha\\) permanezca en \\(\\boldsymbol{I_1}\\) para todo tiempo \\(t\\). Por lo tanto, para evitar que el robot cambie de dirección al acercarse al objetivo, es necesario, diseñar el controlador de forma que \\(\\alpha \\in \\boldsymbol{I_1}\\) para todo \\(t\\), siempre que \\(\\alpha(0) \\in \\boldsymbol{I_1}\\)\n\n(ANÁLISIS DE ESTABILIDAD)"
  },
  {
    "objectID": "clases/17/index.html#diseño-del-controlador",
    "href": "clases/17/index.html#diseño-del-controlador",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\nSe deben diseñar dos señales de control \\(\\nu\\) y \\(\\omega\\), que lleven el robot desde la posición actual \\(\\left( \\rho, \\alpha, \\beta \\right)\\) a la posición objetivo\nEl sistema presenta una discontinuidad en \\(\\rho = 0\\) (\\(x = y = 0\\))\nSi consideramos la ley de control lineal\n\n\\[\n\\begin{cases}\n\\nu = k_\\rho \\rho \\\\\n\\omega = k_\\alpha \\alpha + k_\\beta \\beta\n\\end{cases}\n\\]\n\nSe obtiene el sistema a lazo cerrado descripto por:\n\n\\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-\\cos{\\alpha}                   & 0\\\\\n\\tfrac{\\sin{\\alpha}}{\\rho}      & -1\\\\\n-\\tfrac{\\sin{\\alpha}}{\\rho}     & 0\n\\end{bmatrix}\n\\cdot\n\\begin{bmatrix}\nk_\\rho \\rho\\\\\nk_\\alpha \\alpha + k_\\beta \\beta\n\\end{bmatrix} =\n\\begin{bmatrix}\n-\\cos{(\\alpha)} k_\\rho \\rho \\\\\n\\sin{(\\alpha)} k_\\rho - k_\\alpha \\alpha - k_\\beta \\beta \\\\\n-\\sin{(\\alpha)} k_\\rho\n\\end{bmatrix}\n\\]"
  },
  {
    "objectID": "clases/17/index.html#diseño-del-controlador-1",
    "href": "clases/17/index.html#diseño-del-controlador-1",
    "title": "Robótica",
    "section": "Diseño del controlador",
    "text": "Diseño del controlador\n\\[\n\\begin{bmatrix}\n\\dot{\\rho} \\\\\n\\dot{\\alpha} \\\\\n\\dot{\\beta}\n\\end{bmatrix} =\n\\begin{bmatrix}\n-\\cos{(\\alpha)} k_\\rho \\rho \\\\\n\\sin{(\\alpha)} k_\\rho - k_\\alpha \\alpha - k_\\beta \\beta \\\\\n-\\sin{(\\alpha)} k_\\rho\n\\end{bmatrix}\n\\]\n\nEl sistema ya no presenta singularidad en \\(\\rho = 0\\)\nTiene un único punto de equilibrio en \\(\\left( \\rho, \\alpha, \\beta \\right) = \\left( 0, 0, 0 \\right)\\), por lo tanto, conducirá al robot a dicho punto, que corresponde a la posición objetivo\nLos ángulos \\(\\alpha\\) y \\(\\beta\\) deben expresarse siempre en el intervalo \\((-\\pi, \\pi)\\)\nEl control de velocidad lineal \\(\\nu\\) siempre tiene un signo constante: es positiva cuando \\(\\alpha(0) \\in \\boldsymbol{I_1}\\) y negativa en cualquier otro caso. El robot realiza la maniobra siempre en una sola dirección, sin invertir el sentido de su movimiento.\nEl sistema es estable para \\(k_\\rho &gt; 0\\), \\(k_\\beta &lt; 0\\) y \\(k_\\alpha - k_\\rho &gt; 0\\)"
  },
  {
    "objectID": "clases/17/index.html#simulaciones",
    "href": "clases/17/index.html#simulaciones",
    "title": "Robótica",
    "section": "Simulaciones",
    "text": "Simulaciones\n\n\n\nTrayectorias resultantes al inicializar el robot en un circulo de radio 2\nValores de \\(\\theta = \\left[ -135°; 180°\\right]\\) a intervalos de \\(45°\\)\nValores adoptados:\n\n\\(k_\\rho = 3.0\\)\n\\(k_\\alpha = 8.0\\)\n\\(k_\\beta = -1.5\\)"
  },
  {
    "objectID": "clases/17/index.html#simulaciones-1",
    "href": "clases/17/index.html#simulaciones-1",
    "title": "Robótica",
    "section": "Simulaciones",
    "text": "Simulaciones\n\n\n\nAnálisis de sensibilidad de \\(k_\\rho\\)\n\\(\\theta_0 = 90°\\)\n\\(k_\\alpha = 8.0\\) y \\(k_\\beta = -1.5\\)"
  },
  {
    "objectID": "clases/17/index.html#simulaciones-2",
    "href": "clases/17/index.html#simulaciones-2",
    "title": "Robótica",
    "section": "Simulaciones",
    "text": "Simulaciones\n\n\n\nAnálisis de sensibilidad de \\(k_\\alpha\\)\n\\(\\theta_0 = 90°\\)\n\\(k_\\rho = 3.0\\) y \\(k_\\beta = -1.5\\)"
  },
  {
    "objectID": "clases/17/index.html#simulaciones-3",
    "href": "clases/17/index.html#simulaciones-3",
    "title": "Robótica",
    "section": "Simulaciones",
    "text": "Simulaciones\n\n\n\nAnálisis de sensibilidad de \\(k_\\beta\\)\n\\(\\theta_0 = 90°\\)\n\\(k_\\rho = 3.0\\) y \\(k_\\alpha = 8.0\\)"
  },
  {
    "objectID": "clases/17/index.html#laboratorio-1",
    "href": "clases/17/index.html#laboratorio-1",
    "title": "Robótica",
    "section": "Laboratorio",
    "text": "Laboratorio\nControlador point follower"
  },
  {
    "objectID": "entregables/01/entregable1.html",
    "href": "entregables/01/entregable1.html",
    "title": "Ejercicios",
    "section": "",
    "text": "Fecha de entrega: 22 de Junio\nFormato de entrega: Archivo comprimido con el código fuente de los paquetes. Formato pdf en caso de necesitar entregar ejercicios de desarrollo. Proveer en un archivo de texto README.md los comandos necesarios para la ejecución de el/los paquete/s para los ejercicios.\nArchivos disponibles: entregable-1.zip\n\nCarpeta meshes con archivos .stl para las geometrías visuales de los componentes del robot.\nCarpeta urdf con dos archivos: inertial_macros.xacro con definición de inercias y materiales de ejemplo; motor.xacrocon macro para insertar un motor en el robot."
  },
  {
    "objectID": "entregables/01/entregable1.html#universidad-nacional-del-litoral-unl",
    "href": "entregables/01/entregable1.html#universidad-nacional-del-litoral-unl",
    "title": "Ejercicios",
    "section": "Universidad Nacional del Litoral (UNL)\n",
    "text": "Universidad Nacional del Litoral (UNL)\n\n\nFacultad de Ingeniería y Ciencias Hídricas (FICH) \n\nTecnicatura en Automatización y Robótica (TUAR)"
  },
  {
    "objectID": "entregables/01/entregable1.html#urdf",
    "href": "entregables/01/entregable1.html#urdf",
    "title": "Ejercicios",
    "section": "URDF",
    "text": "URDF\nCrear un paquete de ROS llamado (*)_description para albergar el robot description siguiendo la estructura vista en clases. Crear un archivo de definición del robot en formato XACRO respetando la geometría representada en las vistas del anexo y cumpliendo con los siguientes requerimientos:\n\nDebe contener al menos un base_link asignado al chasis del robot y un link y un joint por cada rueda\nCada link deberá tener definida la geometría visual y de colisión, según la tabla correspondiente del anexo\nDebe estar parametrizado al menos el radio de las ruedas de tracción y la separación de las mismas\nEn caso de poder reutilizar bloques, hacer uso de macros\nUtilice el macro motor importando el archivo motor.xacro para ubicar el motor izquierdo y derecho. El macro recibe 3 parámetros:\n\nprefix (String): para diferenciar el link con un prefijo\nchassis_width (Double): ancho del chasis\nreflect (Bool): No reflejar (False) o sí reflejar (True). La orientación original es hacia la izquierda\n\n\n\nEn el mismo paquete, crear un archivo launch de nombre description.launch.py, en el cuál se deberá procesar el archivo XACRO con la descripción del robot y se deberá publicar la misma a través del paquete robot_state_publisher. El launch deberá recibir, a través de un parámetro de tipo bool llamado testing, la condición para ejecutar o no el paquete joint_state_publisher_gui y RViz.\n\n\n\n\n\n\nEste archivo será útil para probar el archivo del ejercicio anterior, por lo que se recomienda realizarlos en paralelo"
  },
  {
    "objectID": "entregables/01/entregable1.html#gazebo",
    "href": "entregables/01/entregable1.html#gazebo",
    "title": "Ejercicios",
    "section": "Gazebo",
    "text": "Gazebo\nEditar el o los archivos XACRO del ejercicio 1, de manera que sea/n compatible/s con los requerimientos de Gazebo, haciendo uso de los macros disponibles en el archivo inertial_macros.xacro.\nCrear un paquete (*)_gz y un archivo launch nuevo, que ejecute Gazebo, procese la descripción del robot y, utilizando el ejecutable spawn_entity.py, cargue el robot en el simulador. Puede reutilizar el archivo creado en el ejercicio 2 incluyéndolo (no debe ejecutar el joint_state_publisher_gui ni RViz)."
  },
  {
    "objectID": "entregables/01/entregable1.html#ros2-control",
    "href": "entregables/01/entregable1.html#ros2-control",
    "title": "Ejercicios",
    "section": "ROS2 control",
    "text": "ROS2 control\nEditar el archivo de definición del robot y agregar los elementos necesarios para configurar ROS2 control y Gazebo de forma tal que las juntas correspondientes a las ruedas de tracción reciban comandos de velocidad y devuelvan el estado de posición y velocidad. Para esto deberá añadir los tags &lt;ros2_control&gt; y &lt;gazebo&gt;.\nCrear un paquete (*)_control, con una carpeta config y un archivo de configuración en formato YAML con los parámetros necesarios para que el controller_manager de ROS2 control cargue un JointStateBroadcaster y dos controladores de velocidad de tipo JointGroupVelocityController, uno para cada rueda de tracción.\nEditar el archivo launch del ejercicio 3 para invocar al comando load_controller de ros2_control y cargar los controladores del inciso anterior."
  },
  {
    "objectID": "entregables/01/entregable1.html#cinemática",
    "href": "entregables/01/entregable1.html#cinemática",
    "title": "Ejercicios",
    "section": "Cinemática",
    "text": "Cinemática\nCalcular la velocidad lineal y angular del robot y de las ruedas para que se complete:\n\nuna trayectoria recta de 1[m] en 10 [s].\nuna trayectoria circular con un radio de 0.5 [m] en sentido horario en 20 [s].\n\nExaminar la definición de los mensajes de tipo geometry_msgs/Twist y describir cuál sería la secuencia de comandos de velocidad a aplicar al robot para seguir la trayectoria mostrada en la Figure 1 utilizando dichos mensajes. La velocidad máxima de giro de los motores es de \\(50 [rpm]\\).\n\n\n\n\n\n\nFigure 1: Trayectoria para el ejercicio 6\n\n\n\n\n\n\n\n\n\nEl punto inicial del robot será asignado por el docente.\n\n\n\nExaminar la definición de los mensajes del topic suscripto por el JointGroupVelocityController. Calcule las velocidades angulares de las ruedas para cada comando del ejercicio 6 y construya la secuencia de mensajes de comando correspondientes.\n\n\n\n\n\n\nEl campo layout no se debe completar.\n\n\n\nDentro del paquete (*)_control, cree un nodo que reciba comandos de tipo geometry_msgs/Twist a través de un topic llamado cmd_vel, calcule las velocidades angulares en base al modelo cinemático inverso del robot y escriba los comandos de velocidad de cada rueda de tracción en los topics left_wheel_cmd y right_wheel_cmd. Tenga en cuenta que los parámetros del robot se encuentran en el robot description."
  },
  {
    "objectID": "entregables/01/entregable1.html#odometría",
    "href": "entregables/01/entregable1.html#odometría",
    "title": "Ejercicios",
    "section": "Odometría",
    "text": "Odometría\nCrear un nodo (en el mismo paquete que el ejercicio anterior o por separado) que lea el o los topics de posición de las juntas de las ruedas (publicados por el JointStateBroadcaster), calcule la odometría basado en el modelo cinemático directo del robot y publique la misma en el topic \\odom con mensajes de tipo nav_msgs/Odometry. El nodo debe recibir como parámetro las dimensiones geométricas del modelo cinemático y los nombres correspondientes a las juntas de las ruedas de tracción.\n\n\n\n\n\n\nNote\n\n\n\nEl campo twist y covariance en pose no se deben completar para el mensaje nav_msgs/Odometry.\n\n\nCree un nuevo paquete (*)_bringup con un archivo launch en el cual se cargue todo el sistema desarrollado (URDF, Gazebo, los controladores de ROS2 control) y los nodos de los ejercicios 8 y 9. Recuerde configurar correctamente los parámetros y topics de cada nodo. Puede probar que el robot se encuentra funcionando utilizando el teleop_twist_keyboard o publicando mensajes de Twist como los del ejercicio 5 o 6."
  },
  {
    "objectID": "entregables/01/entregable1.html#ros-2-y-tf2",
    "href": "entregables/01/entregable1.html#ros-2-y-tf2",
    "title": "Ejercicios",
    "section": "ROS 2 y tf2",
    "text": "ROS 2 y tf2\n\n(Opción A) Crear un nodo que publique la transformación entre los frames odom y base_link a partir de los mensajes del topic /odom. Agregar la ejecución del mismo al launch del ejercicio anterior.\n(Opción B) Modificar el nodo del ejercicio 9 para que que publique la transformación entre los frames odom y base_link. Agregar un parámetro para que cuando no se requiera esta transformación, no se publique.\n\nCree un archivo launch en el paquete (*)_bringup que extienda (inclusión o copia) al del ejercicio 10 y añada la ejecución de RViz junto con su respectivo archivo de configuración, el cual muestre el robot en el frame odom y las transformaciones de todos los links definidos en el URDF."
  }
]