---
title: Clase 06 - Laboratorio
format:
    html:
        code-fold: true
        code-copy: false
        #code-overflow: wrap
        toc: true
bread-crumbs: true
page-navigation: true
---

## Programaci칩n de nodos con par치metros

- #### Definir par치metros

En el constructor del nodo a trav칠s del atributo `self`:

>       self.declare_parameter('<nombre_parametro>', <valor>)

::: {.callout-note appearance="simple"}
El tipo es inferido a trav칠s del valor
:::

------

- #### Obtener el valor

Tipo texto (`string`):

>       self.get_parameter('<nombre_parametro>')
>               .get_parameter_value().string_value

Tipo entero (`int`), decimal (`double`), booleano (`bool`), es igual:

>       self.get_parameter('<nombre_parametro>').get_parameter_value().string_value.<int|double|bool>_value

## Programaci칩n de archivos *launch*

### Adecuaci칩n del paquete para albergar los archivos

- #### Crear una carpeta `launch`

Crear la carpeta `launch` que contendr치 los archivos

> ```
> 游늭 src
>   游늭 clase_06
>       游늭 launch                           拘勇
>           游늯 nombre_archivo.launch.py     拘勇
>           ...
>       游늬 resource
>       游늬 test
>       游늯 package.xml
>       ...
> ```

- #### Modificar el archivo `setup.py`

Modificar la configuraci칩n de `data_files` para instalar correctamente los archivos `launch`

```{.py filename="setup.py" code-fold="true" code-line-numbers="true"}
from setuptools import setup

import os
from glob import glob

package_name = 'nombre_paquete'

setup(
  name=package_name,
  # Otros par치metros ...
  data_files=[
    # ... Otros archivos
    # Incluir todos los archivos de la carpeta launch
    (os.path.join('share', package_name, 'launch'), glob('launch/*'))
  ],
  # El resto de la configuraci칩n ...
)
```

::: {.callout-note appearance="simple"}
Se recomienda agregar `ros2launch` como dependencia de ejecuci칩n: 

        <exec_depend>ros2launch</exec_depend>
:::

------

### Programaci칩n del *launch*

- #### Importar las librer칤as `launch` y `launch_ros`

```python
from launch import LaunchDescription
from launch_ros import actions
```

- #### Definir la funci칩n `generate_launch_description` que devolver치 el `LaunchDescription`

```python
def generate_launch_description():
    ...
    return LaunchDescription([
        # Contenido del launch
        ...
    ])
```

- #### *Actions*: Ejecutar un nodo

Importar la librer칤a

```python
from launch_ros.actions import Node
```

Crear la acci칩n

```{.py code-fold="true" code-line-numbers="true"}
def generate_launch_description():
    node = Node(
        package = '<nombre_paquete>',
        executable = '<nombre_ejecutable>',
        # Adicionales (seg칰n corresponda) 拘勇
        name = '<nombre_nodo>',
        namespace = '<nombre_namespace>',
        parameters = [ # Pueden ser archivos
            {'<nombre_parametro>': <valor>, .. }
        ],
        remappings = [
            ('<nombre_topic>', '<nuevo_nombre>'),
        ],
        output = '<screen|log|both>',
        ros_arguments = [...],
        arguments = [...],
    )

    return LaunchDescription([
        node,
        ...
    ])
```

::: {.callout-note}
No es necesario completar todos los campos, los requeridos son los m칤nimos para el comando `ros2 run`: `package` y `executable`
:::

- #### Declaraci칩n de argumentos

Importar la librer칤a

```python
from launch.substitutions import LaunchConfiguration
from launch.actions import DeclareLaunchArgument
```

Primero declarar los argumentos con `DeclareLaunchArgument` y luego utilizarlos mediante las sustituciones `LaunchConfiguration`

```{.py code-fold="true" code-line-numbers="true"}
...
def generate_launch_description():
  return LaunchDescription([
    DeclareLaunchArgument(
      '<nombre_parametro>', default_value=<valor>
    ),
    Node(
        package = '<nombre_paquete>',
        executable = '<nombre_ejecutable>',
        ...
        parameters=[{
            '<parametro_del_nodo>': LaunchConfiguration('<nombre_parametro>'),
        }]
    ),
  ])
```

------

## Uso de loggers

- #### Generar un mensaje de log 

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>')

------

```python
self.get_logger().info('Mensaje de prueba con severidad INFO')
```


- #### Generar un mensaje de log por 칰nica vez

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>', once=True)

------

```python
self.get_logger().warn('Advertencia una sola vez', once=True)
```

- #### Enviar el mensaje como m치ximo N veces por segundo

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>', throttle_duration_sec=<N>)

------

```python
self.get_logger().debug(f'Valor de la medicion {valor}', throttle_duration_sec=1)
```


------

# Sistema de Monitoreo de temperatura

#### Objetivos

* Crear un nodo publicador que env칤e mediciones de temperatura
* Crear un nodo suscriptor que escuche esas mediciones y emita una alarma si se supera un umbral de temperatura configurable
* Crear archivos de *launch* que permitan iniciar todo el sistema estableciendo los par치metros programados




## Crear el nodo: `temperature_sensor`

- El valor de temperatura es generado a partir de un valor base (`base_temperature`) con una variaci칩n aleatoria m치xima (`max_variation`) configurable ambas mediante par치metros
- Publica en el topic `\temperature` utilizando el tipo de mensaje [`sensor_msgs/msg/Temperature`](https://docs.ros2.org/latest/api/sensor_msgs/msg/Temperature.html){target="_blank"}

<!-- ::: {.callout-tip}
Puede utilizar el comando `ros2 interface show <tipo_mensaje>` para ver la composici칩n
::: -->

- Enviar un mensaje de log que muestre la temperatura generada (`info` o `debug`)
- Adem치s agregar un par치metro de configuraci칩n de la frecuencia de publicaci칩n en Hz (`publish_rate`)

|Nombre               | Tipo    | Descripci칩n                   | Valor por defecto |
|:--------------------|:-------:|:----------------------------  |:-----------------:|
| `base_temperature`  | `float` | Temperatura inicial/base en grados Celsius | 25.0 |
| `max_variation`     | `float` | M치xima variaci칩n aleatoria                 | 5.0  |
| `publish_rate`      | `int`   | Frecuencia de publicaci칩n en Hz            | 1    |

------

Para generar la temperatura puedes utilizar la funci칩n `uniform` de la librer칤a `random`

```.py
temperature = base_temperature + random.uniform(-max_variation, max_variation)
```
- `base_temperature`: valor base
- `max_variation`: cu치nto puede subir o bajar como m치ximo en cada medici칩n
- `random.uniform(a, b)`: genera un n칰mero flotante aleatorio entre `a` y `b`.


------

::: {.callout-note title="Opcional"}
Uno de los campos del mensaje de tipo `Temperature` es el `header`, que contiene un `stamp` de tipo `Time` y un `frame_id`, puedes completar dichos campos *opcionalmente*

Para obtener un `stamp` actual puedes utilizar el m칠todo `get_clock` de la clase `Node` de ROS:

```.py
msg.header.stamp = self.get_clock().now().to_msg()
msg.header.frame_id = 'sensor1'
```
:::


<!-- ```{.python filename="temperature_sensor.py" code-fold="true" code-line-numbers="true"}
import rclpy
from rclpy.node import Node

...

class <nombre_clase>(Node):
    __init__(self):
        super().__init__(<nombre_nodo>)
    ...
    def timer_callback(self):
        ...
        # Publicar el mensaje
        self.pub.publish(self.msg)

def main(args=None):
    # 1. Inicializaci칩n
    rclpy.init(args=args)
    # 2. Creaci칩n de nodo
    # nodo = ...
    # 3. Procesamiento de mensajes y callback
    rclpy.spin(nodo)
    # 4. Finalizaci칩n 
    rclpy.shutdown()


if __name__ == '__main__':
    main()
``` -->

## Crear el nodo `temperature_monitor`

- Suscribe al topic `\temperature` y por cada mensaje verifica si la temperatura supera un umbral cr칤tico configurable mediante un par치metro `alarm_threshold`
- Agregar un par치metro de configuraci칩n `temperature_unit` que definir치 la unidad utilizada para el umbral y las alertas de temperatura

::: {.callout-tip title="Conversi칩n 춿C a 춿F" appearance="simple"}
$$
T \, [춿F]  = T \, [춿C] \times 9/5 + 32
$$
:::

- Si supera el umbral imprime un mensaje de alarma con severidad `warn` y si no publicar la temperatura recibida con severidad `info` o `debug`

## Probar el sistema mediante `ros2 run`

- Ejecutar ambos nodos desde consola comprobando el funcionamiento de los valores por defecto de los par치metros y el funcionamiento del sistema en su conjunto
- Probar distintas ejecuciones variando los par치metros definidos y probar cambios de par치metros durante la ejecuci칩n, comprobando cuales tienen efecto inmediato y cuales requieren reinciar el nodo
- Comprobar el funcionamiento de los mensajes de log seg칰n distintos niveles de severidad seteados para cada nodo


## Crear el archivo `launch` para ambos nodos

- Iniciar ambos nodos
    - `temperature_sensor` con una temperatura base de 27춿C y una variaci칩n m치xima de 5춿C, con una frecuencia de publicaci칩n de 2Hz.
    - `temperature_monitor` con un umbral en 30춿C
- Declarar los argumentos necesarios para poder configurar los par치metros establecidos en ambos nodos
- Ambos nodos deben enviar la salida por la consola con nivel de severidad `info`

## Probar el sistema mediante `ros2 launch`

- Ejecutar el archivo `launch`creado para verificar el funcionamiento de los par치metros por defecto
- Probar distintas ejecuciones variando los par치metros definidos
