---
title: Clase 06 - Laboratorio
format:
    html:
        code-fold: true
        code-copy: false
        #code-overflow: wrap
        toc: true
bread-crumbs: true
page-navigation: true
---

## Programaci√≥n de nodos con par√°metros

- #### Definir par√°metros

En el constructor del nodo a trav√©s del atributo `self`:

>       self.declare_parameter('<nombre_parametro>', <valor>)

::: {.callout-note appearance="simple"}
El tipo es inferido a trav√©s del valor
:::

------

- #### Obtener el valor

Tipo texto (`string`):

>       self.get_parameter('<nombre_parametro>')
>               .get_parameter_value().string_value

Tipo entero (`int`), decimal (`double`), booleano (`bool`), es igual:

>       self.get_parameter('<nombre_parametro>').get_parameter_value().string_value.<int|double|bool>_value

## Programaci√≥n de archivos `launch`

- #### Crear una carpeta para los archivos

Crear la carpeta `launch` que contendr√° los archivos

> ```
> üìÇ src
>   üìÇ clase_06
>       üìÇ launch                           ‚¨ÖÔ∏è
>           üìÑ nombre_archivo.launch.py     ‚¨ÖÔ∏è
>           ...
>       üìÅ resource
>       üìÅ test
>       üìÑ package.xml
>       ...
> ```

- #### Modificar el archivo `setup.py`

Modificar la configuraci√≥n de `data_files` para instalar correctamente los archivos `launch`

```{.py filename="setup.py" code-fold="true" code-line-numbers="true"}
from setuptools import setup

import os
from glob import glob

package_name = 'nombre_paquete'

setup(
  name=package_name,
  # Otros par√°metros ...
  data_files=[
    # ... Otros archivos
    # Incluir todos los archivos de la carpeta launch
    (os.path.join('share', package_name, 'launch'), glob('launch/*'))
  ],
  # El resto de la configuraci√≥n ...
)
```

::: {.callout-note appearance="simple"}
Se recomienda agregar `ros2launch` como dependencia de ejecuci√≥n: 

        <exec_depend>ros2launch</exec_depend>
:::

------


- #### Importar las librer√≠as `launch` y `launch_ros`

```python
from launch import LaunchDescription
from launch_ros import actions
```

- #### Definir la funci√≥n `generate_launch_description` que devolver√° el `LaunchDescription`

```python
def generate_launch_description():
    ...
    return LaunchDescription([
        # Contenido del launch
        ...
    ])
```

- #### *Actions*: Ejecutar un nodo

Importar la librer√≠a

```python
from launch_ros.actions import Node
```

Crear la acci√≥n

```{.py code-fold="true" code-line-numbers="true"}
def generate_launch_description():
    node = Node(
        package = ‚Äô<nombre_paquete>‚Äô,
        executable = ‚Äô<nombre_ejecutable>‚Äô,
        # Adicionales ‚¨áÔ∏è
        name = ‚Äô<nombre_nodo>‚Äô,
        namespace = ‚Äô<nombre_namespace>‚Äô,
        parameters = [ # Pueden ser archivos
            {‚Äò<nombre_parametro>‚Äô: <valor>, .. }
        ],
        remappings = [
            ('<nombre_topic>', '<nuevo_nombre>'),
        ],
        output = ‚Äô<screen|log|both>‚Äô,
        ros_arguments = [...],
        arguments = [...],
    )

    return LaunchDescription([
        node,
        ...
    ])
```

::: {.callout-note}
No es necesario completar todos los campos, los requeridos son los m√≠nimos para el comando `ros2 run`: `package` y `executable`
:::

- #### Declaraci√≥n de argumentos

Importar la librer√≠a

```python
from launch.substitutions import LaunchConfiguration
from launch.actions import DeclareLaunchArgument
```

Primero declarar los argumentos con `DeclareLaunchArgument` y luego utilizarlos mediante las sustituciones `LaunchConfiguration`

```{.py code-fold="true" code-line-numbers="true"}
...
def generate_launch_description():
  return LaunchDescription([
    DeclareLaunchArgument(
      ‚Äò<nombre_parametro>‚Äô, default_value=<valor>
    ),
    Node(
      package = ‚Äô<nombre_paquete>‚Äô,
      executable = ‚Äô<nombre_ejecutable>‚Äô,
      ...
      parameters=[{
        '<parametro_del_nodo>': LaunchConfiguration('<nombre_parametro>'),
      }]
    ),
  ])
```

------

## Uso de loggers

- #### Generar un mensaje de log 

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>')

------

```python
self.get_logger().info('Mensaje de prueba con severidad INFO')
```


- #### Generar un mensaje de log por √∫nica vez

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>', once=True)

------

```python
self.get_logger().warn('Advertencia una sola vez', once=True)
```

- #### Enviar el mensaje como m√°ximo N veces por segundo

>       <nodo>.get_logger().{debug,info,warning,error,fatal}
>                 ('<mensaje_de_log>', throttle_duration_sec=<N>)

------

```python
self.get_logger().debug(f'Valor de la medicion {valor}', throttle_duration_sec=1)
```


------

# Sistema de Monitoreo de temperatura

#### Objetivos

* Crear un nodo publicador que env√≠e mediciones de temperatura
* Crear un nodo suscriptor que escuche esas mediciones y emita una alarma si se supera un umbral de temperatura configurable
* Crear archivos de *launch* que permitan iniciar todo el sistema estableciendo los par√°metros programados




## Crear el nodo: `temperature_sensor`

- El valor de temperatura es generado a partir de un valor base (`base_temperature`) con una variaci√≥n aleatoria m√°xima (`max_variation`) configurable ambas mediante par√°metros
- Publica en el topic `\temperature` utilizando el tipo de mensaje [`sensor_msgs/msg/Temperature`](https://docs.ros2.org/latest/api/sensor_msgs/msg/Temperature.html){target="_blank"}

<!-- ::: {.callout-tip}
Puede utilizar el comando `ros2 interface show <tipo_mensaje>` para ver la composici√≥n
::: -->

- Enviar un mensaje de log que muestre la temperatura generada (`info` o `debug`)
- Adem√°s agregar un par√°metro de configuraci√≥n de la frecuencia de publicaci√≥n en Hz (`publish_rate`)

|Nombre               | Tipo    | Descripci√≥n                   | Valor por defecto |
|:--------------------|:-------:|:----------------------------  |:-----------------:|
| `base_temperature`  | `float` | Temperatura inicial/base en grados Celsius | 25.0 |
| `max_variation`     | `float` | M√°xima variaci√≥n aleatoria                 | 5.0  |
| `publish_rate`      | `int`   | Frecuencia de publicaci√≥n en Hz            | 1    |

------

Para generar la temperatura puedes utilizar la funci√≥n `uniform` de la librer√≠a `random`

```.py
temperature = base_temperature + random.uniform(-max_variation, max_variation)
```
- `base_temperature`: valor base
- `max_variation`: cu√°nto puede subir o bajar como m√°ximo en cada medici√≥n
- `random.uniform(a, b)`: genera un n√∫mero flotante aleatorio entre `a` y `b`.


------

::: {.callout-note title="Opcional"}
Uno de los campos del mensaje de tipo `Temperature` es el `header`, que contiene un `stamp` de tipo `Time` y un `frame_id`, puedes completar dichos campos *opcionalmente*

Para obtener un `stamp` actual puedes utilizar el m√©todo `get_clock` de la clase `Node` de ROS:

```.py
msg.header.stamp = self.get_clock().now().to_msg()
msg.header.frame_id = 'sensor1'
```
:::


<!-- ```{.python filename="temperature_sensor.py" code-fold="true" code-line-numbers="true"}
import rclpy
from rclpy.node import Node

...

class <nombre_clase>(Node):
    __init__(self):
        super().__init__(<nombre_nodo>)
    ...
    def timer_callback(self):
        ...
        # Publicar el mensaje
        self.pub.publish(self.msg)

def main(args=None):
    # 1. Inicializaci√≥n
    rclpy.init(args=args)
    # 2. Creaci√≥n de nodo
    # nodo = ...
    # 3. Procesamiento de mensajes y callback
    rclpy.spin(nodo)
    # 4. Finalizaci√≥n 
    rclpy.shutdown()


if __name__ == '__main__':
    main()
``` -->

## Crear el nodo `temperature_monitor`

- Suscribe al topic `\temperature` y por cada mensaje verifica si la temperatura supera un umbral cr√≠tico configurable mediante un par√°metro `alarm_threshold`
- Agregar un par√°metro de configuraci√≥n `temperature_unit` que definir√° la unidad utilizada para el umbral y las alertas de temperatura

::: {.callout-tip title="Conversi√≥n ¬∞C a ¬∞F" appearance="simple"}
$$
T \, [¬∞F]  = T \, [¬∞C] \times 9/5 + 32
$$
:::

- Si supera el umbral imprime un mensaje de alarma con severidad `warn` y si no publicar la temperatura recibida con severidad `info` o `debug`

## Probar el sistema mediante `ros2 run`

- Ejecutar ambos nodos desde consola comprobando el funcionamiento de los valores por defecto de los par√°metros y el funcionamiento del sistema en su conjunto
- Probar distintas ejecuciones variando los par√°metros definidos y probar cambios de par√°metros durante la ejecuci√≥n, comprobando cuales tienen efecto inmediato y cuales requieren reinciar el nodo
- Comprobar el funcionamiento de los mensajes de log seg√∫n distintos niveles de severidad seteados para cada nodo


## Crear el archivo `launch` para ambos nodos

- Iniciar ambos nodos
    - `temperature_sensor` con una temperatura base de 27¬∞C y una variaci√≥n m√°xima de 5¬∞C, con una frecuencia de publicaci√≥n de 2Hz.
    - `temperature_monitor` con un umbral en 30¬∞C
- Declarar los argumentos necesarios para poder configurar los par√°metros establecidos en ambos nodos
- Ambos nodos deben enviar la salida por la consola con nivel de severidad `info`

## Probar el sistema mediante `ros2 launch`

- Ejecutar el archivo `launch`creado para verificar el funcionamiento de los par√°metros por defecto
- Probar distintas ejecuciones variando los par√°metros definidos
