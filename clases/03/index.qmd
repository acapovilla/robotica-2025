---
title: "Rob√≥tica"
subtitle: "Clase 03"
date: "04/07/2025"
date-format: "[Semana 4 -] DD/MM/YYYY"
institute: "FICH - UNL"
format:
    revealjs:
        theme: dark
        #chalkboard: true
        footer: Rob√≥tica - TUAR - FICH - UNL
        menu: false
        slide-number: c
        code-copy: false
        code-overflow: wrap
---

## Resumen Clase 02

:::: {.columns}
::: {.column width="60%"}
- ### ROS 2 - Jazzy
    - ### `Nodos`
    - ### `Topics`
    - ### `Mensajes`

:::

::: {.column width="40%"}
![](/clases/02/img/nodos-topics-msgs.svg){fig-align="center"}
:::
::::

::: {.notes}
Algunos comandos m√°s usados (run, node list, node info, topic list, topic info, topic echo, rqt_graph)
:::

## ROS2: Contexto y `namespaces` {.smaller}

:::: {.columns}
::: {.column width="50%"}
Similaridad a una estructura de carpetas

---

#### Tipos
- #### Global
- #### Relativo
- #### Base
- #### Privado
:::

::: {.column width="50%"}
```
/
‚îú‚îÄ‚îÄ sim1/
‚îÇ ‚îî‚îÄ‚îÄ robot/
‚îÇ     ‚îú‚îÄ‚îÄ cmd_vel       /sim1/robot/cmd_vel
‚îÇ     ‚îî‚îÄ‚îÄ odometry      /sim1/robot/odometry
‚îî‚îÄ‚îÄ sim2/
    ‚îî‚îÄ‚îÄ robot/
        ‚îú‚îÄ‚îÄ cmd_vel     /sim2/robot/cmd_vel
        ‚îî‚îÄ‚îÄ odometry    /sim2/robot/odometry

Base:       robot

Privado:    ~/cmd_vel
            ~/odometry
```
:::
::::

::: {.notes}
Explicaci√≥n de contexto: Estructura jer√°rquica de nombres utilizada en ROS para proveer encapsulamiento y as√≠ poder gestionar de una forma m√°s sencilla grandes sistemas.

Existen 4 tipos de nombres: base, relativo, global y privado.

La resoluci√≥n se realiza de forma relativa al namespace del nodo.

- Global -> empiezan con ‚Äú/‚Äù y se consideran resueltos
- Relativo -> no empiezan con ‚Äú/‚Äù y deben ser resueltos de forma relativa al namespace del nodo
- Base -> Es un subtipo de relativo: No llevan namespaces y generalmente se utilizan para inicializar el nombre del nodo
- Privado -> empiezan on ‚Äú~‚Äù y convierten el nodo en un ‚Äúnamespace‚Äù 
:::

## ROS2: Servicios

:::: {.columns}
::: {.column width="60%"}
> Modelo de llamada-respuesta

::: {.fragment}
> Bidireccional
:::
::: {.fragment}
> Solo proveen informaci√≥n cuando son invocados
:::
::: {.fragment}
> Comunicaci√≥n es 1 a N
:::

:::

::: {.column width="40%"}
![](/clases/03/img/servicios.svg){fig-align="center"}
:::
::::

::: {.notes}
Servicios (comunicaci√≥n)

- Basados en un modelo de ‚Äúllamada-respuesta‚Äù (call-and-response)
- La diferencia con Topics: no son continuos, solo proveen informaci√≥n cuando son invocados. 
- Muchos clientes pero solo un servidor.
- Bidireccional
- Definidos en archivos .srv
:::

## ROS2: Par√°metros
> Valores de configuraci√≥n para un nodo


::: {.fragment}
> Cada nodo posee sus propios par√°metros
:::
::: {.fragment}
::: {style="font-size: 70%;"}
- `int`
- `float`
- `bool`
- `string`
- `list[]`
:::
:::


## [Laboratorio (parte 1)](http://localhost:4200/clases/03/lab.html#parte-1-servicios-y-par%C3%A1metros) {.center}

- Invocar y analizar servicios

- Comandos para setear y obtener comandos

<!-- ## Organizaci√≥n de paquetes y c√≥digo {.center} -->

## Entorno de ROS y `workspace`

:::: {.columns}
::: {.column width="60%"}
#### Dos niveles:

  - `overlay` ‚û°Ô∏è _Nuestros_ paquetes
  - `underlay` ‚û°Ô∏è Paquetes instalados

::: {.fragment}
> `Workspace`
> 
> ```{code-line-numbers="|2"}
> üìÇ ros_ws
>   üìÅ src
>   üìÅ build      ‚ö†Ô∏è
>   üìÅ install    ‚ö†Ô∏è
>   üìÅ log        ‚ö†Ô∏è
> ```
:::
:::

::: {.column style="width: 40%; font-size: 50%;"}

<br>
<br>

+:-----------------------------------------------------------------:+
| Workspace de desarrollo<br>
| `. install/local_setup.bash`                                      
+-------------------------------------------------------------------+
| Paquete de ROS instalados<br>
| `source /opt/ros/jazzy/setup.bash`                               
+-------------------------------------------------------------------+

: {.stripped tbl-colwidths="[100]"}

:::
::::

::: {.notes}
Dos ‚Äúniveles‚Äù: Paquetes de ROS2 instalados (cuando se hace el source) ‚Äúunderlay‚Äù (tiene las dependencias del ‚Äúoverlay‚Äù), workspace de desarrollo donde se agregan paquetes nuevos ‚Äúoverlay‚Äù. Este √∫ltimo sobre-escribe paquetes del ‚Äúunderlay‚Äù.

workspace: Estructura de carpetas que contiene paquetes

- `src`: c√≥digo fuente: crear y editar el c√≥digo de los paquetes que se quieren compilar
- `build`: cach√© y archivos intermedios de compilaci√≥n
- `install`: los paquetes o ‚Äútargets‚Äù instalados
- `log`: Informaci√≥n de log
:::

## Paquete de ROS

:::: {.columns}
::: {.column style="width: 60%;"}

### Contiene

::: {.incremental}
- C√≥digo fuente
- Archivos de configuraci√≥n
- Archivos ‚Äúlaunch‚Äù
- Definici√≥n de mensajes, servicios, etc
- Metadatos e informaci√≥n
- Documentaci√≥n
:::
:::

::: {.column width="40%"}

> ```{code-line-numbers="|2"}
> üìÇ src
>   üìÅ nombre_paquete
>       üìÅ nombre_paquete
>           üìÑ __init__.py
>           ...
>       üìÅ resource
>           üìÑ nombre_paquete
>       üìÑ package.xml
>       üìÑ setup.cfg
>       üìÑ setup.py
> ```

:::
::::

::: {.notes}
Contenedor o marco del c√≥digo (contiene c√≥digo fuente, archivos launch, archivos de configuraci√≥n, definici√≥n de mensajes, datos y documentaci√≥n). Forma que permite instalar el propio c√≥digo y compartirlo.

Archivos m√≠nimos para paquetes Python (para cada paquete por separado)

- `package.xml`: informaci√≥n acerca del paquete (cual?)
- `setup.py` -> instrucciones para instalar el paquete
- `setup.cfg` -> Para que el comando run encuentra los ejecutables en el caso de que existan
- `/<nombre_paquete>` -> Carpeta con el mismo nombre del paquete junto con el archivo `__init__.py` utilizado por las herramientas de ROS2
:::


## Paquete de ROS: üìÑ package.xml {.smaller}

### Contiene

- Propiedades e informaci√≥n del paquete
- Formato `XML`


```{.xml code-line-numbers="|1,2,3|5,20|6,8|7|9-13|15|17-19"}
<?xml version="1.0"?>
<?xml-model href="http://download.ros.org/schema/package_format3.xsd"
    schematypens="http://www.w3.org/2001/XMLSchema"?>

<package format="3">
    <name>nombre_paquete</name>
    <version>0.0.0</version>
    <description>Descripci√≥n del paquete</description>
    <maintainer email="user@todo.todo">user</maintainer>
    <license>Licencia</license>

    <url type="website">https://github.com/...</url>
    <author email="user@todo.todo">user</author>

    <depend>nombre_paquete_dependencia</depend>

    <export>
        <build_type>ament_python</build_type>
    </export>
</package>
```

::: {.notes}
Propiedades e informaci√≥n del paquete: Nombre, versi√≥n, autores, dependencias, descripci√≥n, etc

Breve descripci√≥n de los archivos con codificaci√≥n eXtensible Markup Language:

- Lenguaje de marcado -> una forma de organizar la informaci√≥n utilizando etiquetas (para definir elementos) y atributos (para informaci√≥n adicional), de forma jer√°rquica.
- Es flexible y puede personalizarse -> √ötil para intercambiar informaci√≥n
- F√°cil de entender para humanos
:::

## Paquete de ROS: üìÑ setup.py {.smaller .scrollable}

### Contiene

- Instrucciones de c√≥mo se debe instalar el paquete (para el sistema de compilaci√≥n)
- Deben coincidir la informaci√≥n y los metadatos con los del `package.xml`


```{.py code-line-numbers="|3|6-9,21-24|11-17|26-30"}
from setuptools import setup

package_name = 'nombre_paquete'

setup(
  name=package_name,
  version='0.0.0',
  # Packages to export
  packages=[package_name],
  # Files we want to install, specifically launch files
  data_files=[
      # Install marker file in the package index
      ('share/ament_index/resource_index/packages',
             ['resource/' + package_name]),
      # Include our package.xml file
      ('share/' + package_name, ['package.xml']),
    ],
  # This is important as well
  install_requires=['setuptools'],
  zip_safe=True,
  maintainer='TODO',
  maintainer_email='TODO',
  description='TODO: Package description',
  license='TODO: License declaration',
  tests_require=['pytest'],
  entry_points={
      'console_scripts': [
              'nombre_nodo = nombre_paquete.nombre_nodo:main'
      ],
    },
)
```

::: {.notes}
Contenido: repite nombre, version, descripci√≥n, maintainer y licencia. Es necesario que sean iguales en los dos archivos 
:::

## Paquete de ROS: üìÑ setup.cfg {.smaller}

> Si el paquete posee un ejecutable, para que `ros2 run` lo pueda encontrar

```{.toml}
[develop]
script_dir=$base/lib/<nombre_paquete>

[install]
install_scripts=$base/lib/<nombre_paquete>
```

## `rclpy`: ROS Client Library (Python)

> Acceso a los componentes de ROS

::: {.incremental}
- Inicializaci√≥n y ejecuci√≥n de callbacks
- Gesti√≥n de nodos
- Topics, servicios, acciones, etc.
- Logs
:::

::: {.fragment}
```{.python}
import rclpy
```
:::

::: {.aside}
Documentaci√≥n completa en: [docs.ros2.org/latest/api/rclpy](https://docs.ros2.org/latest/api/rclpy/index.html)
:::

::: {.notes}
Acceso a los elementos de ROS desde la sintaxis de Python utilizando tipos nativos y patrones como listas. 

Componentes principales de la librer√≠a:-Inicializaci√≥n y ‚Äúspinning‚Äù. Gesti√≥n del nodo. Log. Subscriber/Publisher. Par√°metros.

(as√≠ como servicios, acciones y elementos de sincronizaci√≥n)
:::

<!-- ## `rclpy`: ROS Client Library (Python)

> Partes b√°sicas del programa

1. Inicializaci√≥n

2. Creaci√≥n de 1 o m√°s nodos

3. Procesamiento de callbacks (`spinning`)

4. Apagado (`shutdown`) -->

## `rclpy`: ROS Client Library (Python) {auto-animate="true"}

> Partes b√°sicas del programa

::: {.fragment}
1. Inicializaci√≥n

        rclpy.init(..)

> Antes que cualquier otra funci√≥n de ROS

> Define el contexto
:::

<!-- 2. Creaci√≥n de 1 o m√°s nodos

3. Procesamiento de callbacks (`spinning`)

4. Apagado (`shutdown`) -->

::: {.notes}
Inicializaci√≥n: Debe ser llamado antes de cualquier otra funci√≥n de ROS. Define el contexto.
:::

## `rclpy`: ROS Client Library (Python) {auto-animate="true"}

> Partes b√°sicas del programa

1. Inicializaci√≥n

        rclpy.init(..)

2. Creaci√≥n de 1 o m√°s nodos

        rclpy.create_node(..)

> Punto de acceso al sistema de ROS (topics, par√°metros, servicios, etc.)

> En POO ser√≠a a trav√©s de una instancia ‚Äònode‚Äô

::: {.notes}
Creaci√≥n del nodo: es el punto de acceso al sistema de ROS (topics, servicios, par√°metros, etc)

En el caso de utilizar clases (POO) ser√≠a a trav√©s de una instancia de ‚Äònode‚Äô.
:::

## `rclpy`: ROS Client Library (Python) {auto-animate="true"}

> Partes b√°sicas del programa

1. Inicializaci√≥n

        rclpy.init(..)

2. Creaci√≥n de 1 o m√°s nodos

        rclpy.create_node(..)

3. Procesamiento de callbacks (`spinning`)

        rclpy.spin(..)

> Se procesan los callbacks y dem√°s tareas del nodo

::: {.notes}
‚ÄúSpinning‚Äù: Procesar los callbacks y dem√°s rutinas
:::


## `rclpy`: ROS Client Library (Python) {auto-animate="true"}

> Partes b√°sicas del programa

1. Inicializaci√≥n

        rclpy.init(..)

2. Creaci√≥n de 1 o m√°s nodos

        rclpy.create_node(..)

3. Procesamiento de callbacks (`spinning`)

        rclpy.spin(..)

4. Apagado / finalizaci√≥n (`shutdown`)

        rclpy.shutdown()

::: {.notes}
Finalizaci√≥n: `rclpy.shutdown()`
:::

## `rclpy`: ROS Client Library (Python)

> Gesti√≥n de nodos

::: {.fragment}
- Crear un publisher: `node.create_publisher(..)`
:::
::: {.fragment}
- Crear un suscriber: `node.create_subscription(..)`
:::
::: {.fragment}
- Timer: `node.create_timer(..)`
:::
::: {.fragment}
- Log: `node.get_logger(..)`
:::

::: {.notes}
Manejo de nodos:

- Crear un publisher: Tipo de mensaje, nombre del topic
- Crear un subscriptor: Tipo de mensaje, nombre del topic, callback 
- Timer: Tareas repetitivas a una frecuencia deseada. Per√≠odo, callback
- Loggear:  Mensajes en consola
:::

## Compilaci√≥n del paquete

> Creaci√≥n de paquetes:

        ros2 pkg create --build-type ament_python <nombre_paquete>

> Herramienta de compilaci√≥n: `colcon`

	    colcon build [--symlink-install] [--packages-select <nombre_paquete>]

> Dependencias:
	    
        rosdep update

        rosdep install -i --from-path src --rosdistro jazzy -y

::: {.callout-warning title="Ejecutar en la ra√≠z del workspace"}
:::

## Callbacks {visibility="hidden"}

::: {.notes}
Explicaci√≥n de lo que es un callback: Porci√≥n de c√≥digo que es pasada como argumento, a otra parte de c√≥digo, que se espera sea ejecutado (call-back) en un momento conveniente. 
:::
