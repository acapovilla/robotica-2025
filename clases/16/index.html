<!DOCTYPE html>
<html lang="en"><head>
<script src="../../site_libs/quarto-html/tabby.min.js"></script>
<script src="../../site_libs/quarto-html/popper.min.js"></script>
<script src="../../site_libs/quarto-html/tippy.umd.min.js"></script>
<link href="../../site_libs/quarto-html/tippy.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/light-border.css" rel="stylesheet">
<link href="../../site_libs/quarto-html/quarto-syntax-highlighting-7b89279ff1a6dce999919e0e67d4d9ec.css" rel="stylesheet" id="quarto-text-highlighting-styles"><meta charset="utf-8">
  <meta name="generator" content="quarto-1.8.25">

  <title>Robótica 2025 – Robótica</title>
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/reset.css">
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/reveal.css">
  <style>
    code{white-space: pre-wrap;}
    span.smallcaps{font-variant: small-caps;}
    div.columns{display: flex; gap: min(4vw, 1.5em);}
    div.column{flex: auto; overflow-x: auto;}
    div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
    ul.task-list{list-style: none;}
    ul.task-list li input[type="checkbox"] {
      width: 0.8em;
      margin: 0 0.8em 0.2em -1em; /* quarto-specific, see https://github.com/quarto-dev/quarto-cli/issues/4556 */ 
      vertical-align: middle;
    }
    /* CSS for citations */
    div.csl-bib-body { }
    div.csl-entry {
      clear: both;
      margin-bottom: 0em;
    }
    .hanging-indent div.csl-entry {
      margin-left:2em;
      text-indent:-2em;
    }
    div.csl-left-margin {
      min-width:2em;
      float:left;
    }
    div.csl-right-inline {
      margin-left:2em;
      padding-left:1em;
    }
    div.csl-indent {
      margin-left: 2em;
    }  </style>
  <link rel="stylesheet" href="../../site_libs/revealjs/dist/theme/quarto-bbddfaabaaccfd8a5ddbf403c6be5566.css">
  <link href="../../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-menu/menu.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/reveal-menu/quarto-menu.css" rel="stylesheet">
  <link href="../../site_libs/revealjs/plugin/quarto-support/footer.css" rel="stylesheet">
  <style type="text/css">
    .reveal div.sourceCode {
      margin: 0;
      overflow: auto;
    }
    .reveal div.hanging-indent {
      margin-left: 1em;
      text-indent: -1em;
    }
    .reveal .slide:not(.center) {
      height: 100%;
    }
    .reveal .slide.scrollable {
      overflow-y: auto;
    }
    .reveal .footnotes {
      height: 100%;
      overflow-y: auto;
    }
    .reveal .slide .absolute {
      position: absolute;
      display: block;
    }
    .reveal .footnotes ol {
      counter-reset: ol;
      list-style-type: none; 
      margin-left: 0;
    }
    .reveal .footnotes ol li:before {
      counter-increment: ol;
      content: counter(ol) ". "; 
    }
    .reveal .footnotes ol li > p:first-child {
      display: inline-block;
    }
    .reveal .slide ul,
    .reveal .slide ol {
      margin-bottom: 0.5em;
    }
    .reveal .slide ul li,
    .reveal .slide ol li {
      margin-top: 0.4em;
      margin-bottom: 0.2em;
    }
    .reveal .slide ul[role="tablist"] li {
      margin-bottom: 0;
    }
    .reveal .slide ul li > *:first-child,
    .reveal .slide ol li > *:first-child {
      margin-block-start: 0;
    }
    .reveal .slide ul li > *:last-child,
    .reveal .slide ol li > *:last-child {
      margin-block-end: 0;
    }
    .reveal .slide .columns:nth-child(3) {
      margin-block-start: 0.8em;
    }
    .reveal blockquote {
      box-shadow: none;
    }
    .reveal .tippy-content>* {
      margin-top: 0.2em;
      margin-bottom: 0.7em;
    }
    .reveal .tippy-content>*:last-child {
      margin-bottom: 0.2em;
    }
    .reveal .slide > img.stretch.quarto-figure-center,
    .reveal .slide > img.r-stretch.quarto-figure-center {
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-left,
    .reveal .slide > img.r-stretch.quarto-figure-left  {
      display: block;
      margin-left: 0;
      margin-right: auto; 
    }
    .reveal .slide > img.stretch.quarto-figure-right,
    .reveal .slide > img.r-stretch.quarto-figure-right  {
      display: block;
      margin-left: auto;
      margin-right: 0; 
    }
  </style>
</head>
<body class="quarto-light">
  <div class="reveal">
    <div class="slides">

<section id="title-slide" class="quarto-title-block center">
  <h1 class="title">Robótica</h1>
  <p class="subtitle">Clase 16</p>

<div class="quarto-title-authors">
</div>

  <p class="date">Semana 21 - 17/09/2025</p>
</section>
<section>

<section id="navegación-1" class="slide level2">
<h2>Navegación</h2>
<blockquote>
<p>Área más desafiante en robótica móvil</p>
</blockquote>
<div class="columns">
<div class="column">
<h4 id="pilares"><u>4 pilares</u></h4>
<ul>
<li>Percepción</li>
<li><mark>Localización</mark></li>
<li>Cognición</li>
<li>Control</li>
</ul>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/nav-gemini.png" class="quarto-figure quarto-figure-center" style="width:75.0%"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Dominio de cuatro pilares:</p>
<ul>
<li>Percepción (interpretar sus sensores para extraer información significativa)</li>
<li>Localización (el robot debe determinar su posición en el entorno)</li>
<li>Cognición (el robot debe decidir cómo actuar para lograr sus objetivos)</li>
<li>Control de movimiento (el robot debe controlar la respuesta de sus motores para lograr la trayectoria deseada)</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>

<section id="localización-1" class="slide level2 smaller">
<h2>Localización</h2>
<blockquote>
<p>Responder a la pregunta: <u>¿Dónde está el robot ahora?</u></p>
</blockquote>
<p><br></p>
<div class="callout callout-tip callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Si se pudiera conectar un GPS preciso a un robot móvil todo el tiempo se solucionaría gran parte del problema</p>
</div>
</div>
</div>
<div class="fragment">
<div class="columns">
<div class="column" style="width:45%;">
<h4 id="realidad">Realidad</h4>
<ul>
<li>Precisión inaceptable para robots móviles a escala humana</li>
<li>No funciona en interiores ni áreas obstruidas (ej, calles rodeadas por edificios altos)</li>
<li>Posición respecto al planeta Tierra</li>
</ul>
</div><div class="column" style="width:55%;">
<div class="quarto-figure quarto-figure-center">
<figure>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><a href="https://www.u-blox.com/en/blogs/tech/reducing-rf-interference-gnss-performance" target="_blank"><img data-src="https://content.u-blox.com/sites/default/files/2022-09/RF%20interference.jpg" title="Position accuracy factors" class="quarto-figure quarto-figure-center" style="width:75.0%" data-fig-env="figure*"></a></p>
</figure>
</div>
<figcaption>Fuente: U-blox (<a href="https://www.u-blox.com" target="_blank">www.u-blox.com</a>)</figcaption>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Un GPS preciso en un robot solucionaría gran parte del problema de localización. El GPS informaría al robot de su posición exacta, en interiores y exteriores, y la respuesta a la pregunta “¿Dónde estoy?” siempre estaría disponible de inmediato.</p>
<p>Desafortunadamente, un sensor de este tipo no es práctico. La red GPS proporciona una precisión inaceptable para localizar robots móviles a escala humana (utilizando módulos convencionales). Además, las tecnologías GPS no funciona en interiores ni en áreas obstruidas (ej, calles rodeadeas por edificios altos) y, por lo tanto, su área de trabajo está limitada.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</div>
</section>
<section id="localización-2" class="slide level2 smaller">
<h2>Localización</h2>
<div class="columns">
<div class="column">
<blockquote>
<p>Más problemas</p>
</blockquote>
<h4 id="un-robot-que-interactúa-con-humanos">Un robot que interactúa con humanos</h4>
<ul>
<li>Su posición relativa con respecto al objetivo es igualmente importante que su posición absoluta</li>
<li>Identificación de obstáculos dinámicos y estáticos: construir un mapa e identificar la posición en relación al mismo</li>
</ul>
<div class="fragment">
<h4 id="tipos-de-posicionamiento">2 tipos de posicionamiento</h4>
<ul>
<li>Absolutos</li>
<li>Relativos</li>
</ul>
</div>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/humanoid.gif" style="width:60.0%"></p>
<figcaption>Extraído de <a href="https://www.youtube.com/watch?v=0SeTapE9WIA" target="_blank">YouTube</a></figcaption>
</figure>
</div>
</div></div>
<aside class="notes">
<p>La localización implica más que conocer la posición absoluta en el sistema de referencia terrestre.</p>
<p>Consideremos un robot que interactúa con humanos. Su posición relativa con respecto a los humanos objetivo es igualmente importante que su posición absoluta. Su tarea de localización puede incluir identificar humanos mediante su conjunto de sensores y luego calcular su posición relativa.</p>
<p>Además, durante la etapa de cognición, un robot seleccionará una estrategia para lograr sus objetivos. Si pretende llegar a una ubicación específica, la localización puede no ser suficiente. El robot puede necesitar adquirir o construir un modelo ambiental, un mapa, que le ayude a planificar una ruta hacia el objetivo. Una vez más, la localización significa más que simplemente determinar una posición absoluta en el espacio; significa construir un mapa y luego identificar la posición del robot en relación con ese mapa.</p>
<p>Claramente, los sensores y efectores del robot desempeñan un papel integral en todas las formas de localización mencionadas. Debido a la inexactitud e incompletitud de estos sensores y efectores, la localización plantea grandes desafíos.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>

<section id="métodos-absolutos" class="slide level2 smaller">
<h2>Métodos absolutos</h2>
<div class="columns">
<div class="column">
<blockquote>
<p>Basados en referencias y sensores exteroceptivos</p>
</blockquote>
<p><u>Ejemplos</u>:</p>
<ol type="1">
<li>Brújulas magnéticas</li>
<li>Balizas (<em>beacons</em>) de navegación</li>
<li>Sistema de posicionamiento global (<em>GPS</em>)</li>
<li>Puntos de referencias (activos o pasivos)</li>
<li>Otros..</li>
</ol>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/robot-localization-mark.png"></p>
<figcaption>Frese, U., &amp; Wagner, R. &amp; Röfer, T. A SLAM overview from a users perspective. Künstl Intell 24, 191-198 (2010). <a href="https://doi.org/10.1007/s13218-010-0040-4" target="_blank">10.1007/s13218-010-0040-4</a>.</figcaption>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Cada uno de estos enfoques puede implementarse mediante diversos métodos y sensores</p>
<p>Sin embargo, ninguno de los sistemas existentes es especialmente elegante.</p>
<p>Los beacons y los puntos de referencia suelen requerir instalaciones y mantenimiento costosos, mientras que la navegación por satélite (GPS) suelen ser más lentos que la odometría y solo puede utilizarse en exteriores.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="métodos-relativos" class="slide level2 smaller">
<h2>Métodos relativos</h2>
<blockquote>
<p>Por lo general basado en sensores propioceptivos</p>
</blockquote>
<ul>
<li>Se determina <span style="color: #1f77b4;">la ubicación actual</span> <span style="color: #ff7f0e;">“avanzando”</span> desde <span style="color: #d62728;">una posición previa</span>, con la <span style="color: #7f7f7f;">información de velocidad</span> en un cierto <span style="color: #2ca02c;">período de tiempo</span>, hacia <span style="color: #9467bd;">una dirección conocida</span></li>
</ul>
<p><span class="math display">\[
\require{color}
\textcolor{#1f77b4}{\boldsymbol{p}_k} = \textcolor{#d62728}{\boldsymbol{p}_{k-1}} \textcolor{#ff7f0e}{+} \textcolor{#7f7f7f}{{\boldsymbol{\stackrel{\cdot}{p}}_k}} \cdot \textcolor{#9467bd}{\vec{\boldsymbol{\theta}}} \cdot \textcolor{#2ca02c}{\Delta t}
\]</span></p>
<ul>
<li><h4 id="también-conocidos-como-dead-reckoning">También conocidos como <em>dead-reckoning</em></h4></li>
</ul>
<p><u>Ejemplos</u>:</p>
<ol type="1">
<li>Navegación inercial</li>
<li>Odometría</li>
</ol>
<aside class="notes">
<p><em>dead-reckoning</em>: Procedimiento matemático para determinar la ubicación actual “avanzando” desde una posición previa a través de un curso conocido con la información de velocidad en un cierto período de tiempo</p>
<p>Otro enfoque se basa en la navegación inercial con giroscopos y/o acelerómetros. Los datos del acelerómetro deben integrarse dos veces para obtener la posición, lo que hace que estos sensores sean extremadamente sensibles al “bias” o deriva.</p>
<p>Otro problema es que las aceleraciones en condiciones de funcionamiento típicas pueden ser muy pequeñas, del orden de 0,01 g. Sin embargo, ya se producen fluctuaciones de esta magnitud si el sensor se inclina tan solo 0,5° respecto del plano horizontal (por ejemplo, cuando el vehículo circula sobre superficies irregulares)</p>
<p>Los giroscopios pueden ser más precisos, pero solo proporcionan información sobre la velocidad de rotación del vehículo (sus datos deben integrarse una sola vez)</p>
<p>Este problema no existe con las brújulas electrónicas (o magnetómetros) que miden la orientación del robot respecto al campo magnético terrestre. Sin embargo, no se recomiendan para aplicaciones en interiores debido a las grandes distorsiones del campo magnético terrestre cerca de líneas eléctricas o estructuras de acero.</p>
<p>La odometría es el método más utilizado para determinar la posición en robótica móvil. Es sencilla, económica y fácil de implementar en tiempo real.</p>
<p>Proporciona información de posicionamiento en tiempo real y de fácil acceso entre mediciones periódicas de posición absoluta. La frecuencia con la que deben realizarse las mediciones absolutas (generalmente costosas y/o laboriosas) depende en gran medida de la precisión del sistema de odometría.</p>
<p>La GRAN desventaja de la odometría es su acumulación de error ilimitado (no acotado).</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>

<section id="odometría-1" class="slide level2 smaller">
<h2>Odometría</h2>
<ul>
<li>El método más utilizado y económico</li>
<li>Buena precisión a corto plazo y alta frecuencia de muestreo</li>
<li>Implementación más común a través de encoders ópticos acoplados a los ejes de las ruedas</li>
<li>Para calcular la distancia incremental de ambas ruedas en el intervalo <span class="math inline">\(i\)</span>:</li>
</ul>
<p><span class="math display">\[
\Delta s_{L|R,i} = \pi \cdot D_{L|R} \cdot \frac{N_{L|R, i}}{c_e}
\]</span></p>
<p>donde:</p>
<ul>
<li><span class="math inline">\(D_{L|R}\)</span>: Diámetro de la rueda (en [mm])</li>
<li><span class="math inline">\(N_{L|R, i}\)</span>: incremento de pulsos del encoder en el intervalo</li>
<li><span class="math inline">\(c_e\)</span>: Resolución del encoder (en [pulsos por revolución])</li>
</ul>
<aside class="notes">
<p>Es el método de navegación más utilizado para el posicionamiento de robots móviles. Es bien sabido que proporciona una buena precisión a corto plazo, es económica y permite frecuencias de muestreo muy altas. Sin embargo la acumulación de errores es inevitable.</p>
<p>La precisión de las mediciones de odometría para dead-reckoning es una acción directa del diseño cinemático de un vehículo. Se debe considerar detenidamente el diseño cinemático antes de intentar mejorar la precisión de la navegación a estima.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="repaso-odometría" class="slide level2 smaller">
<h2>Repaso odometría</h2>
<blockquote>
<p>Calculo del desplazamiento desde una posición inicial mediante la medición de las revoluciones de las ruedas</p>
</blockquote>
<ul>
<li><p>Sea la posición en el instante <span class="math inline">\(k-1\)</span>: <span class="math display">\[
p_{k-1} = \begin{bmatrix} x &amp; y &amp; \theta \end{bmatrix}^\top
\]</span></p></li>
<li><p>La posición estimada para el instante <span class="math inline">\(k\)</span> puede obtenerse sumando las distancias recorridas de forma incremental:</p></li>
</ul>
<p><span class="math display">\[
p_{k} = p_{k-1} + \Delta p
\]</span></p>
<aside class="notes">
<p>El posicionamiento relativo suele basarse en la odometría (medición de las revoluciones de las ruedas para calcular el desplazamiento desde una posición inicial conocida).</p>
<p>La odometría calcula el desplazamiento horizontal relativo del robot y el cambio de orientación en función del desplazamiento horizontal incremental de las ruedas motrices.</p>
<p>La odometría se basa en ecuaciones sencillas de fácil implementación que utilizan datos de encoders incrementales de rueda económicos.</p>
<p>Sin embargo, parte de la suposición de que las revoluciones de la rueda pueden traducirse en un desplazamiento lineal con respecto al suelo. Esta suposición tiene una validez limitada. Un ejemplo extremo es el deslizamiento de una rueda: si una rueda patinara, por ejemplo, en un lugar con aceite, el encoder asociado a la rueda registraría las revoluciones aunque estas no correspondieran a un desplazamiento lineal.</p>
<p>Además de este caso extremo de deslizamiento total, existen otras razones más sutiles que explican las imprecisiones en la traducción de las lecturas del encoder de rueda a movimiento lineal.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="repaso-odometría-1" class="slide level2">
<h2>Repaso odometría</h2>
<div style="font-size:70%;">
<ul>
<li>Para un robot <em>differential-drive</em>, con un período de muestreo fijo <span class="math inline">\(\Delta t\)</span>:</li>
</ul>
<p><span class="math display">\[
\Delta p =
\begin{bmatrix} \Delta x \\ \Delta y \\ \Delta\theta \end{bmatrix} =
\begin{bmatrix}
\Delta s \cos(\theta + \frac{\Delta\theta}{2})\\
\Delta s \sin(\theta + \frac{\Delta\theta}{2})\\
\frac{\Delta s_{R} - \Delta s_{L}}{b}
\end{bmatrix}
\]</span></p>
<p>donde:</p>
<ul>
<li><span class="math inline">\(\Delta x, \Delta y, \Delta\theta\)</span>: el avance en el último período</li>
<li><span class="math inline">\(\Delta s_{L|R}\)</span>: la distancia recorrida por la rueda izquierda y derecha respectivamente</li>
<li><span class="math inline">\(\Delta s = (\Delta s_{L} + \Delta s_{R}) / 2\)</span></li>
<li><span class="math inline">\(b\)</span>: la distancia entre ruedas</li>
</ul>
</div>
</section>
<section id="repaso-odometría-2" class="slide level2">
<h2>Repaso odometría</h2>
<div style="font-size:70%;">
<ul>
<li>Utilizando las definiciones de <span class="math inline">\(\Delta s\)</span> y <span class="math inline">\(\Delta\theta\)</span> se obtiene la ecuación para la actualización de la posición</li>
</ul>
<p><span class="math display">\[\begin{align*}p_k &amp;= p_{k-1} + \Delta p\\ &amp;= \left[\begin{matrix}x\\y\\\theta\end{matrix}\right] + \left[\begin{matrix}\left(\frac{\Delta s_{L}}{2} + \frac{\Delta s_{R}}{2}\right) \cos{\left(\theta + \frac{- \Delta s_{L} + \Delta s_{R}}{2 b} \right)}\\\left(\frac{\Delta s_{L}}{2} + \frac{\Delta s_{R}}{2}\right) \sin{\left(\theta + \frac{- \Delta s_{L} + \Delta s_{R}}{2 b} \right)}\\\frac{- \Delta s_{L} + \Delta s_{R}}{b}\end{matrix}\right]\end{align*}\]</span></p>
<div class="hidden">
<p><span class="math display">\[
\def\f{{\boldsymbol{f}}}
\]</span></p>
</div>
<ul>
<li>De forma reducida:</li>
</ul>
<p><span class="math display">\[
p_{k} = \f \left( x, \  y, \  \theta, \  \Delta s_{L}, \  \Delta s_{R}, \  b\right)
\]</span></p>
</div>
</section></section>
<section>

<section id="modelo-de-error-de-odometría-1" class="slide level2 smaller">
<h2>Modelo de error de odometría</h2>
<ul>
<li>Para el movimiento incremental <span class="math inline">\(\Delta s_L\)</span> y <span class="math inline">\(\Delta s_R\)</span> se asume una matriz de covarianza <span class="math inline">\(\Sigma_\Delta\)</span>:</li>
</ul>
<p><span class="math display">\[
\Sigma_\Delta = \mathcal{covar}(\Delta s_L, \Delta s_R) = \begin{bmatrix}
k_L |\Delta s_L|  &amp; 0\\
               0  &amp; k_R |\Delta s_R|
\end{bmatrix}
\]</span></p>
<ol type="1">
<li>Los errores de las ruedas motrices son independientes</li>
<li>La varianza de los errores es proporcional al valor absoluto de la distancia recorrida</li>
<li><span class="math inline">\(k_L\)</span> y <span class="math inline">\(k_R\)</span> son coeficientes de error constantes</li>
</ol>
<aside class="notes">
<p>Las actualizaciones de la posición odométrica solo pueden proporcionar una estimación muy aproximada de la posición real</p>
<p>Debido a los errores de integración de las incertidumbres de p y a los errores de movimiento durante el movimiento incremental, el error de posición basado en la integración odométrica aumenta con el tiempo</p>
<p>Se establecerá un modelo de error para la posición integrada <span class="math inline">\(p_{k}\)</span> con el fin de obtener la matriz de covarianza <span class="math inline">\(\Sigma p_{k}\)</span> de la estimación de la posición odométrica.</p>
<p>Se asume:</p>
<ul>
<li>En el punto de partida se conoce la matriz de covarianza inicial <span class="math inline">\(\Sigma p_{k-1}\)</span></li>
<li><span class="math inline">\(k_R\)</span>, <span class="math inline">\(k_L\)</span> son constantes de error que representan los parámetros no deterministas del accionamiento del motor y la interacción de la rueda y el suelo</li>
<li>Los dos errores de las ruedas motrices individuales son independientes</li>
<li>La varianza de los errores (ruedas izquierda y derecha) es proporcional al valor absoluto de las distancias recorridas</li>
</ul>
<p>Estas suposiciones no son perfectas, pero simplifican el desarrollo del modelo de error</p>
<p>Los errores de movimiento se deben a movimientos imprecisos debido a la deformación de la rueda, deslizamiento, suelo irregular, errores en los codificadores, etc. Los valores de las constantes de error <span class="math inline">\(k_L\)</span> y <span class="math inline">\(k_R\)</span> dependen del robot y del entorno, y deben determinarse experimentalmente mediante la realización y el análisis de movimientos representativos.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="modelo-de-error-de-odometría-2" class="slide level2 smaller">
<h2>Modelo de error de odometría</h2>
<ul>
<li>Suponiendo que <span class="math inline">\(p_{k-1}\)</span> y <span class="math inline">\(\Delta_{L,R} = \begin{bmatrix} \Delta s_L &amp; \Delta s_R \end{bmatrix}\)</span> no están correlacionados y <span class="math inline">\(\boldsymbol{f}\)</span> se puede aproximar mediante la expansión de <em>Taylor</em> de primer orden:</li>
</ul>
<p><span class="math display">\[
\Sigma_{p_k} = \nabla_p \f \cdot \Sigma_{p_{k-1}} \cdot \nabla_p \f^\top + \nabla_{\Delta_{L,R}} \f \cdot \Sigma_\Delta \cdot \nabla_{\Delta_{L,R}} \f^\top
\]</span></p>
<p>donde <span class="math inline">\(\Sigma_{p_{k-1}}\)</span> está dado por el paso anterior, y puede calcularse a partir de un valor incial (generalmente <span class="math inline">\(\Sigma_{p_0} = \mathbb{0}\)</span>)</p>
<ul>
<li>Utilizando la definción de <span class="math inline">\(p_{k} = \f(\cdot)\)</span> es posible obtener los <em>Jacobianos</em>:</li>
</ul>
<p><span class="math display">\[
F_p = \nabla_p \f \\
F_{\Delta_{L,R}} = \nabla_{\Delta_{L,R}} \f
\]</span></p>
<aside class="notes">
<p>Si suponemos que <span class="math inline">\(p_{k-1}\)</span> y <span class="math inline">\(\Delta_{L,R} = \begin{bmatrix} \Delta s_L &amp; \Delta s_R \end{bmatrix})\)</span> no están correlacionados y la derivada de <span class="math inline">\(f\)</span> se puede aproximar mediante la expansión de Taylor de primer orden</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="modelo-de-error-de-odometría-3" class="slide level2">
<h2>Modelo de error de odometría</h2>
<div style="font-size:70%;">
<ul>
<li>El <em>Jacobiano</em> de <span class="math inline">\(\f\)</span> con respecto al vector de posición <span class="math inline">\(p = \begin{bmatrix}x &amp; y &amp; \theta \end{bmatrix}\)</span>:</li>
</ul>
<p><span class="math display">\[
F_p = \nabla_p \f = \nabla_p (\f^\top) = \begin{bmatrix} \frac{\partial \f}{\partial x} &amp; \frac{\partial \f}{\partial y} &amp; \frac{\partial \f}{\partial \theta} \end{bmatrix}
\]</span></p>
<ul>
<li>Que resulta en:</li>
</ul>
<div id="eq-f_definition">
<p><span class="math display">\[F_p = \left[\begin{matrix}1 &amp; 0 &amp; - \Delta s \sin{\left(\frac{\Delta\theta}{2} + \theta \right)}\\0 &amp; 1 &amp; \Delta s \cos{\left(\frac{\Delta\theta}{2} + \theta \right)}\\0 &amp; 0 &amp; 1\end{matrix}\right]\]</span></p>
</div>
</div>
</section>
<section id="modelo-de-error-de-odometría-4" class="slide level2">
<h2>Modelo de error de odometría</h2>
<div style="font-size:70%;">
<ul>
<li>El <em>Jacobiano</em> de <span class="math inline">\(\f\)</span> con respecto al desplazamiento de las ruedas <span class="math inline">\(\Delta_{L,R} = \begin{bmatrix} \Delta s_L &amp; \Delta s_R \end{bmatrix}\)</span>:</li>
</ul>
<p><span class="math display">\[
F_{\Delta_{L,R}} = \nabla_{\Delta_{L,R}} \f = \begin{bmatrix} \frac{\partial \f}{\partial \Delta s_L} &amp; \frac{\partial \f}{\partial \Delta s_R} \end{bmatrix}
\]</span></p>
<ul>
<li>Que resulta en:</li>
</ul>
<p><span class="math display">\[F_{\Delta_{L,R}} = \left[\begin{matrix}\frac{\Delta s \sin{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2 b} + \frac{\cos{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2} &amp; - \frac{\Delta s \sin{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2 b} + \frac{\cos{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2}\\- \frac{\Delta s \cos{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2 b} + \frac{\sin{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2} &amp; \frac{\Delta s \cos{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2 b} + \frac{\sin{\left(\frac{\Delta\theta}{2} + \theta \right)}}{2}\\- \frac{1}{b} &amp; \frac{1}{b}\end{matrix}\right]\]</span></p>
</div>
</section>
<section id="modelo-de-error-de-odometría-5" class="slide level2 smaller">
<h2>Modelo de error de odometría</h2>
<ul>
<li>Dados los parámetros de error <span class="math inline">\(k_L\)</span> y <span class="math inline">\(k_R\)</span>, se puede ver la evolución del error de posición</li>
</ul>
<div id="23f19909" class="cell quarto-layout-panel" data-execution_count="5" data-fig-format="svg" data-layout-ncol="2">
<div class="quarto-layout-row">
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="index_files/figure-revealjs/cell-6-output-1.svg"></p>
<figcaption>* La incertidumbre en <span class="math inline">\(y\)</span> crece mucho más rápido que en la dirección del movimiento</figcaption>
</figure>
</div>
</div>
<div class="quarto-layout-cell" style="flex-basis: 50.0%;justify-content: flex-start;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="index_files/figure-revealjs/cell-6-output-2.svg"></p>
<figcaption>* El eje principal de la elipse no permanece perpendicular a la dirección del movimiento</figcaption>
</figure>
</div>
</div>
</div>
</div>
<aside class="notes">
<p>Las FIGURAS muestran ejemplos típicos de cómo aumentan los errores de posición con el tiempo</p>
<p>Crecimiento de la incertidumbre de la postura para el movimiento en línea recta: Nótese que la incertidumbre en y crece mucho más rápido que en la dirección del movimiento. Esto se debe a la integración de la incertidumbre sobre la orientación del robot</p>
<p>Crecimiento de la incertidumbre de la pose para el movimiento circular (r = constante): Nuevamente, la incertidumbre perpendicular al movimiento crece mucho más rápido que la de la dirección del movimiento. Nótese que el eje principal de la elipse de incertidumbre no permanece perpendicular a la dirección del movimiento.</p>
<p>Los errores deterministas se pueden compensar calibrando correctamente el robot. Sin embargo, los parámetros de error que especifican los errores no deterministas solo se pueden cuantificar mediante mediciones estadísticas (repetitivas)</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>

<section id="fuentes-de-error-1" class="slide level2 smaller">
<h2>Fuentes de error</h2>
<blockquote>
<p>La verdadera fuente de error generalmente se produce por un modelo incompleto del entorno</p>
</blockquote>
<ul>
<li><h4 id="errores-sistemáticos">Errores sistemáticos</h4></li>
<li><h4 id="errores-aleatorios-o-no-sistemáticos">Errores aleatorios (o <u>no</u> sistemáticos)</h4></li>
</ul>
<aside class="notes">
<p>Todas estas fuentes de error se clasifican en dos categorías: (1) errores sistemáticos y (2) errores no sistemáticos.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="errores-no-sistemáticos" class="slide level2 smaller">
<h2>Errores <u>no</u> sistemáticos</h2>
<blockquote>
<p>Causados ​​por la interacción del robot con características impredecibles del entorno (aleatorios)</p>
</blockquote>
<ul>
<li>Desplazamiento sobre superficies irregulares u objetos inesperados</li>
<li>Deslizamientos:
<ul>
<li>Suelo con baja adherencia</li>
<li>Giro rápido (derrape)</li>
<li>Fuerzas externas (interacción con cuerpos externos)</li>
<li>Fuerzas internas (ruedas libres, patines, etc)</li>
</ul></li>
<li>Contacto <strong>no</strong> puntual de las ruedas y el suelo</li>
</ul>
<aside class="notes">
<ul>
<li>Por ejemplo, las irregularidades de la superficie del suelo, como baches, grietas o residuos, harán que una rueda gire más de lo previsto.</li>
<li>En superficies rugosas con irregularidades significativas, son predominantes los errores no sistemáticos</li>
<li>Los errores no sistemáticos representan un gran problema para las aplicaciones reales, mediante el uso de encoders redundantes, los errores no sistemáticos pueden reducirse</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="errores-sistemáticos-1" class="slide level2 smaller">
<h2>Errores sistemáticos</h2>
<blockquote>
<p>Suelen deberse a imperfecciones en la construcción de un robot móvil (deterministas)</p>
</blockquote>
<ul>
<li>Ruedas no alineadas o diámetro desiguales</li>
<li>El promedio de los diámetros difiere del nominal</li>
<li>Variación en el punto de contacto de la rueda</li>
<li>Resolución y frecuencia de muestro de encoder limitada</li>
<li>Por el propio modelo de odometría</li>
</ul>
<aside class="notes">
<p>Incerteza en la separación de las ruedas (dado que el punto de contacto de la rueda con el suelo no es “un punto”)</p>
<p>Se pueden introducir errores de odometría adicionales mediante las propias ecuaciones de odometría, ya que aproximan el movimiento arbitrario como una serie de segmentos rectos cortos. La precisión de esta aproximación depende de la frecuencia de muestreo con respecto a la velocidad del robot. Sin embargo, en nuestra experiencia práctica, este error es insignificante al trabajar con tiempos de muestreo típicos de Ts &lt; 10 ms y velocidades típicas de V &lt; 1 m/s.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="errores-sistemáticos-2" class="slide level2 smaller">
<h2>Errores sistemáticos</h2>
<blockquote>
<p>No suelen cambiar durante la operación</p>
</blockquote>
<ul>
<li>Puede mejorarse la odometría midiendo las fuentes de error más predominantes y contrarrestando su efecto mediante software</li>
</ul>
<p><br></p>
<ul>
<li><h4 id="fuentes-de-error-más-comunes">2 fuentes de error más comunes:</h4>
<ul>
<li>Diámetro desiguales de las ruedas <span class="math display">\[D_L \neq D_R\]</span></li>
<li>Incerteza en la distancia entre las ruedas <span class="math display">\[b?\]</span></li>
</ul></li>
</ul>
<aside class="notes">
<p>Los errores sistemáticos son específicos del vehículo y no suelen cambiar durante la operación (aunque diferentes distribuciones de carga pueden modificar cuantitativamente algunos errores sistemáticos). Por lo tanto, la odometría puede mejorarse en significativamente midiendo la contribución individual de las fuentes de error más predominantes y contrarrestando su efecto en el software.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="incerteza-en-la-distancia-entre-ruedas" class="slide level2 smaller">
<h2>Incerteza en la distancia entre ruedas</h2>
<blockquote>

<ul>
<li>Las ruedas de goma no entran en contacto con el suelo en un punto, sino en una zona de contacto</li>
</ul>

</blockquote>
<h4 id="denominamos-este-error-tipo-a-asociado-al-coeficiente-e_b">Denominamos este error <u>Tipo A</u> asociado al coeficiente <span class="math inline">\(E_b\)</span>:</h4>
<p><span class="math display">\[
E_b = \frac{b_{\textrm{actual}}}{b_{\textrm{nominal}}}
\]</span></p>
<p>donde <span class="math inline">\(b\)</span> es la distancia entre ruedas</p>
<aside class="notes">
<ul>
<li>El Tipo A se define como un error de orientación que reduce (o aumenta) la rotación total del robot tanto en sentido horario como antihorario.</li>
<li>La distancia entre ejes se define como la distancia entre los puntos de contacto de las dos ruedas motrices y el suelo.</li>
<li>Es necesario conocer la distancia entre ejes para calcular el número de pulsos del codificador diferencial correspondientes a una determinada rotación del vehículo. La incertidumbre se debe a que las ruedas (por lo general de goma) no entran en contacto con el suelo en un punto, sino en una zona de contacto.</li>
<li>La incertidumbre resultante puede ser del orden del 1%</li>
</ul>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="diámetro-desiguales" class="slide level2 smaller">
<h2>Diámetro desiguales</h2>
<blockquote>

<ul>
<li>No se fabrican 2 ruedas exactamente iguales</li>
<li>Ruedas de goma se comprimen</li>
</ul>

</blockquote>
<h4 id="denominamos-este-error-tipo-b-asociado-al-coeficiente-e_d">Denominamos este error <u>Tipo B</u> asociado al coeficiente <span class="math inline">\(E_d\)</span>:</h4>
<p><span class="math display">\[
E_d = \frac{D_R}{D_L}
\]</span></p>
<p>donde <span class="math inline">\(D_{L|R}\)</span> es el diámetro de las ruedas izquierda y derecha respectivamente</p>
<p><br></p>
<ul>
<li><p><span class="math inline">\(E_d\)</span> y <span class="math inline">\(E_b\)</span> son valores adimensionales, expresados ​​como fracciones del valor nominal</p></li>
<li><p><span class="math inline">\(E_b\)</span> solo afecta al girar y <span class="math inline">\(E_d\)</span> solo afecta al movimiento en línea recta</p></li>
</ul>
<aside class="notes">
<p>El Tipo B se define como un error de orientación que reduce (o aumenta) la rotación total en una dirección, pero la aumenta (o reduce) en la otra</p>
<p>La mayoría de los robots móviles utilizan ruedas de goma difíciles de fabricar con el mismo diámetro. Además, el material elástico se comprimen de forma diferente bajo una distribución asimétrica de la carga. Cualquiera de estos efectos puede causar errores odométricos considerables.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="errores-de-escala" class="slide level2 smaller">
<h2>Errores de escala</h2>
<ul>
<li><p>Si el <u>promedio</u> de los dos diámetros reales <span class="math inline">\(D_a\)</span> difiere del diámetro nominal <span class="math inline">\(D_n\)</span> el vehículo experimentará un error odométrico adicional, denominado error de escala <span class="math inline">\(E_s\)</span></p></li>
<li><p>También conocidos como errores de alcance</p></li>
<li><p><span class="math inline">\(E_s\)</span> afecta el movimiento en <u>línea recta</u> y el movimiento de <u>giro puro</u></p></li>
<li><p>Para largos períodos de tiempo, los errores de <strong>Tipo A</strong> y <strong>Tipo B</strong> superan los errores de escala</p></li>
<li><p><span class="math inline">\(E_s\)</span> es fácil de medir y corregir con una regla o cinta métrica</p></li>
</ul>
<aside class="notes">
<p>Si el promedio de los dos diámetros reales de las ruedas, <span class="math inline">\(D_a\)</span>, difiere del diámetro nominal de las ruedas, <span class="math inline">\(D_n\)</span>, el vehículo experimentará un error odométrico adicional, denominado error de escala <span class="math inline">\(E_s\)</span>. <span class="math inline">\(E_s\)</span> afecta el movimiento en línea recta y el movimiento de giro puro. No obstante, aunque <span class="math inline">\(E_s\)</span> puede ser un error significativo, es extremadamente fácil de medir. Por esta razón, asumiremos que <span class="math inline">\(E_s\)</span> se ha medido y corregido antes de realizar cualquiera de los procedimientos descritos a continuación.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>

<section id="trayectoria-cuadrada-unidireccional-1" class="slide level2 smaller">
<h2>Trayectoria cuadrada unidireccional</h2>
<div class="columns">
<div class="column">
<blockquote>
<p>Se compone de 4 segmentos en línea rcta y 4 rotaciones <strong>puras</strong> en las esquinas</p>
</blockquote>
<ul>
<li>El robot parte de la posición <span class="math inline">\((x_0, y_0)\)</span>, y angulo <span class="math inline">\(\theta_0\)</span></li>
<li>La posición final muestra el error de odometría</li>
</ul>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura1.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>La FIGURA muestra una trayectoria unidireccional cuadrada de <span class="math inline">\(4 \mathrm{[m]}\)</span> de lado. El robot parte de la posición <span class="math inline">\(x_0\)</span>, <span class="math inline">\(y_0\)</span>, <span class="math inline">\(\theta_0\)</span>. El área de inicio debe ubicarse cerca de la esquina de dos paredes perpendiculares. Las paredes sirven como referencia fija antes y después de la carrera: medir la distancia entre tres puntos específicos del robot y las paredes permite determinar con precisión su posición y orientación absolutas.</p>
<p>Estas mediciones absolutas se comparan con la posición y la orientación del vehículo, calculadas a partir de los datos odométricos. El resultado es un conjunto de errores de posición de retorno causados ​​por la odometría, denominados <span class="math inline">\(\epsilon_x\)</span>, <span class="math inline">\(\epsilon_y\)</span> y <span class="math inline">\(\epsilon_\theta\)</span></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="trayectoria-cuadrada-unidireccional-2" class="slide level2 smaller">
<h2>Trayectoria cuadrada unidireccional</h2>
<div class="columns">
<div class="column">
<ul>
<li>Al comparar la pose del vehículo medida con la calculada por la odometría se obtiene un conjunto de errores <span class="math inline">\(\epsilon_x\)</span>, <span class="math inline">\(\epsilon_y\)</span> y <span class="math inline">\(\epsilon_\theta\)</span></li>
</ul>
<p><span id="eq-errors"><span class="math display">\[
\begin{gather*}
\epsilon_x = x_{\textrm{abs}} - x_{\textrm{calc}} \\
\epsilon_y = y_{\textrm{abs}} - y_{\textrm{calc}}\\
\epsilon_\theta = \theta_{\textrm{abs}} - \theta_{\textrm{calc}}
\label{eq:errors}
\end{gather*}
\tag{1}\]</span></span></p>
<p>donde:</p>
<ul>
<li><span class="math inline">\(\{x,y,\theta\}_{\textrm{abs}}\)</span>: Posición y orientación absoluta del robot</li>
<li><span class="math inline">\(\{x,y,\theta\}_{\textrm{calc}}\)</span>: Posición y orientación del robot calculada por la odometría</li>
</ul>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura2.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section>
<section id="trayectoria-cuadrada-unidireccional-3" class="slide level2 smaller">
<h2>Trayectoria cuadrada unidireccional</h2>
<div class="columns">
<div class="column">
<ul>
<li>El error <span class="math inline">\(\textcolor{#9467bd}{E_d}\)</span> por diámetros desiguales se muestra en la trayectoria ligeramente curvada (línea punteada)</li>
<li>El error <span class="math inline">\(\textcolor{#d62728}{E_b}\)</span> por incertidumbre sobre la distancia entre ejes provoca un giro deficiente (línea discontinua)</li>
</ul>
<p><br></p>
<div class="fragment">
<div class="callout callout-warning callout-style-simple">
<div class="callout-body">
<div class="callout-icon-container">
<i class="callout-icon"></i>
</div>
<div class="callout-content">
<p>Cualquiera de estos dos errores podría haber producido el mismo error de posición</p>
</div>
</div>
</div>
</div>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura3.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Como se puede ver en la FIGURA, cualquiera de estos dos casos podría haber producido aproximadamente el mismo error de posición. El hecho de que dos mecanismos de error diferentes puedan resultar en el mismo error general puede llevar al experimentador a cometer un grave error: corregir solo una de las dos fuentes de error en el software.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="simple-compensación-de-error" class="slide level2 smaller">
<h2>Simple compensación de error</h2>
<div class="columns">
<div class="column">
<ul>
<li>Se aumenta el valor de <span class="math inline">\(b\)</span> para que el robot “gire más” en cada esquina, a lo que parece ser el valor <em>“ideal”</em></li>
</ul>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura4-ccw.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Este error es tan grave porque producirá resultados aparentemente “excelentes”, como se muestra en el ejemplo de la FIGURA. En este ejemplo, asumimos que el experimentador comenzó a “mejorar” el rendimiento ajustando la distancia entre ejes b en el software de control. El experimentador solo necesita aumentar el valor de b para que el robot gire más en cada giro nominal de 90°. Al hacerlo, el experimentador pronto habrá ajustado b a lo que parece ser el valor “ideal”, es decir, el que hará que el robot gire 93°, compensando así eficazmente el error de orientación de 3° introducido por cada tramo ligeramente curvado (pero nominalmente recto) de la trayectoria cuadrada.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="simple-compensación-de-error-1" class="slide level2 smaller">
<h2>Simple compensación de error</h2>
<div class="columns">
<div class="column">
<ul>
<li>Se aumenta el valor de <span class="math inline">\(b\)</span> para que el robot “gire más” en cada esquina, a lo que parece ser el valor <em>“ideal”</em></li>
<li>El robot <em>“calibrado”</em> tendrá enormes errores de odometría, a pesar de que la trayectoria en un sentido muestre que está bien calibrado</li>
</ul>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura4-cw.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Obviamente, el robot así “calibrado” incurriría en enormes errores de odometría, a pesar de que el procedimiento de calibración unidireccional demostró que el robot estaba bien calibrado.</p>
<p>El problema, por lo tanto, es cómo distinguir y calcular los errores de tipo A y tipo B a partir de los errores de posición final medidos del robot en el experimento de trayectoria cuadrada bidireccional</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section></section>
<section>

<section id="trayectoria-cuadrada-bidireccional-1" class="slide level2 smaller">
<h2>Trayectoria cuadrada bidireccional</h2>
<div class="columns">
<div class="column">
<ul>
<li>Realizar la misma trayectoria, pero en ambos sentidos de giro: horario (<em>CW</em>) y anti-horario (<em>CCW</em>)</li>
<li>Se obtienen conjuntos de errores <span class="math inline">\(\epsilon_x\)</span>, <span class="math inline">\(\epsilon_y\)</span> y <span class="math inline">\(\epsilon_\theta\)</span> para cada sentido</li>
<li><u>Se puede observar</u>:</li>
</ul>
<blockquote>
<ol type="1">
<li>Los errores se agrupan en dos áreas distintas</li>
<li>La distribución dentro de los grupos es el resultado de errores no sistemáticos</li>
</ol>
</blockquote>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura5.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Las posiciones de parada para cinco recorridos, cada uno en sentido horario (cw) y antihorario (ccw), se muestran en la FIGURA.</p>
<p>Los resultados de la FIGURA pueden interpretarse de la siguiente manera: - a. Las posiciones de frenado después de las carreras en sentido horario y antihorario se agrupan en dos áreas distintas. - b. La distribución dentro de los grupos en sentido horario y antihorario es el resultado de errores no sistemáticos, como se menciona en la Sección 2.1. Sin embargo, la FIGURA muestra que, en un vehículo no calibrado que circula sobre un suelo de hormigón razonablemente liso, la contribución de los errores sistemáticos al error odométrico total es notablemente mayor que la de los errores no sistemáticos.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="trayectoria-cuadrada-bidireccional-2" class="slide level2 smaller">
<h2>Trayectoria cuadrada bidireccional</h2>
<div class="columns">
<div class="column">
<ul>
<li>Coordenadas de los centroides</li>
</ul>
<div class="hidden">
<p><span class="math display">\[
\def\ccw#1{{\underset{\scriptsize \textrm{CCW}}{#1}}}
\def\cw#1{{\underset{\scriptsize \textrm{CW}}{#1}}}
\def\ccwcw#1{{\underset{\scriptsize \textrm{CCW|CW}}{#1}}}
\]</span></p>
</div>
<p><span id="eq-x_centroid"><span class="math display">\[
\ccwcw{\bar{x}} = \frac{1}{N} \sum_{i = 1}^N \ccwcw{\epsilon_{x_i}}
\label{eq:x_centroid}
\tag{2}\]</span></span></p>
<p><span id="eq-y_centroid"><span class="math display">\[
\ccwcw{\bar{y}} = \frac{1}{N} \sum_{i = 1}^N \ccwcw{\epsilon_{y_i}}
\label{eq:y_centroid}
\tag{3}\]</span></span> con <span class="math inline">\(N = 3,5,7 \cdots\)</span> la cantidad de repeticiones para cada lado</p>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura5.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
<aside class="notes">
<p>Tras realizar el experimento, se podría derivar un único valor numérico que exprese la precisión odométrica (con respecto a los errores sistemáticos) del vehículo probado. Para minimizar el efecto de los errores no sistemáticos, sugerimos considerar el centroide de cada grupo como representativo de los errores odométricos en las direcciones en sentido horario y antihorario.</p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="trayectoria-cuadrada-bidireccional-3" class="slide level2 smaller">
<h2>Trayectoria cuadrada bidireccional</h2>
<div class="columns">
<div class="column">
<ul>
<li><em>Offset</em> de los centroides con respecto al origen</li>
</ul>
<p><span class="math display">\[
\ccw{\bar{r}} = \sqrt{\ccw{\bar{x}}^2 + \ccw{\bar{y}}^2}
\label{eq:r_ccw_centroid}
\]</span></p>
<p><span class="math display">\[
\cw{\bar{r}} = \sqrt{\cw{\bar{x}}^2 + \cw{\bar{y}}^2}
\label{eq:r_cw_centroid}
\]</span></p>
<ul>
<li>El mayor valor como la medida para errores sistemáticos:</li>
</ul>
<p><span class="math display">\[
E_{\textrm{max,sist.}} = \max{\left( \ccw{\bar{r}}, \cw{\bar{r}} \right)}
\]</span></p>
</div><div class="column">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura5.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section>

<section id="análisis-de-los-errores-sistemáticos-1" class="slide level2 smaller">
<h2>Análisis de los errores sistemáticos</h2>
<ul>
<li><p>Se analizarán los errores por separado y posteriormente se superpondrán para representar condiciones reales</p></li>
<li><p>Utilizaremos aproximaciones de ángulos pequeños (medidos en radianes):</p></li>
</ul>
<p><span class="math display">\[ L\sin{\gamma} \approx L \gamma \qquad L \cos{\gamma} \approx L\]</span></p>
<ul>
<li>Para simplicidad la posición inicial del robot <span class="math inline">\((x_0, y_0) = (0,0)\)</span></li>
</ul>
</section>
<section id="errores-de-tipo-a" class="slide level2 smaller">
<h2>Errores de tipo A</h2>
<ul>
<li>La figura muestra la contribución de los errores de <strong>Tipo A</strong> (asociados a <span class="math inline">\(E_b\)</span>)</li>
<li>Causan un giro excesivo (o insuficiente) en las esquinas</li>
<li>La diferencia de rotación en cada giro de 90° se denota como <span class="math inline">\(\alpha\)</span> (en <span class="math inline">\(\textrm{[rad]}\)</span>).</li>
</ul>
<div class="quarto-layout-panel" data-layout="[[-5,40,-10,40,-5]]">
<div class="quarto-layout-row">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura6.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 10.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura7.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
</section>
<section id="errores-de-tipo-a-1" class="slide level2">
<h2>Errores de tipo A</h2>
<div class="columns">
<div class="column">
<div style="font-size:50%;">
<ul>
<li><p><u>Segmento 1</u>: <span class="math display">\[
\begin{align*}
x_1 &amp;= x_0 + L\\
y_1 &amp;= y_0
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 2</u>: <span class="math display">\[
\begin{align*}
x_2 &amp;= x_1 + L \sin{\alpha} \approx (L) + L\alpha\\
y_2 &amp;= y_1 + L \cos{\alpha} \approx L
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 3</u>: <span class="math display">\[
\begin{align*}
x_3 &amp;= x_2 - L \cos{2 \alpha} \approx (L + L\alpha) - L \approx L\alpha\\
y_3 &amp;= y_2 + L \sin{2 \alpha} \approx (L) + 2 L \alpha
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 4</u>: <span class="math display">\[
\begin{align*}
x_4 &amp;= x_3 - L \sin{3 \alpha} \approx (L\alpha) - 3 L \alpha \approx \boxed{-2 L \alpha}\\
y_4 &amp;= y_3 - L \cos{3 \alpha} \approx (L + 2 L \alpha) - L \approx \boxed{2 L \alpha}
\end{align*}
\]</span></p></li>
</ul>
</div>
</div><div class="column">
<div style="font-size:70%;">
<blockquote>
<p>En sentido anti-horario:</p>
</blockquote>
</div>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura6.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section>
<section id="errores-de-tipo-a-2" class="slide level2">
<h2>Errores de tipo A</h2>
<div class="columns">
<div class="column">
<div style="font-size:50%;">
<ul>
<li><p><u>Segmento 1</u>: <span class="math display">\[
\begin{align*}
x_1 &amp;= x_0 + L\\
y_1 &amp;= y_0
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 2</u>: <span class="math display">\[
\begin{align*}
x_2 &amp;= x_1 + L \sin{\alpha} \approx (L) + L\alpha\\
y_2 &amp;= y_1 - L \cos{\alpha} \approx -L
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 3</u>: <span class="math display">\[
\begin{align*}
x_3 &amp;= x_2 - L \cos{2 \alpha} \approx (L + L\alpha) - L \approx L\alpha\\
y_3 &amp;= y_2 - L \sin{2 \alpha} \approx (-L) - 2 L \alpha \approx -L -2 L \alpha
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 4</u>: <span class="math display">\[
\begin{align*}
x_4 &amp;= x_3 - L \sin{3 \alpha} \approx (L\alpha) - 3 L \alpha \approx \boxed{-2 L \alpha}\\
y_4 &amp;= y_3 + L \cos{3 \alpha} \approx (-L - 2 L \alpha) + L \approx \boxed{-2 L \alpha}
\end{align*}
\]</span></p></li>
</ul>
</div>
</div><div class="column">
<div style="font-size:70%;">
<blockquote>
<p>En sentido horario:</p>
</blockquote>
</div>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura7.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section>
<section id="errores-tipo-b" class="slide level2 smaller">
<h2>Errores tipo B</h2>
<ul>
<li>La figura muestra la contribución de los errores de <strong>Tipo B</strong> (asociados a <span class="math inline">\(E_d\)</span>)</li>
<li>Causan una trayectoria ligeramente curva durante los tramos rectos</li>
<li>El robot adquiere un error de orientación incremental <span class="math inline">\(\beta\)</span> (en <span class="math inline">\(\textrm{[rad]}\)</span>).</li>
</ul>
<div class="quarto-layout-panel" data-layout="[[-5,40,-10,40,-5]]">
<div class="quarto-layout-row">
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura8b.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 10.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
<div class="quarto-layout-cell" style="flex-basis: 40.0%;justify-content: center;">
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura9.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div>
<div class="quarto-figure-spacer quarto-layout-cell" style="flex-basis: 5.0%;justify-content: flex-start;">
<p>&nbsp;</p>
</div>
</div>
</div>
<ul>
<li>La línea auxiliar <span class="math inline">\(c^\prime_1\)</span> (que conecta los vértices de la trayectoria real) tiene una pendiente de <span class="math inline">\(\beta/2\)</span></li>
</ul>
</section>
<section id="errores-tipo-b-1" class="slide level2">
<h2>Errores tipo B</h2>
<div class="columns">
<div class="column">
<div style="font-size:50%;">
<ul>
<li><p><u>Segmento 1</u>: <span class="math display">\[
\begin{align*}
x_1 &amp;= x_0 + L \cos{\beta/2} \approx L\\
y_1 &amp;= y_0 + L \sin{\beta/2} \approx L \beta / 2
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 2</u>: <span class="math display">\[
\begin{align*}
x_2 &amp;= x_1 - L \sin{3 \beta/2} \approx L - L \beta/2\\
y_2 &amp;= y_1 + L \cos{3 \beta/2} \approx L \beta/2 + L
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 3</u>: <span class="math display">\[
\begin{align*}
x_3 &amp;= x_2 - L \cos{5 \beta/2} \approx -3 L \beta/2 \\
y_3 &amp;= y_2 - L \sin{5 \beta/2} \approx -2 L \beta/2 + L
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 4</u>: <span class="math display">\[
\begin{align*}
x_4 &amp;= x_3 + L \sin{7 \beta/2} \approx \boxed{2 L \beta}\\
y_4 &amp;= y_3 - L \cos{7 \beta/2} \approx \boxed{-2 L \beta}
\end{align*}
\]</span></p></li>
</ul>
</div>
</div><div class="column">
<div style="font-size:70%;">
<blockquote>
<p>En sentido anti-horario:</p>
</blockquote>
</div>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura8a.svg" class="quarto-figure quarto-figure-center" style="width:70.0%"></p>
</figure>
</div>
</div></div>
</section>
<section id="errores-tipo-b-2" class="slide level2">
<h2>Errores tipo B</h2>
<div class="columns">
<div class="column">
<div style="font-size:50%;">
<ul>
<li><p><u>Segmento 1</u>: <span class="math display">\[
\begin{align*}
x_1 &amp;= x_0 + L \cos{\beta/2} \approx L\\
y_1 &amp;= y_0 + L \sin{\beta/2} \approx L \beta / 2
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 2</u>: <span class="math display">\[
\begin{align*}
x_2 &amp;= x_1 + L \sin{3 \beta/2} \approx L + 3 L \beta/2\\
y_2 &amp;= y_1 - L \cos{3 \beta/2} \approx L \beta/2 - L
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 3</u>: <span class="math display">\[
\begin{align*}
x_3 &amp;= x_2 - L \cos{5 \beta/2} \approx  3 L \beta/2 \\
y_3 &amp;= y_2 - L \sin{5 \beta/2} \approx -L (\beta/2 + 1)
\end{align*}
\]</span></p></li>
<li><p><u>Segmento 4</u>: <span class="math display">\[
\begin{align*}
x_4 &amp;= x_3 - L \sin{7 \beta/2} \approx \boxed{-2 L \beta}\\
y_4 &amp;= y_3 + L \cos{7 \beta/2} \approx \boxed{-2 L \beta}
\end{align*}
\]</span></p></li>
</ul>
</div>
</div><div class="column">
<div style="font-size:70%;">
<blockquote>
<p>En sentido horario:</p>
</blockquote>
</div>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura9.svg" class="quarto-figure quarto-figure-center" style="width:70.0%"></p>
</figure>
</div>
</div></div>
</section></section>
<section>

<section id="corrección-de-errores-de-tipo-a" class="slide level2">
<h2>Corrección de errores de Tipo A</h2>
<div style="font-size:70%;">
<ul>
<li>Error de <strong>Tipo A</strong> y <strong>Tipo B</strong> para la dirección <span class="math inline">\(x\)</span> en trayectoria con sentido horario y anti-horario:</li>
</ul>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;\textrm{A)} \, \cw{x} &amp;= -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \cw{x} &amp;= -2 L \beta \\
&amp;\textrm{A)} \, \ccw{x} &amp;= -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \ccw{x} &amp;= 2 L \beta
\end{alignat}
\]</span></p>
<ul>
<li>Superponiendo ambos tipos de error y <u>sumando</u> ambas expresiones:</li>
</ul>
<p><span id="eq-alpha_x"><span class="math display">\[
\left.
\begin{alignat}{3}
&amp;\cw{\textrm{x:}} \, -&amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \cw{\bar{x}} \\
&amp;\ccw{\textrm{x:}} \, -&amp;2 L \alpha + &amp;2 L \beta
&amp;&amp;= \ccw{\bar{x}}
\end{alignat}
\right\}
-4 L \alpha = \cw{\bar{x}} + \ccw{\bar{x}} \to \alpha = \frac{\cw{\bar{x}} + \ccw{\bar{x}}}{-4L}
\tag{4}\]</span></span></p>
</div>
</section>
<section id="corrección-de-errores-de-tipo-a-1" class="slide level2">
<h2>Corrección de errores de Tipo A</h2>
<div style="font-size:70%;">
<ul>
<li>El mismo análisis para la dirección <span class="math inline">\(y\)</span> muestra un resultado similar:</li>
</ul>
<p><span class="math display">\[
\begin{alignat}{3}
&amp;\textrm{A)} \, &amp;\cw{y} &amp;= -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \cw{y} &amp;= -2 L \beta \\
&amp;\textrm{A)} \, &amp;\ccw{y} &amp;= 2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \ccw{y} &amp;= - 2 L \beta
\end{alignat}
\]</span></p>
<ul>
<li>Superponiendo ambos tipos de error y <u>restando</u> ambas expresiones:</li>
</ul>
<p><span id="eq-alpha_y"><span class="math display">\[
\left.
\begin{alignat}{4}
&amp;\cw{\textrm{y:}} \, -&amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \cw{\bar{y}} \\
&amp;\ccw{\textrm{y:}} \, &amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \ccw{\bar{y}}
\end{alignat}
\right\}
-4 L \alpha = \cw{\bar{y}} - \ccw{\bar{y}} \to \alpha = \frac{\cw{\bar{y}} - \ccw{\bar{y}}}{-4L}
\tag{5}\]</span></span></p>
</div>
</section>
<section id="corrección-de-errores-de-tipo-a-2" class="slide level2">
<h2>Corrección de errores de Tipo A</h2>
<div style="font-size:70%;">
<ul>
<li>Dado que la distancia entre ejes <span class="math inline">\(b\)</span> es inversamente proporcional a la rotación real</li>
</ul>
<p><span id="eq-b_actual"><span class="math display">\[
\frac{b_{\textrm{actual}}}{\pi / 2} = \frac{b_{\textrm{nominal}}}{\pi / 2 - \alpha} \to b_{\textrm{actual}} = \frac{\pi / 2}{\pi / 2 - \alpha} b_{\textrm{nominal}}
\tag{6}\]</span></span></p>
<p>y por lo tanto:</p>
<p><span id="eq-E_b_alpha"><span class="math display">\[
E_b = \frac{\pi / 2}{\pi / 2 - \alpha}
\tag{7}\]</span></span></p>
</div>
</section>
<section id="corrección-de-errores-tipo-b" class="slide level2">
<h2>Corrección de errores Tipo B</h2>
<div style="font-size:70%;">
<ul>
<li>Análisis similar al anterior para la dirección en <span class="math inline">\(x\)</span></li>
</ul>
<p><span class="math display">\[
\begin{alignat}{2}
&amp;\textrm{A)} \, &amp;\cw{x} = -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, &amp;\cw{x} &amp;= -2 L \beta \\
&amp;\textrm{A)} \, &amp;\ccw{x} = -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, &amp;\ccw{x} &amp;= 2 L \beta
\end{alignat}
\]</span></p>
<ul>
<li>Superponiendo ambos tipos de error y <u>restando</u> ambas expresiones:</li>
</ul>
<p><span id="eq-beta_x"><span class="math display">\[
\left.
\begin{alignat}{3}
&amp;\cw{\textrm{x:}} \, -&amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \cw{\bar{x}} \\
&amp;\ccw{\textrm{x:}} \, -&amp;2 L \alpha + &amp;2 L \beta
&amp;&amp;= \ccw{\bar{x}}
\end{alignat}
\right\}
-4 L \beta = \cw{\bar{x}} - \ccw{\bar{x}} \to \beta = \frac{\cw{\bar{x}} - \ccw{\bar{x}}}{-4L}
\tag{8}\]</span></span></p>
</div>
</section>
<section id="corrección-de-errores-tipo-b-1" class="slide level2">
<h2>Corrección de errores Tipo B</h2>
<div style="font-size:70%;">
<ul>
<li>El mismo procedimiento para la dirección en <span class="math inline">\(y\)</span> arroja un resultado similar</li>
</ul>
<p><span class="math display">\[
\begin{alignat}{3}
&amp;\textrm{A)} \, &amp;\cw{y} &amp;= -2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \cw{y} &amp;= -2 L \beta \\
&amp;\textrm{A)} \, &amp;\ccw{y} &amp;= 2 L \alpha \qquad &amp;&amp;\textrm{B)} \, \ccw{y} &amp;= - 2 L \beta
\end{alignat}
\]</span></p>
<ul>
<li>Superponiendo ambos tipos de error y <u>sumando</u> ambas expresiones:</li>
</ul>
<p><span id="eq-beta_y"><span class="math display">\[
\left.
\begin{alignat}{4}
&amp;\cw{\textrm{y:}} \, -&amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \cw{\bar{y}} \\
&amp;\ccw{\textrm{y:}} \, &amp;2 L \alpha - &amp;2 L \beta
&amp;&amp;= \ccw{\bar{y}}
\end{alignat}
\right\}
-4 L \beta = \cw{\bar{y}} + \ccw{\bar{y}} \to \beta = \frac{\cw{\bar{y}} + \ccw{\bar{y}}}{-4L}
\tag{9}\]</span></span></p>
</div>
</section>
<section id="corrección-de-errores-tipo-b-2" class="slide level2 smaller">
<h2>Corrección de errores Tipo B</h2>
<div class="columns">
<div class="column">
<ul>
<li><p>El radio de curvatura <span class="math inline">\(R\)</span> de las trayectorias en linea recta se puede encontrar a partir del triángulo <span class="math inline">\(\overset{\triangle}{ABM}\)</span> en la figura <span id="eq-R_beta"><span class="math display">\[
R = \frac{L/2}{\sin(\beta/2)}
\tag{10}\]</span></span></p></li>
<li><p>Para determinar la relación entre los diámetros de las ruedas:</p></li>
</ul>
<p><span id="eq-E_d_R"><span class="math display">\[
E_d = \frac{D_R}{D_L} = \frac{R + b/2}{R - b/2}
\label{eq:wheel_correction}
\tag{11}\]</span></span></p>
<div class="callout callout-tip no-icon callout-style-simple">
<div class="callout-body">
<div class="callout-content">
<p>Esta relación se puede utilizar para corregir errores de <strong>Tipo B</strong></p>
</div>
</div>
</div>
</div><div class="column">
<p><br></p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figura9.png" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section>
<section id="corrección-de-ambos-tipo-de-error" class="slide level2 smaller">
<h2>Corrección de ambos tipo de error</h2>
<ul>
<li>La corrección del error de distancia entre ejes <span class="math inline">\(E_b\)</span> es trivial</li>
</ul>
<blockquote>
<p>La distancia entre ejes <span class="math inline">\(b\)</span> se redefine según la ecuación: <span class="math display">\[
b_{\textrm{actual}} = \frac{\pi / 2}{\pi / 2 - \alpha} b_{\textrm{nominal}}
\]</span></p>
</blockquote>
<ul>
<li>La corrección para los diámetros de rueda desiguales <span class="math inline">\(E_d\)</span> es más compleja</li>
</ul>
<blockquote>
<p>Al aplicar un factor de compensación, debemos asegurarnos de no modificar el diámetro medio de la rueda <span class="math inline">\(D_a = (D_R + D_L)/2\)</span></p>
</blockquote>
<aside class="notes">
<p>Una vez conocidos los valores cuantitativos de <span class="math inline">\(E_d\)</span> y <span class="math inline">\(E_b\)</span>, es fácil compensar estos errores en el software.</p>
<p>La corrección del error de distancia entre ejes <span class="math inline">\(E_b\)</span> es trivial: la distancia entre ejes <span class="math inline">\(b\)</span> se redefine en el software según la ecuación <span class="math inline">\(\ref{eq:new_b}\)</span>.</p>
<p>La corrección para los diámetros de rueda desiguales, <span class="math inline">\(E_d\)</span>, es ligeramente más compleja. Tras realizar los experimentos bidireccionales, se conoce la relación real de los diámetros de la ruedas <span class="math inline">\(E_d = D_R/D_L\)</span> a partir de la ecuación <span class="math inline">\(\ref{eq:wheel_correction}\)</span>. Sin embargo, al aplicar un factor de compensación, debemos asegurarnos de no modificar el diámetro medio de la rueda <span class="math inline">\(D_a\)</span>, ya que sería necesario recalibrar dicho parámetro. Por lo tanto <span class="math inline">\(D_a = (D_R + D_L)/2\)</span></p>
<style type="text/css">
        span.MJX_Assistive_MathML {
          position:absolute!important;
          clip: rect(1px, 1px, 1px, 1px);
          padding: 1px 0 0 0!important;
          border: 0!important;
          height: 1px!important;
          width: 1px!important;
          overflow: hidden!important;
          display:block!important;
      }</style></aside>
</section>
<section id="corrección-de-ambos-tipo-de-error-1" class="slide level2 smaller">
<h2>Corrección de ambos tipo de error</h2>
<ul>
<li>Resolviendo</li>
</ul>
<p><span class="math display">\[
\left.
\begin{aligned}
D_a = (D_R + D_L)/2 \\
E_d = \frac{D_R}{D_L}
\end{aligned}
\right\}
E_d D_L + \frac{D_R}{E_d} = 2 D_a
\]</span></p>
<ul>
<li>Se obtiene</li>
</ul>
<p><span class="math display">\[
\begin{align*}
E_d D_L + D_L = 2 D_a &amp;\to D_L = \frac{2}{E_d +1} D_a \\
D_R + \frac{D_R}{E_d} = 2 D_a &amp;\to D_R = \frac{2}{\frac{1}{E_d} +1} D_a
\end{align*}
\]</span></p>
</section>
<section id="corrección-de-ambos-tipo-de-error-2" class="slide level2 smaller">
<h2>Corrección de ambos tipo de error</h2>
<ul>
<li>Se definen dos factores de corrección:</li>
</ul>
<p><span id="eq-cL_cR"><span class="math display">\[
\begin{align*}
c_L &amp;= \frac{2}{E_d + 1} \\
c_R &amp;= \frac{2}{\frac{1}{E_d} + 1}
\end{align*}
\tag{12}\]</span></span></p>
<ul>
<li>Se re-escribe la ecuación de desplazamiento lineal de las ruedas:</li>
</ul>
<p><span class="math display">\[
\Delta s_{L|R,i} = \pi \cdot D_{L|R} \cdot \frac{N_{L|R, i}}{c_e} \cdot c_{L|R}
\]</span></p>
</section>
<section id="resumen-del-procedimiento" class="slide level2 smaller">
<h2>Resumen del procedimiento</h2>
<ol type="1">
<li>Medir la posición absoluta del vehículo.</li>
<li>Realizar la trayectoria cuadrada de 4x4 [m] en <u>sentido horario</u>, asegurándose de:
<ul>
<li>detenerse después de cada tramo recto de 4[m]</li>
<li>realizar un total de cuatro giros de 90° en la esquina</li>
<li>conducir el robot lentamente para evitar deslizamientos</li>
</ul></li>
<li>Al regresar a la zona de inicio, medir la posición absoluta del vehículo.</li>
<li>Compare la posición absoluta con la posición calculada del robot utilizando las ecuaciones en <a href="#/eq-errors" class="quarto-xref">1</a>.</li>
<li>Repita los pasos 1 a 4 cuatro veces más</li>
<li>Repita los pasos 1 a 5 en <u>sentido antihorario</u></li>
<li>Utilice las ecuaciones <a href="#/eq-x_centroid" class="quarto-xref">2</a>, <a href="#/eq-y_centroid" class="quarto-xref">3</a> para obtener <span class="math inline">\(\ccwcw{\bar{x}}\)</span> y <span class="math inline">\(\ccwcw{\bar{y}}\)</span></li>
</ol>
</section>
<section id="resumen-del-procedimiento-1" class="slide level2 smaller">
<h2>Resumen del procedimiento</h2>
<div class="columns">
<div class="column">
<ol start="8" type="1">
<li><p>Con <span class="math inline">\(\alpha\)</span> (ec. <a href="#/eq-alpha_x" class="quarto-xref">4</a> o <a href="#/eq-alpha_y" class="quarto-xref">5</a>), obtener el nuevo valor de <span class="math inline">\(b\)</span> (<a href="#/eq-b_actual" class="quarto-xref">6</a>): <span class="math display">\[
b_{\textrm{actual}} = \frac{\pi / 2}{\pi / 2 - \alpha} b_{\textrm{nominal}}
\]</span></p></li>
<li><p>Con <span class="math inline">\(\beta\)</span> (ec. <a href="#/eq-beta_x" class="quarto-xref">8</a> o <a href="#/eq-beta_y" class="quarto-xref">9</a>), <span class="math inline">\(R\)</span> (<a href="#/eq-R_beta" class="quarto-xref">10</a>) y <span class="math inline">\(E_d\)</span> (<a href="#/eq-E_d_R" class="quarto-xref">11</a>), obtener los coeficientes de corrección <span class="math inline">\(c_L\)</span> y <span class="math inline">\(c_R\)</span> (<a href="#/eq-cL_cR" class="quarto-xref">12</a>): <span class="math display">\[
\begin{align*}
c_L &amp;= \frac{2}{E_d + 1} \\
c_R &amp;= \frac{2}{\frac{1}{E_d} + 1}
\end{align*}
\]</span></p></li>
</ol>
</div><div class="column">
<p><br></p>
<div class="quarto-figure quarto-figure-center">
<figure>
<p><img data-src="figs/figura11.svg" class="quarto-figure quarto-figure-center"></p>
</figure>
</div>
</div></div>
</section></section>
<section>

<section id="referencias-1" class="slide level2 smaller scrollable">
<h2>Referencias</h2>
<div id="refs" class="references csl-bib-body hanging-indent" data-entry-spacing="0" role="list">
<div id="ref-544770" class="csl-entry" role="listitem">
Borenstein, J., and Liqiang Feng. 1996. <span>“Measurement and Correction of Systematic Odometry Errors in Mobile Robots.”</span> <em>IEEE Transactions on Robotics and Automation</em> 12 (6): 869–80. <a href="https://doi.org/10.1109/70.544770">https://doi.org/10.1109/70.544770</a>.
</div>
<div id="ref-Borenstein1996WhereAI" class="csl-entry" role="listitem">
Borenstein, Johann, Hobart R. Everett, and Liqiang Feng. 1996. <span>“Where Am i?" Sensors and Methods for Mobile Robot Positioning.”</span> In. <a href="https://api.semanticscholar.org/CorpusID:59906505">https://api.semanticscholar.org/CorpusID:59906505</a>.
</div>
<div id="ref-Borenstein1997MobileRP" class="csl-entry" role="listitem">
Borenstein, Johann, Hobart R. Everett, Liqiang Feng, and David K. Wehe. 1997. <span>“Mobile Robot Positioning: Sensors and Techniques.”</span> <em>J. Field Robotics</em> 14: 231–49. <a href="https://api.semanticscholar.org/CorpusID:1045982">https://api.semanticscholar.org/CorpusID:1045982</a>.
</div>
<div id="ref-606708" class="csl-entry" role="listitem">
Chong, Kok Seng, and L. Kleeman. 1997. <span>“Accurate Odometry and Error Modelling for a Mobile Robot.”</span> In <em>Proceedings of International Conference on Robotics and Automation</em>, 4:2783–2788 vol.4. <a href="https://doi.org/10.1109/ROBOT.1997.606708">https://doi.org/10.1109/ROBOT.1997.606708</a>.
</div>
</div>
</section></section>
<section>

<section id="laboratorio-1" class="slide level2 center">
<h2><a href="../../clases/16/lab.html">Laboratorio</a></h2>
<p>Calibración de odometría</p>


</section></section>
    </div>
  <div class="quarto-auto-generated-content" style="display: none;">
<div class="footer footer-default">
<p>Robótica - TUAR - FICH - UNL</p>
</div>
</div></div>

  <script>window.backupDefine = window.define; window.define = undefined;</script>
  <script src="../../site_libs/revealjs/dist/reveal.js"></script>
  <!-- reveal.js plugins -->
  <script src="../../site_libs/revealjs/plugin/quarto-line-highlight/line-highlight.js"></script>
  <script src="../../site_libs/revealjs/plugin/pdf-export/pdfexport.js"></script>
  <script src="../../site_libs/revealjs/plugin/reveal-menu/menu.js"></script>
  <script src="../../site_libs/revealjs/plugin/reveal-menu/quarto-menu.js"></script>
  <script src="../../site_libs/revealjs/plugin/quarto-support/support.js"></script>
  

  <script src="../../site_libs/revealjs/plugin/notes/notes.js"></script>
  <script src="../../site_libs/revealjs/plugin/search/search.js"></script>
  <script src="../../site_libs/revealjs/plugin/zoom/zoom.js"></script>
  <script src="../../site_libs/revealjs/plugin/math/math.js"></script>
  <script>window.define = window.backupDefine; window.backupDefine = undefined;</script>

  <script>

      // Full list of configuration options available at:
      // https://revealjs.com/config/
      Reveal.initialize({
'controlsAuto': true,
'previewLinksAuto': false,
'pdfSeparateFragments': false,
'autoAnimateEasing': "ease",
'autoAnimateDuration': 1,
'autoAnimateUnmatched': true,
'jumpToSlide': true,
'menu': {"side":"left","useTextContentForMissingTitles":true,"markers":false,"loadIcons":false,"custom":[{"title":"Tools","icon":"<i class=\"fas fa-gear\"></i>","content":"<ul class=\"slide-menu-items\">\n<li class=\"slide-tool-item active\" data-item=\"0\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.fullscreen(event)\"><kbd>f</kbd> Fullscreen</a></li>\n<li class=\"slide-tool-item\" data-item=\"1\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.speakerMode(event)\"><kbd>s</kbd> Speaker View</a></li>\n<li class=\"slide-tool-item\" data-item=\"2\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.overview(event)\"><kbd>o</kbd> Slide Overview</a></li>\n<li class=\"slide-tool-item\" data-item=\"3\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.togglePdfExport(event)\"><kbd>e</kbd> PDF Export Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"4\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.toggleScrollView(event)\"><kbd>r</kbd> Scroll View Mode</a></li>\n<li class=\"slide-tool-item\" data-item=\"5\"><a href=\"#\" onclick=\"RevealMenuToolHandlers.keyboardHelp(event)\"><kbd>?</kbd> Keyboard Help</a></li>\n</ul>"}],"openButton":false},
'smaller': false,
 
        // Display controls in the bottom right corner
        controls: false,

        // Help the user learn the controls by providing hints, for example by
        // bouncing the down arrow when they first encounter a vertical slide
        controlsTutorial: false,

        // Determines where controls appear, "edges" or "bottom-right"
        controlsLayout: 'edges',

        // Visibility rule for backwards navigation arrows; "faded", "hidden"
        // or "visible"
        controlsBackArrows: 'faded',

        // Display a presentation progress bar
        progress: true,

        // Display the page number of the current slide
        slideNumber: 'c',

        // 'all', 'print', or 'speaker'
        showSlideNumber: 'all',

        // Add the current slide number to the URL hash so that reloading the
        // page/copying the URL will return you to the same slide
        hash: true,

        // Start with 1 for the hash rather than 0
        hashOneBasedIndex: false,

        // Flags if we should monitor the hash and change slides accordingly
        respondToHashChanges: true,

        // Push each slide change to the browser history
        history: true,

        // Enable keyboard shortcuts for navigation
        keyboard: true,

        // Enable the slide overview mode
        overview: true,

        // Disables the default reveal.js slide layout (scaling and centering)
        // so that you can use custom CSS layout
        disableLayout: false,

        // Vertical centering of slides
        center: false,

        // Enables touch navigation on devices with touch input
        touch: true,

        // Loop the presentation
        loop: false,

        // Change the presentation direction to be RTL
        rtl: false,

        // see https://revealjs.com/vertical-slides/#navigation-mode
        navigationMode: 'linear',

        // Randomizes the order of slides each time the presentation loads
        shuffle: false,

        // Turns fragments on and off globally
        fragments: true,

        // Flags whether to include the current fragment in the URL,
        // so that reloading brings you to the same fragment position
        fragmentInURL: false,

        // Flags if the presentation is running in an embedded mode,
        // i.e. contained within a limited portion of the screen
        embedded: false,

        // Flags if we should show a help overlay when the questionmark
        // key is pressed
        help: true,

        // Flags if it should be possible to pause the presentation (blackout)
        pause: true,

        // Flags if speaker notes should be visible to all viewers
        showNotes: false,

        // Global override for autoplaying embedded media (null/true/false)
        autoPlayMedia: null,

        // Global override for preloading lazy-loaded iframes (null/true/false)
        preloadIframes: null,

        // Number of milliseconds between automatically proceeding to the
        // next slide, disabled when set to 0, this value can be overwritten
        // by using a data-autoslide attribute on your slides
        autoSlide: 0,

        // Stop auto-sliding after user input
        autoSlideStoppable: true,

        // Use this method for navigation when auto-sliding
        autoSlideMethod: null,

        // Specify the average time in seconds that you think you will spend
        // presenting each slide. This is used to show a pacing timer in the
        // speaker view
        defaultTiming: null,

        // Enable slide navigation via mouse wheel
        mouseWheel: false,

        // The display mode that will be used to show slides
        display: 'block',

        // Hide cursor if inactive
        hideInactiveCursor: true,

        // Time before the cursor is hidden (in ms)
        hideCursorTime: 5000,

        // Opens links in an iframe preview overlay
        previewLinks: false,

        // Transition style (none/fade/slide/convex/concave/zoom)
        transition: 'none',

        // Transition speed (default/fast/slow)
        transitionSpeed: 'default',

        // Transition style for full page slide backgrounds
        // (none/fade/slide/convex/concave/zoom)
        backgroundTransition: 'none',

        // Number of slides away from the current that are visible
        viewDistance: 3,

        // Number of slides away from the current that are visible on mobile
        // devices. It is advisable to set this to a lower number than
        // viewDistance in order to save resources.
        mobileViewDistance: 2,

        // The "normal" size of the presentation, aspect ratio will be preserved
        // when the presentation is scaled to fit different resolutions. Can be
        // specified using percentage units.
        width: 1050,

        height: 700,

        // Factor of the display size that should remain empty around the content
        margin: 0.1,

        math: {
          mathjax: 'https://cdn.jsdelivr.net/npm/mathjax@2.7.9/MathJax.js',
          config: 'TeX-AMS_HTML-full',
          tex2jax: {
            inlineMath: [['\\(','\\)']],
            displayMath: [['\\[','\\]']],
            balanceBraces: true,
            processEscapes: false,
            processRefs: true,
            processEnvironments: true,
            preview: 'TeX',
            skipTags: ['script','noscript','style','textarea','pre','code'],
            ignoreClass: 'tex2jax_ignore',
            processClass: 'tex2jax_process'
          },
        },

        // reveal.js plugins
        plugins: [QuartoLineHighlight, PdfExport, RevealMenu, QuartoSupport,

          RevealMath,
          RevealNotes,
          RevealSearch,
          RevealZoom
        ]
      });
    </script>
    <script id="quarto-html-after-body" type="application/javascript">
      window.document.addEventListener("DOMContentLoaded", function (event) {
        const tabsets =  window.document.querySelectorAll(".panel-tabset-tabby")
        tabsets.forEach(function(tabset) {
          const tabby = new Tabby('#' + tabset.id);
        });
          var localhostRegex = new RegExp(/^(?:http|https):\/\/localhost\:?[0-9]*\//);
          var mailtoRegex = new RegExp(/^mailto:/);
            var filterRegex = new RegExp("https:\/\/acapovilla\.github\.io\/robotica-2025\/");
          var isInternal = (href) => {
              return filterRegex.test(href) || localhostRegex.test(href) || mailtoRegex.test(href);
          }
          // Inspect non-navigation links and adorn them if external
         var links = window.document.querySelectorAll('a[href]:not(.nav-link):not(.navbar-brand):not(.toc-action):not(.sidebar-link):not(.sidebar-item-toggle):not(.pagination-link):not(.no-external):not([aria-hidden]):not(.dropdown-item):not(.quarto-navigation-tool):not(.about-link)');
          for (var i=0; i<links.length; i++) {
            const link = links[i];
            if (!isInternal(link.href)) {
              // undo the damage that might have been done by quarto-nav.js in the case of
              // links that we want to consider external
              if (link.dataset.originalHref !== undefined) {
                link.href = link.dataset.originalHref;
              }
            }
          }
        function tippyHover(el, contentFn, onTriggerFn, onUntriggerFn) {
          const config = {
            allowHTML: true,
            maxWidth: 500,
            delay: 100,
            arrow: false,
            appendTo: function(el) {
                return el.closest('section.slide') || el.parentElement;
            },
            interactive: true,
            interactiveBorder: 10,
            theme: 'light-border',
            placement: 'bottom-start',
          };
          if (contentFn) {
            config.content = contentFn;
          }
          if (onTriggerFn) {
            config.onTrigger = onTriggerFn;
          }
          if (onUntriggerFn) {
            config.onUntrigger = onUntriggerFn;
          }
            config['offset'] = [0,0];
            config['maxWidth'] = 700;
          window.tippy(el, config); 
        }
        const noterefs = window.document.querySelectorAll('a[role="doc-noteref"]');
        for (var i=0; i<noterefs.length; i++) {
          const ref = noterefs[i];
          tippyHover(ref, function() {
            // use id or data attribute instead here
            let href = ref.getAttribute('data-footnote-href') || ref.getAttribute('href');
            try { href = new URL(href).hash; } catch {}
            const id = href.replace(/^#\/?/, "");
            const note = window.document.getElementById(id);
            if (note) {
              return note.innerHTML;
            } else {
              return "";
            }
          });
        }
        const findCites = (el) => {
          const parentEl = el.parentElement;
          if (parentEl) {
            const cites = parentEl.dataset.cites;
            if (cites) {
              return {
                el,
                cites: cites.split(' ')
              };
            } else {
              return findCites(el.parentElement)
            }
          } else {
            return undefined;
          }
        };
        var bibliorefs = window.document.querySelectorAll('a[role="doc-biblioref"]');
        for (var i=0; i<bibliorefs.length; i++) {
          const ref = bibliorefs[i];
          const citeInfo = findCites(ref);
          if (citeInfo) {
            tippyHover(citeInfo.el, function() {
              var popup = window.document.createElement('div');
              citeInfo.cites.forEach(function(cite) {
                var citeDiv = window.document.createElement('div');
                citeDiv.classList.add('hanging-indent');
                citeDiv.classList.add('csl-entry');
                var biblioDiv = window.document.getElementById('ref-' + cite);
                if (biblioDiv) {
                  citeDiv.innerHTML = biblioDiv.innerHTML;
                }
                popup.appendChild(citeDiv);
              });
              return popup.innerHTML;
            });
          }
        }
      });
      </script>
    

</body></html>